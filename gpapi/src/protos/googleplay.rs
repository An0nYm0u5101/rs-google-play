// This file is generated by rust-protobuf 3.0.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AckNotificationResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AckNotificationResponse {
    pub fn new() -> AckNotificationResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AckNotificationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckNotificationResponse {
        AckNotificationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<AckNotificationResponse>(
                "AckNotificationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AckNotificationResponse {
        static instance: ::protobuf::rt::Lazy<AckNotificationResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(AckNotificationResponse::new)
    }
}

impl ::protobuf::Clear for AckNotificationResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckNotificationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckNotificationResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AndroidAppDeliveryData {
    // message fields
    pub downloadSize: ::std::option::Option<i64>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub additionalFile: ::protobuf::RepeatedField<AppFileMetadata>,
    pub downloadAuthCookie: ::protobuf::RepeatedField<HttpCookie>,
    pub forwardLocked: ::std::option::Option<bool>,
    pub refundTimeout: ::std::option::Option<i64>,
    pub serverInitiated: ::std::option::Option<bool>,
    pub postInstallRefundWindowMillis: ::std::option::Option<i64>,
    pub immediateStartNeeded: ::std::option::Option<bool>,
    pub patchData: ::protobuf::SingularPtrField<AndroidAppPatchData>,
    pub encryptionParams: ::protobuf::SingularPtrField<EncryptionParams>,
    pub gzippedDownloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub gzippedDownloadSize: ::std::option::Option<i64>,
    pub splitDeliveryData: ::protobuf::RepeatedField<SplitDeliveryData>,
    pub installLocation: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AndroidAppDeliveryData {
    pub fn new() -> AndroidAppDeliveryData {
        ::std::default::Default::default()
    }

    // optional int64 downloadSize = 1;

    pub fn get_downloadSize(&self) -> i64 {
        self.downloadSize.unwrap_or(0)
    }

    // optional string signature = 2;

    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string downloadUrl = 3;

    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool forwardLocked = 6;

    pub fn get_forwardLocked(&self) -> bool {
        self.forwardLocked.unwrap_or(false)
    }

    // optional int64 refundTimeout = 7;

    pub fn get_refundTimeout(&self) -> i64 {
        self.refundTimeout.unwrap_or(0)
    }

    // optional bool serverInitiated = 8;

    pub fn get_serverInitiated(&self) -> bool {
        self.serverInitiated.unwrap_or(false)
    }

    // optional int64 postInstallRefundWindowMillis = 9;

    pub fn get_postInstallRefundWindowMillis(&self) -> i64 {
        self.postInstallRefundWindowMillis.unwrap_or(0)
    }

    // optional bool immediateStartNeeded = 10;

    pub fn get_immediateStartNeeded(&self) -> bool {
        self.immediateStartNeeded.unwrap_or(false)
    }

    // optional string gzippedDownloadUrl = 13;

    pub fn get_gzippedDownloadUrl(&self) -> &str {
        match self.gzippedDownloadUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 gzippedDownloadSize = 14;

    pub fn get_gzippedDownloadSize(&self) -> i64 {
        self.gzippedDownloadSize.unwrap_or(0)
    }

    // optional int32 installLocation = 16;

    pub fn get_installLocation(&self) -> i32 {
        self.installLocation.unwrap_or(0)
    }
}

impl ::protobuf::Message for AndroidAppDeliveryData {
    fn is_initialized(&self) -> bool {
        for v in &self.additionalFile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downloadAuthCookie {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patchData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryptionParams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.splitDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloadSize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.additionalFile)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.downloadAuthCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forwardLocked = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeout = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.serverInitiated = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postInstallRefundWindowMillis = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.immediateStartNeeded = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<AndroidAppPatchData, _>(wire_type, is, &mut self.patchData)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<EncryptionParams, _>(wire_type, is, &mut self.encryptionParams)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gzippedDownloadUrl)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gzippedDownloadSize = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.splitDeliveryData)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.installLocation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.downloadSize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.additionalFile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.downloadAuthCookie {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.forwardLocked {
            my_size += 2;
        }
        if let Some(v) = self.refundTimeout {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serverInitiated {
            my_size += 2;
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.immediateStartNeeded {
            my_size += 2;
        }
        if let Some(v) = self.patchData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.encryptionParams.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.gzippedDownloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.gzippedDownloadSize {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.splitDeliveryData {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.installLocation {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.downloadSize {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.additionalFile {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.downloadAuthCookie {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.forwardLocked {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.refundTimeout {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.serverInitiated {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.immediateStartNeeded {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.patchData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.encryptionParams.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.gzippedDownloadUrl.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.gzippedDownloadSize {
            os.write_int64(14, v)?;
        }
        for v in &self.splitDeliveryData {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.installLocation {
            os.write_int32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppDeliveryData {
        AndroidAppDeliveryData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "downloadSize",
                |m: &AndroidAppDeliveryData| { &m.downloadSize },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadSize },
                AndroidAppDeliveryData::get_downloadSize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signature",
                |m: &AndroidAppDeliveryData| { &m.signature },
                |m: &mut AndroidAppDeliveryData| { &mut m.signature },
                AndroidAppDeliveryData::get_signature,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadUrl",
                |m: &AndroidAppDeliveryData| { &m.downloadUrl },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadUrl },
                AndroidAppDeliveryData::get_downloadUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppFileMetadata>>(
                "additionalFile",
                |m: &AndroidAppDeliveryData| { &m.additionalFile },
                |m: &mut AndroidAppDeliveryData| { &mut m.additionalFile },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HttpCookie>>(
                "downloadAuthCookie",
                |m: &AndroidAppDeliveryData| { &m.downloadAuthCookie },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadAuthCookie },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "forwardLocked",
                |m: &AndroidAppDeliveryData| { &m.forwardLocked },
                |m: &mut AndroidAppDeliveryData| { &mut m.forwardLocked },
                AndroidAppDeliveryData::get_forwardLocked,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "refundTimeout",
                |m: &AndroidAppDeliveryData| { &m.refundTimeout },
                |m: &mut AndroidAppDeliveryData| { &mut m.refundTimeout },
                AndroidAppDeliveryData::get_refundTimeout,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "serverInitiated",
                |m: &AndroidAppDeliveryData| { &m.serverInitiated },
                |m: &mut AndroidAppDeliveryData| { &mut m.serverInitiated },
                AndroidAppDeliveryData::get_serverInitiated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "postInstallRefundWindowMillis",
                |m: &AndroidAppDeliveryData| { &m.postInstallRefundWindowMillis },
                |m: &mut AndroidAppDeliveryData| { &mut m.postInstallRefundWindowMillis },
                AndroidAppDeliveryData::get_postInstallRefundWindowMillis,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "immediateStartNeeded",
                |m: &AndroidAppDeliveryData| { &m.immediateStartNeeded },
                |m: &mut AndroidAppDeliveryData| { &mut m.immediateStartNeeded },
                AndroidAppDeliveryData::get_immediateStartNeeded,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppPatchData>, _>(
                "patchData",
                |m: &AndroidAppDeliveryData| { &m.patchData },
                |m: &mut AndroidAppDeliveryData| { &mut m.patchData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptionParams>, _>(
                "encryptionParams",
                |m: &AndroidAppDeliveryData| { &m.encryptionParams },
                |m: &mut AndroidAppDeliveryData| { &mut m.encryptionParams },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gzippedDownloadUrl",
                |m: &AndroidAppDeliveryData| { &m.gzippedDownloadUrl },
                |m: &mut AndroidAppDeliveryData| { &mut m.gzippedDownloadUrl },
                AndroidAppDeliveryData::get_gzippedDownloadUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "gzippedDownloadSize",
                |m: &AndroidAppDeliveryData| { &m.gzippedDownloadSize },
                |m: &mut AndroidAppDeliveryData| { &mut m.gzippedDownloadSize },
                AndroidAppDeliveryData::get_gzippedDownloadSize,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SplitDeliveryData>>(
                "splitDeliveryData",
                |m: &AndroidAppDeliveryData| { &m.splitDeliveryData },
                |m: &mut AndroidAppDeliveryData| { &mut m.splitDeliveryData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "installLocation",
                |m: &AndroidAppDeliveryData| { &m.installLocation },
                |m: &mut AndroidAppDeliveryData| { &mut m.installLocation },
                AndroidAppDeliveryData::get_installLocation,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AndroidAppDeliveryData>(
                "AndroidAppDeliveryData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppDeliveryData {
        static instance: ::protobuf::rt::Lazy<AndroidAppDeliveryData> = ::protobuf::rt::Lazy::INIT;
        instance.get(AndroidAppDeliveryData::new)
    }
}

impl ::protobuf::Clear for AndroidAppDeliveryData {
    fn clear(&mut self) {
        self.downloadSize = ::std::option::Option::None;
        self.signature.clear();
        self.downloadUrl.clear();
        self.additionalFile.clear();
        self.downloadAuthCookie.clear();
        self.forwardLocked = ::std::option::Option::None;
        self.refundTimeout = ::std::option::Option::None;
        self.serverInitiated = ::std::option::Option::None;
        self.postInstallRefundWindowMillis = ::std::option::Option::None;
        self.immediateStartNeeded = ::std::option::Option::None;
        self.patchData.clear();
        self.encryptionParams.clear();
        self.gzippedDownloadUrl.clear();
        self.gzippedDownloadSize = ::std::option::Option::None;
        self.splitDeliveryData.clear();
        self.installLocation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppDeliveryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppDeliveryData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SplitDeliveryData {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub downloadSize: ::std::option::Option<i64>,
    pub gzippedDownloadSize: ::std::option::Option<i64>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub gzippedDownloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub patchData: ::protobuf::SingularPtrField<AndroidAppPatchData>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SplitDeliveryData {
    pub fn new() -> SplitDeliveryData {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 downloadSize = 2;

    pub fn get_downloadSize(&self) -> i64 {
        self.downloadSize.unwrap_or(0)
    }

    // optional int64 gzippedDownloadSize = 3;

    pub fn get_gzippedDownloadSize(&self) -> i64 {
        self.gzippedDownloadSize.unwrap_or(0)
    }

    // optional string signature = 4;

    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string downloadUrl = 5;

    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string gzippedDownloadUrl = 6;

    pub fn get_gzippedDownloadUrl(&self) -> &str {
        match self.gzippedDownloadUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SplitDeliveryData {
    fn is_initialized(&self) -> bool {
        for v in &self.patchData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloadSize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gzippedDownloadSize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gzippedDownloadUrl)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<AndroidAppPatchData, _>(wire_type, is, &mut self.patchData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.downloadSize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gzippedDownloadSize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.gzippedDownloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.patchData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.downloadSize {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.gzippedDownloadSize {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.gzippedDownloadUrl.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.patchData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SplitDeliveryData {
        SplitDeliveryData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "id",
                |m: &SplitDeliveryData| { &m.id },
                |m: &mut SplitDeliveryData| { &mut m.id },
                SplitDeliveryData::get_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "downloadSize",
                |m: &SplitDeliveryData| { &m.downloadSize },
                |m: &mut SplitDeliveryData| { &mut m.downloadSize },
                SplitDeliveryData::get_downloadSize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "gzippedDownloadSize",
                |m: &SplitDeliveryData| { &m.gzippedDownloadSize },
                |m: &mut SplitDeliveryData| { &mut m.gzippedDownloadSize },
                SplitDeliveryData::get_gzippedDownloadSize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signature",
                |m: &SplitDeliveryData| { &m.signature },
                |m: &mut SplitDeliveryData| { &mut m.signature },
                SplitDeliveryData::get_signature,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadUrl",
                |m: &SplitDeliveryData| { &m.downloadUrl },
                |m: &mut SplitDeliveryData| { &mut m.downloadUrl },
                SplitDeliveryData::get_downloadUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gzippedDownloadUrl",
                |m: &SplitDeliveryData| { &m.gzippedDownloadUrl },
                |m: &mut SplitDeliveryData| { &mut m.gzippedDownloadUrl },
                SplitDeliveryData::get_gzippedDownloadUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppPatchData>, _>(
                "patchData",
                |m: &SplitDeliveryData| { &m.patchData },
                |m: &mut SplitDeliveryData| { &mut m.patchData },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SplitDeliveryData>(
                "SplitDeliveryData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SplitDeliveryData {
        static instance: ::protobuf::rt::Lazy<SplitDeliveryData> = ::protobuf::rt::Lazy::INIT;
        instance.get(SplitDeliveryData::new)
    }
}

impl ::protobuf::Clear for SplitDeliveryData {
    fn clear(&mut self) {
        self.id.clear();
        self.downloadSize = ::std::option::Option::None;
        self.gzippedDownloadSize = ::std::option::Option::None;
        self.signature.clear();
        self.downloadUrl.clear();
        self.gzippedDownloadUrl.clear();
        self.patchData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SplitDeliveryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitDeliveryData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AndroidAppPatchData {
    // message fields
    pub baseVersionCode: ::std::option::Option<i32>,
    pub baseSignature: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub patchFormat: ::std::option::Option<i32>,
    pub maxPatchSize: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AndroidAppPatchData {
    pub fn new() -> AndroidAppPatchData {
        ::std::default::Default::default()
    }

    // optional int32 baseVersionCode = 1;

    pub fn get_baseVersionCode(&self) -> i32 {
        self.baseVersionCode.unwrap_or(0)
    }

    // optional string baseSignature = 2;

    pub fn get_baseSignature(&self) -> &str {
        match self.baseSignature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string downloadUrl = 3;

    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 patchFormat = 4;

    pub fn get_patchFormat(&self) -> i32 {
        self.patchFormat.unwrap_or(0)
    }

    // optional int64 maxPatchSize = 5;

    pub fn get_maxPatchSize(&self) -> i64 {
        self.maxPatchSize.unwrap_or(0)
    }
}

impl ::protobuf::Message for AndroidAppPatchData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.baseVersionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.baseSignature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.patchFormat = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxPatchSize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.baseVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.baseSignature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.patchFormat {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxPatchSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.baseVersionCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.baseSignature.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.patchFormat {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maxPatchSize {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppPatchData {
        AndroidAppPatchData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "baseVersionCode",
                |m: &AndroidAppPatchData| { &m.baseVersionCode },
                |m: &mut AndroidAppPatchData| { &mut m.baseVersionCode },
                AndroidAppPatchData::get_baseVersionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "baseSignature",
                |m: &AndroidAppPatchData| { &m.baseSignature },
                |m: &mut AndroidAppPatchData| { &mut m.baseSignature },
                AndroidAppPatchData::get_baseSignature,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadUrl",
                |m: &AndroidAppPatchData| { &m.downloadUrl },
                |m: &mut AndroidAppPatchData| { &mut m.downloadUrl },
                AndroidAppPatchData::get_downloadUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "patchFormat",
                |m: &AndroidAppPatchData| { &m.patchFormat },
                |m: &mut AndroidAppPatchData| { &mut m.patchFormat },
                AndroidAppPatchData::get_patchFormat,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "maxPatchSize",
                |m: &AndroidAppPatchData| { &m.maxPatchSize },
                |m: &mut AndroidAppPatchData| { &mut m.maxPatchSize },
                AndroidAppPatchData::get_maxPatchSize,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AndroidAppPatchData>(
                "AndroidAppPatchData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppPatchData {
        static instance: ::protobuf::rt::Lazy<AndroidAppPatchData> = ::protobuf::rt::Lazy::INIT;
        instance.get(AndroidAppPatchData::new)
    }
}

impl ::protobuf::Clear for AndroidAppPatchData {
    fn clear(&mut self) {
        self.baseVersionCode = ::std::option::Option::None;
        self.baseSignature.clear();
        self.downloadUrl.clear();
        self.patchFormat = ::std::option::Option::None;
        self.maxPatchSize = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppPatchData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppPatchData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AppFileMetadata {
    // message fields
    pub fileType: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AppFileMetadata {
    pub fn new() -> AppFileMetadata {
        ::std::default::Default::default()
    }

    // optional int32 fileType = 1;

    pub fn get_fileType(&self) -> i32 {
        self.fileType.unwrap_or(0)
    }

    // optional int32 versionCode = 2;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 size = 3;

    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional string downloadUrl = 4;

    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AppFileMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fileType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppFileMetadata {
        AppFileMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "fileType",
                |m: &AppFileMetadata| { &m.fileType },
                |m: &mut AppFileMetadata| { &mut m.fileType },
                AppFileMetadata::get_fileType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &AppFileMetadata| { &m.versionCode },
                |m: &mut AppFileMetadata| { &mut m.versionCode },
                AppFileMetadata::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "size",
                |m: &AppFileMetadata| { &m.size },
                |m: &mut AppFileMetadata| { &mut m.size },
                AppFileMetadata::get_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadUrl",
                |m: &AppFileMetadata| { &m.downloadUrl },
                |m: &mut AppFileMetadata| { &mut m.downloadUrl },
                AppFileMetadata::get_downloadUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AppFileMetadata>(
                "AppFileMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppFileMetadata {
        static instance: ::protobuf::rt::Lazy<AppFileMetadata> = ::protobuf::rt::Lazy::INIT;
        instance.get(AppFileMetadata::new)
    }
}

impl ::protobuf::Clear for AppFileMetadata {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.downloadUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppFileMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppFileMetadata {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct EncryptionParams {
    // message fields
    pub version: ::std::option::Option<i32>,
    pub encryptionKey: ::protobuf::SingularField<::std::string::String>,
    pub hmacKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl EncryptionParams {
    pub fn new() -> EncryptionParams {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional string encryptionKey = 2;

    pub fn get_encryptionKey(&self) -> &str {
        match self.encryptionKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string hmacKey = 3;

    pub fn get_hmacKey(&self) -> &str {
        match self.hmacKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for EncryptionParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryptionKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hmacKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryptionKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.hmacKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.encryptionKey.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.hmacKey.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptionParams {
        EncryptionParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "version",
                |m: &EncryptionParams| { &m.version },
                |m: &mut EncryptionParams| { &mut m.version },
                EncryptionParams::get_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "encryptionKey",
                |m: &EncryptionParams| { &m.encryptionKey },
                |m: &mut EncryptionParams| { &mut m.encryptionKey },
                EncryptionParams::get_encryptionKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "hmacKey",
                |m: &EncryptionParams| { &m.hmacKey },
                |m: &mut EncryptionParams| { &mut m.hmacKey },
                EncryptionParams::get_hmacKey,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<EncryptionParams>(
                "EncryptionParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptionParams {
        static instance: ::protobuf::rt::Lazy<EncryptionParams> = ::protobuf::rt::Lazy::INIT;
        instance.get(EncryptionParams::new)
    }
}

impl ::protobuf::Clear for EncryptionParams {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.encryptionKey.clear();
        self.hmacKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptionParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionParams {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct HttpCookie {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl HttpCookie {
    pub fn new() -> HttpCookie {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string value = 2;

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for HttpCookie {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpCookie {
        HttpCookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &HttpCookie| { &m.name },
                |m: &mut HttpCookie| { &mut m.name },
                HttpCookie::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "value",
                |m: &HttpCookie| { &m.value },
                |m: &mut HttpCookie| { &mut m.value },
                HttpCookie::get_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<HttpCookie>(
                "HttpCookie",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpCookie {
        static instance: ::protobuf::rt::Lazy<HttpCookie> = ::protobuf::rt::Lazy::INIT;
        instance.get(HttpCookie::new)
    }
}

impl ::protobuf::Clear for HttpCookie {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpCookie {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Address {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub addressLine1: ::protobuf::SingularField<::std::string::String>,
    pub addressLine2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub postalCountry: ::protobuf::SingularField<::std::string::String>,
    pub dependentLocality: ::protobuf::SingularField<::std::string::String>,
    pub sortingCode: ::protobuf::SingularField<::std::string::String>,
    pub languageCode: ::protobuf::SingularField<::std::string::String>,
    pub phoneNumber: ::protobuf::SingularField<::std::string::String>,
    pub deprecatedIsReduced: ::std::option::Option<bool>,
    pub firstName: ::protobuf::SingularField<::std::string::String>,
    pub lastName: ::protobuf::SingularField<::std::string::String>,
    pub email: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string addressLine1 = 2;

    pub fn get_addressLine1(&self) -> &str {
        match self.addressLine1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string addressLine2 = 3;

    pub fn get_addressLine2(&self) -> &str {
        match self.addressLine2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string city = 4;

    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string state = 5;

    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string postalCode = 6;

    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string postalCountry = 7;

    pub fn get_postalCountry(&self) -> &str {
        match self.postalCountry.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string dependentLocality = 8;

    pub fn get_dependentLocality(&self) -> &str {
        match self.dependentLocality.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string sortingCode = 9;

    pub fn get_sortingCode(&self) -> &str {
        match self.sortingCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string languageCode = 10;

    pub fn get_languageCode(&self) -> &str {
        match self.languageCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string phoneNumber = 11;

    pub fn get_phoneNumber(&self) -> &str {
        match self.phoneNumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool deprecatedIsReduced = 12;

    pub fn get_deprecatedIsReduced(&self) -> bool {
        self.deprecatedIsReduced.unwrap_or(false)
    }

    // optional string firstName = 13;

    pub fn get_firstName(&self) -> &str {
        match self.firstName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string lastName = 14;

    pub fn get_lastName(&self) -> &str {
        match self.lastName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string email = 15;

    pub fn get_email(&self) -> &str {
        match self.email.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressLine1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressLine2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCountry)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dependentLocality)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sortingCode)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.languageCode)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phoneNumber)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deprecatedIsReduced = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.firstName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastName)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.addressLine1.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.addressLine2.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.postalCountry.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.dependentLocality.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.sortingCode.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.languageCode.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.phoneNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.deprecatedIsReduced {
            my_size += 2;
        }
        if let Some(v) = self.firstName.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.lastName.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.addressLine1.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.addressLine2.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.city.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.postalCode.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.postalCountry.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.dependentLocality.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.sortingCode.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.languageCode.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.phoneNumber.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.deprecatedIsReduced {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.firstName.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.lastName.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.email.as_ref() {
            os.write_string(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &Address| { &m.name },
                |m: &mut Address| { &mut m.name },
                Address::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "addressLine1",
                |m: &Address| { &m.addressLine1 },
                |m: &mut Address| { &mut m.addressLine1 },
                Address::get_addressLine1,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "addressLine2",
                |m: &Address| { &m.addressLine2 },
                |m: &mut Address| { &mut m.addressLine2 },
                Address::get_addressLine2,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "city",
                |m: &Address| { &m.city },
                |m: &mut Address| { &mut m.city },
                Address::get_city,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "state",
                |m: &Address| { &m.state },
                |m: &mut Address| { &mut m.state },
                Address::get_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "postalCode",
                |m: &Address| { &m.postalCode },
                |m: &mut Address| { &mut m.postalCode },
                Address::get_postalCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "postalCountry",
                |m: &Address| { &m.postalCountry },
                |m: &mut Address| { &mut m.postalCountry },
                Address::get_postalCountry,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "dependentLocality",
                |m: &Address| { &m.dependentLocality },
                |m: &mut Address| { &mut m.dependentLocality },
                Address::get_dependentLocality,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "sortingCode",
                |m: &Address| { &m.sortingCode },
                |m: &mut Address| { &mut m.sortingCode },
                Address::get_sortingCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "languageCode",
                |m: &Address| { &m.languageCode },
                |m: &mut Address| { &mut m.languageCode },
                Address::get_languageCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "phoneNumber",
                |m: &Address| { &m.phoneNumber },
                |m: &mut Address| { &mut m.phoneNumber },
                Address::get_phoneNumber,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "deprecatedIsReduced",
                |m: &Address| { &m.deprecatedIsReduced },
                |m: &mut Address| { &mut m.deprecatedIsReduced },
                Address::get_deprecatedIsReduced,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "firstName",
                |m: &Address| { &m.firstName },
                |m: &mut Address| { &mut m.firstName },
                Address::get_firstName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "lastName",
                |m: &Address| { &m.lastName },
                |m: &mut Address| { &mut m.lastName },
                Address::get_lastName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "email",
                |m: &Address| { &m.email },
                |m: &mut Address| { &mut m.email },
                Address::get_email,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Address>(
                "Address",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Address {
        static instance: ::protobuf::rt::Lazy<Address> = ::protobuf::rt::Lazy::INIT;
        instance.get(Address::new)
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.name.clear();
        self.addressLine1.clear();
        self.addressLine2.clear();
        self.city.clear();
        self.state.clear();
        self.postalCode.clear();
        self.postalCountry.clear();
        self.dependentLocality.clear();
        self.sortingCode.clear();
        self.languageCode.clear();
        self.phoneNumber.clear();
        self.deprecatedIsReduced = ::std::option::Option::None;
        self.firstName.clear();
        self.lastName.clear();
        self.email.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BookAuthor {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub deprecatedQuery: ::protobuf::SingularField<::std::string::String>,
    pub docid: ::protobuf::SingularPtrField<Docid>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BookAuthor {
    pub fn new() -> BookAuthor {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string deprecatedQuery = 2;

    pub fn get_deprecatedQuery(&self) -> &str {
        match self.deprecatedQuery.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BookAuthor {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deprecatedQuery)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.docid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.deprecatedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.deprecatedQuery.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.docid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookAuthor {
        BookAuthor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &BookAuthor| { &m.name },
                |m: &mut BookAuthor| { &mut m.name },
                BookAuthor::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "deprecatedQuery",
                |m: &BookAuthor| { &m.deprecatedQuery },
                |m: &mut BookAuthor| { &mut m.deprecatedQuery },
                BookAuthor::get_deprecatedQuery,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "docid",
                |m: &BookAuthor| { &m.docid },
                |m: &mut BookAuthor| { &mut m.docid },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BookAuthor>(
                "BookAuthor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookAuthor {
        static instance: ::protobuf::rt::Lazy<BookAuthor> = ::protobuf::rt::Lazy::INIT;
        instance.get(BookAuthor::new)
    }
}

impl ::protobuf::Clear for BookAuthor {
    fn clear(&mut self) {
        self.name.clear();
        self.deprecatedQuery.clear();
        self.docid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookAuthor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookAuthor {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BookDetails {
    // message fields
    pub subject: ::protobuf::RepeatedField<BookSubject>,
    pub publisher: ::protobuf::SingularField<::std::string::String>,
    pub publicationDate: ::protobuf::SingularField<::std::string::String>,
    pub isbn: ::protobuf::SingularField<::std::string::String>,
    pub numberOfPages: ::std::option::Option<i32>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub author: ::protobuf::RepeatedField<BookAuthor>,
    pub readerUrl: ::protobuf::SingularField<::std::string::String>,
    pub downloadEpubUrl: ::protobuf::SingularField<::std::string::String>,
    pub downloadPdfUrl: ::protobuf::SingularField<::std::string::String>,
    pub acsEpubTokenUrl: ::protobuf::SingularField<::std::string::String>,
    pub acsPdfTokenUrl: ::protobuf::SingularField<::std::string::String>,
    pub epubAvailable: ::std::option::Option<bool>,
    pub pdfAvailable: ::std::option::Option<bool>,
    pub aboutTheAuthor: ::protobuf::SingularField<::std::string::String>,
    // identifier: <group>
    pub fixedLayoutContent: ::std::option::Option<bool>,
    pub audioVideoContent: ::std::option::Option<bool>,
    pub isAgencyBook: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BookDetails {
    pub fn new() -> BookDetails {
        ::std::default::Default::default()
    }

    // optional string publisher = 4;

    pub fn get_publisher(&self) -> &str {
        match self.publisher.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string publicationDate = 5;

    pub fn get_publicationDate(&self) -> &str {
        match self.publicationDate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string isbn = 6;

    pub fn get_isbn(&self) -> &str {
        match self.isbn.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 numberOfPages = 7;

    pub fn get_numberOfPages(&self) -> i32 {
        self.numberOfPages.unwrap_or(0)
    }

    // optional string subtitle = 8;

    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string readerUrl = 10;

    pub fn get_readerUrl(&self) -> &str {
        match self.readerUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string downloadEpubUrl = 11;

    pub fn get_downloadEpubUrl(&self) -> &str {
        match self.downloadEpubUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string downloadPdfUrl = 12;

    pub fn get_downloadPdfUrl(&self) -> &str {
        match self.downloadPdfUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string acsEpubTokenUrl = 13;

    pub fn get_acsEpubTokenUrl(&self) -> &str {
        match self.acsEpubTokenUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string acsPdfTokenUrl = 14;

    pub fn get_acsPdfTokenUrl(&self) -> &str {
        match self.acsPdfTokenUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool epubAvailable = 15;

    pub fn get_epubAvailable(&self) -> bool {
        self.epubAvailable.unwrap_or(false)
    }

    // optional bool pdfAvailable = 16;

    pub fn get_pdfAvailable(&self) -> bool {
        self.pdfAvailable.unwrap_or(false)
    }

    // optional string aboutTheAuthor = 17;

    pub fn get_aboutTheAuthor(&self) -> &str {
        match self.aboutTheAuthor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool fixedLayoutContent = 21;

    pub fn get_fixedLayoutContent(&self) -> bool {
        self.fixedLayoutContent.unwrap_or(false)
    }

    // optional bool audioVideoContent = 22;

    pub fn get_audioVideoContent(&self) -> bool {
        self.audioVideoContent.unwrap_or(false)
    }

    // optional bool isAgencyBook = 23;

    pub fn get_isAgencyBook(&self) -> bool {
        self.isAgencyBook.unwrap_or(false)
    }
}

impl ::protobuf::Message for BookDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.subject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.author {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.subject)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.publisher)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.publicationDate)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.isbn)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numberOfPages = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.author)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.readerUrl)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadEpubUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadPdfUrl)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.acsEpubTokenUrl)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.acsPdfTokenUrl)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.epubAvailable = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pdfAvailable = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.aboutTheAuthor)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fixedLayoutContent = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.audioVideoContent = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isAgencyBook = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subject {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.publisher.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.publicationDate.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.isbn.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.numberOfPages {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.author {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.readerUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.downloadEpubUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.downloadPdfUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.acsEpubTokenUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.acsPdfTokenUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.epubAvailable {
            my_size += 2;
        }
        if let Some(v) = self.pdfAvailable {
            my_size += 3;
        }
        if let Some(v) = self.aboutTheAuthor.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.fixedLayoutContent {
            my_size += 3;
        }
        if let Some(v) = self.audioVideoContent {
            my_size += 3;
        }
        if let Some(v) = self.isAgencyBook {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subject {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.publisher.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.publicationDate.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.isbn.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.numberOfPages {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.subtitle.as_ref() {
            os.write_string(8, v)?;
        }
        for v in &self.author {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.readerUrl.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.downloadEpubUrl.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.downloadPdfUrl.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.acsEpubTokenUrl.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.acsPdfTokenUrl.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.epubAvailable {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.pdfAvailable {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.aboutTheAuthor.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.fixedLayoutContent {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.audioVideoContent {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.isAgencyBook {
            os.write_bool(23, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookDetails {
        BookDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookSubject>>(
                "subject",
                |m: &BookDetails| { &m.subject },
                |m: &mut BookDetails| { &mut m.subject },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "publisher",
                |m: &BookDetails| { &m.publisher },
                |m: &mut BookDetails| { &mut m.publisher },
                BookDetails::get_publisher,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "publicationDate",
                |m: &BookDetails| { &m.publicationDate },
                |m: &mut BookDetails| { &mut m.publicationDate },
                BookDetails::get_publicationDate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "isbn",
                |m: &BookDetails| { &m.isbn },
                |m: &mut BookDetails| { &mut m.isbn },
                BookDetails::get_isbn,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "numberOfPages",
                |m: &BookDetails| { &m.numberOfPages },
                |m: &mut BookDetails| { &mut m.numberOfPages },
                BookDetails::get_numberOfPages,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subtitle",
                |m: &BookDetails| { &m.subtitle },
                |m: &mut BookDetails| { &mut m.subtitle },
                BookDetails::get_subtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookAuthor>>(
                "author",
                |m: &BookDetails| { &m.author },
                |m: &mut BookDetails| { &mut m.author },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "readerUrl",
                |m: &BookDetails| { &m.readerUrl },
                |m: &mut BookDetails| { &mut m.readerUrl },
                BookDetails::get_readerUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadEpubUrl",
                |m: &BookDetails| { &m.downloadEpubUrl },
                |m: &mut BookDetails| { &mut m.downloadEpubUrl },
                BookDetails::get_downloadEpubUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadPdfUrl",
                |m: &BookDetails| { &m.downloadPdfUrl },
                |m: &mut BookDetails| { &mut m.downloadPdfUrl },
                BookDetails::get_downloadPdfUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "acsEpubTokenUrl",
                |m: &BookDetails| { &m.acsEpubTokenUrl },
                |m: &mut BookDetails| { &mut m.acsEpubTokenUrl },
                BookDetails::get_acsEpubTokenUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "acsPdfTokenUrl",
                |m: &BookDetails| { &m.acsPdfTokenUrl },
                |m: &mut BookDetails| { &mut m.acsPdfTokenUrl },
                BookDetails::get_acsPdfTokenUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "epubAvailable",
                |m: &BookDetails| { &m.epubAvailable },
                |m: &mut BookDetails| { &mut m.epubAvailable },
                BookDetails::get_epubAvailable,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "pdfAvailable",
                |m: &BookDetails| { &m.pdfAvailable },
                |m: &mut BookDetails| { &mut m.pdfAvailable },
                BookDetails::get_pdfAvailable,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "aboutTheAuthor",
                |m: &BookDetails| { &m.aboutTheAuthor },
                |m: &mut BookDetails| { &mut m.aboutTheAuthor },
                BookDetails::get_aboutTheAuthor,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "fixedLayoutContent",
                |m: &BookDetails| { &m.fixedLayoutContent },
                |m: &mut BookDetails| { &mut m.fixedLayoutContent },
                BookDetails::get_fixedLayoutContent,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "audioVideoContent",
                |m: &BookDetails| { &m.audioVideoContent },
                |m: &mut BookDetails| { &mut m.audioVideoContent },
                BookDetails::get_audioVideoContent,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "isAgencyBook",
                |m: &BookDetails| { &m.isAgencyBook },
                |m: &mut BookDetails| { &mut m.isAgencyBook },
                BookDetails::get_isAgencyBook,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BookDetails>(
                "BookDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookDetails {
        static instance: ::protobuf::rt::Lazy<BookDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(BookDetails::new)
    }
}

impl ::protobuf::Clear for BookDetails {
    fn clear(&mut self) {
        self.subject.clear();
        self.publisher.clear();
        self.publicationDate.clear();
        self.isbn.clear();
        self.numberOfPages = ::std::option::Option::None;
        self.subtitle.clear();
        self.author.clear();
        self.readerUrl.clear();
        self.downloadEpubUrl.clear();
        self.downloadPdfUrl.clear();
        self.acsEpubTokenUrl.clear();
        self.acsPdfTokenUrl.clear();
        self.epubAvailable = ::std::option::Option::None;
        self.pdfAvailable = ::std::option::Option::None;
        self.aboutTheAuthor.clear();
        self.fixedLayoutContent = ::std::option::Option::None;
        self.audioVideoContent = ::std::option::Option::None;
        self.isAgencyBook = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BookDetails_Identifier {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub identifier: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BookDetails_Identifier {
    pub fn new() -> BookDetails_Identifier {
        ::std::default::Default::default()
    }

    // optional int32 type = 19;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string identifier = 20;

    pub fn get_identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BookDetails_Identifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.identifier.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookDetails_Identifier {
        BookDetails_Identifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &BookDetails_Identifier| { &m.field_type },
                |m: &mut BookDetails_Identifier| { &mut m.field_type },
                BookDetails_Identifier::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "identifier",
                |m: &BookDetails_Identifier| { &m.identifier },
                |m: &mut BookDetails_Identifier| { &mut m.identifier },
                BookDetails_Identifier::get_identifier,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BookDetails_Identifier>(
                "BookDetails_Identifier",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookDetails_Identifier {
        static instance: ::protobuf::rt::Lazy<BookDetails_Identifier> = ::protobuf::rt::Lazy::INIT;
        instance.get(BookDetails_Identifier::new)
    }
}

impl ::protobuf::Clear for BookDetails_Identifier {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.identifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookDetails_Identifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookDetails_Identifier {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BookSubject {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub subjectId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BookSubject {
    pub fn new() -> BookSubject {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string query = 2;

    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string subjectId = 3;

    pub fn get_subjectId(&self) -> &str {
        match self.subjectId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BookSubject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subjectId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.subjectId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.query.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.subjectId.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookSubject {
        BookSubject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &BookSubject| { &m.name },
                |m: &mut BookSubject| { &mut m.name },
                BookSubject::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "query",
                |m: &BookSubject| { &m.query },
                |m: &mut BookSubject| { &mut m.query },
                BookSubject::get_query,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subjectId",
                |m: &BookSubject| { &m.subjectId },
                |m: &mut BookSubject| { &mut m.subjectId },
                BookSubject::get_subjectId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BookSubject>(
                "BookSubject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookSubject {
        static instance: ::protobuf::rt::Lazy<BookSubject> = ::protobuf::rt::Lazy::INIT;
        instance.get(BookSubject::new)
    }
}

impl ::protobuf::Clear for BookSubject {
    fn clear(&mut self) {
        self.name.clear();
        self.query.clear();
        self.subjectId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookSubject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookSubject {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BrowseLink {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub dataUrl: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BrowseLink {
    pub fn new() -> BrowseLink {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string dataUrl = 3;

    pub fn get_dataUrl(&self) -> &str {
        match self.dataUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 4;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for BrowseLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dataUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.dataUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.dataUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BrowseLink {
        BrowseLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &BrowseLink| { &m.name },
                |m: &mut BrowseLink| { &mut m.name },
                BrowseLink::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "dataUrl",
                |m: &BrowseLink| { &m.dataUrl },
                |m: &mut BrowseLink| { &mut m.dataUrl },
                BrowseLink::get_dataUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &BrowseLink| { &m.serverLogsCookie },
                |m: &mut BrowseLink| { &mut m.serverLogsCookie },
                BrowseLink::get_serverLogsCookie,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BrowseLink>(
                "BrowseLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BrowseLink {
        static instance: ::protobuf::rt::Lazy<BrowseLink> = ::protobuf::rt::Lazy::INIT;
        instance.get(BrowseLink::new)
    }
}

impl ::protobuf::Clear for BrowseLink {
    fn clear(&mut self) {
        self.name.clear();
        self.dataUrl.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BrowseLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BrowseLink {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BrowseResponse {
    // message fields
    pub contentsUrl: ::protobuf::SingularField<::std::string::String>,
    pub promoUrl: ::protobuf::SingularField<::std::string::String>,
    pub category: ::protobuf::RepeatedField<BrowseLink>,
    pub breadcrumb: ::protobuf::RepeatedField<BrowseLink>,
    pub quickLink: ::protobuf::RepeatedField<QuickLink>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BrowseResponse {
    pub fn new() -> BrowseResponse {
        ::std::default::Default::default()
    }

    // optional string contentsUrl = 1;

    pub fn get_contentsUrl(&self) -> &str {
        match self.contentsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string promoUrl = 2;

    pub fn get_promoUrl(&self) -> &str {
        match self.promoUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 6;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for BrowseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.category {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.breadcrumb {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quickLink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.promoUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.category)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.breadcrumb)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.quickLink)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.contentsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.promoUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.category {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.breadcrumb {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.quickLink {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.contentsUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.promoUrl.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.category {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.breadcrumb {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.quickLink {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BrowseResponse {
        BrowseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contentsUrl",
                |m: &BrowseResponse| { &m.contentsUrl },
                |m: &mut BrowseResponse| { &mut m.contentsUrl },
                BrowseResponse::get_contentsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "promoUrl",
                |m: &BrowseResponse| { &m.promoUrl },
                |m: &mut BrowseResponse| { &mut m.promoUrl },
                BrowseResponse::get_promoUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseLink>>(
                "category",
                |m: &BrowseResponse| { &m.category },
                |m: &mut BrowseResponse| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseLink>>(
                "breadcrumb",
                |m: &BrowseResponse| { &m.breadcrumb },
                |m: &mut BrowseResponse| { &mut m.breadcrumb },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuickLink>>(
                "quickLink",
                |m: &BrowseResponse| { &m.quickLink },
                |m: &mut BrowseResponse| { &mut m.quickLink },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &BrowseResponse| { &m.serverLogsCookie },
                |m: &mut BrowseResponse| { &mut m.serverLogsCookie },
                BrowseResponse::get_serverLogsCookie,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BrowseResponse>(
                "BrowseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BrowseResponse {
        static instance: ::protobuf::rt::Lazy<BrowseResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(BrowseResponse::new)
    }
}

impl ::protobuf::Clear for BrowseResponse {
    fn clear(&mut self) {
        self.contentsUrl.clear();
        self.promoUrl.clear();
        self.category.clear();
        self.breadcrumb.clear();
        self.quickLink.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BrowseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BrowseResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct QuickLink {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    pub link: ::protobuf::SingularPtrField<ResolvedLink>,
    pub displayRequired: ::std::option::Option<bool>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub backendId: ::std::option::Option<i32>,
    pub prismStyle: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl QuickLink {
    pub fn new() -> QuickLink {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool displayRequired = 4;

    pub fn get_displayRequired(&self) -> bool {
        self.displayRequired.unwrap_or(false)
    }

    // optional bytes serverLogsCookie = 5;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional int32 backendId = 6;

    pub fn get_backendId(&self) -> i32 {
        self.backendId.unwrap_or(0)
    }

    // optional bool prismStyle = 7;

    pub fn get_prismStyle(&self) -> bool {
        self.prismStyle.unwrap_or(false)
    }
}

impl ::protobuf::Message for QuickLink {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Image, _>(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<ResolvedLink, _>(wire_type, is, &mut self.link)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.displayRequired = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backendId = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prismStyle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.displayRequired {
            my_size += 2;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.backendId {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prismStyle {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.link.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.displayRequired {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.backendId {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.prismStyle {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuickLink {
        QuickLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &QuickLink| { &m.name },
                |m: &mut QuickLink| { &mut m.name },
                QuickLink::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>, _>(
                "image",
                |m: &QuickLink| { &m.image },
                |m: &mut QuickLink| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedLink>, _>(
                "link",
                |m: &QuickLink| { &m.link },
                |m: &mut QuickLink| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "displayRequired",
                |m: &QuickLink| { &m.displayRequired },
                |m: &mut QuickLink| { &mut m.displayRequired },
                QuickLink::get_displayRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &QuickLink| { &m.serverLogsCookie },
                |m: &mut QuickLink| { &mut m.serverLogsCookie },
                QuickLink::get_serverLogsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "backendId",
                |m: &QuickLink| { &m.backendId },
                |m: &mut QuickLink| { &mut m.backendId },
                QuickLink::get_backendId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "prismStyle",
                |m: &QuickLink| { &m.prismStyle },
                |m: &mut QuickLink| { &mut m.prismStyle },
                QuickLink::get_prismStyle,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<QuickLink>(
                "QuickLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuickLink {
        static instance: ::protobuf::rt::Lazy<QuickLink> = ::protobuf::rt::Lazy::INIT;
        instance.get(QuickLink::new)
    }
}

impl ::protobuf::Clear for QuickLink {
    fn clear(&mut self) {
        self.name.clear();
        self.image.clear();
        self.link.clear();
        self.displayRequired = ::std::option::Option::None;
        self.serverLogsCookie.clear();
        self.backendId = ::std::option::Option::None;
        self.prismStyle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuickLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuickLink {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BuyResponse {
    // message fields
    pub purchaseResponse: ::protobuf::SingularPtrField<PurchaseNotificationResponse>,
    // checkoutinfo: <group>
    pub continueViaUrl: ::protobuf::SingularField<::std::string::String>,
    pub purchaseStatusUrl: ::protobuf::SingularField<::std::string::String>,
    pub checkoutServiceId: ::protobuf::SingularField<::std::string::String>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    pub baseCheckoutUrl: ::protobuf::SingularField<::std::string::String>,
    pub tosCheckboxHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub permissionError: ::std::option::Option<i32>,
    pub purchaseStatusResponse: ::protobuf::SingularPtrField<PurchaseStatusResponse>,
    pub purchaseCookie: ::protobuf::SingularField<::std::string::String>,
    pub challenge: ::protobuf::SingularPtrField<Challenge>,
    pub addInstrumentPromptHtml: ::protobuf::SingularField<::std::string::String>,
    pub confirmButtonText: ::protobuf::SingularField<::std::string::String>,
    pub permissionErrorTitleText: ::protobuf::SingularField<::std::string::String>,
    pub permissionErrorMessageText: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub encodedDeliveryToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BuyResponse {
    pub fn new() -> BuyResponse {
        ::std::default::Default::default()
    }

    // optional string continueViaUrl = 8;

    pub fn get_continueViaUrl(&self) -> &str {
        match self.continueViaUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string purchaseStatusUrl = 9;

    pub fn get_purchaseStatusUrl(&self) -> &str {
        match self.purchaseStatusUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string checkoutServiceId = 12;

    pub fn get_checkoutServiceId(&self) -> &str {
        match self.checkoutServiceId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool checkoutTokenRequired = 13;

    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }

    // optional string baseCheckoutUrl = 14;

    pub fn get_baseCheckoutUrl(&self) -> &str {
        match self.baseCheckoutUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 permissionError = 38;

    pub fn get_permissionError(&self) -> i32 {
        self.permissionError.unwrap_or(0)
    }

    // optional string purchaseCookie = 46;

    pub fn get_purchaseCookie(&self) -> &str {
        match self.purchaseCookie.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string addInstrumentPromptHtml = 50;

    pub fn get_addInstrumentPromptHtml(&self) -> &str {
        match self.addInstrumentPromptHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string confirmButtonText = 51;

    pub fn get_confirmButtonText(&self) -> &str {
        match self.confirmButtonText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string permissionErrorTitleText = 52;

    pub fn get_permissionErrorTitleText(&self) -> &str {
        match self.permissionErrorTitleText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string permissionErrorMessageText = 53;

    pub fn get_permissionErrorMessageText(&self) -> &str {
        match self.permissionErrorMessageText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 54;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional string encodedDeliveryToken = 55;

    pub fn get_encodedDeliveryToken(&self) -> &str {
        match self.encodedDeliveryToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BuyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseStatusResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseNotificationResponse, _>(wire_type, is, &mut self.purchaseResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.continueViaUrl)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseStatusUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutServiceId)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.baseCheckoutUrl)?;
                },
                37 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tosCheckboxHtml)?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permissionError = ::std::option::Option::Some(tmp);
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseStatusResponse, _>(wire_type, is, &mut self.purchaseStatusResponse)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseCookie)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_message_into::<Challenge, _>(wire_type, is, &mut self.challenge)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addInstrumentPromptHtml)?;
                },
                51 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.confirmButtonText)?;
                },
                52 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.permissionErrorTitleText)?;
                },
                53 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.permissionErrorMessageText)?;
                },
                54 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                55 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encodedDeliveryToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.purchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.continueViaUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.purchaseStatusUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.checkoutServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        if let Some(v) = self.baseCheckoutUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        for value in &self.tosCheckboxHtml {
            my_size += ::protobuf::rt::string_size(37, &value);
        };
        if let Some(v) = self.permissionError {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchaseStatusResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(46, &v);
        }
        if let Some(v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.addInstrumentPromptHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(50, &v);
        }
        if let Some(v) = self.confirmButtonText.as_ref() {
            my_size += ::protobuf::rt::string_size(51, &v);
        }
        if let Some(v) = self.permissionErrorTitleText.as_ref() {
            my_size += ::protobuf::rt::string_size(52, &v);
        }
        if let Some(v) = self.permissionErrorMessageText.as_ref() {
            my_size += ::protobuf::rt::string_size(53, &v);
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(54, &v);
        }
        if let Some(v) = self.encodedDeliveryToken.as_ref() {
            my_size += ::protobuf::rt::string_size(55, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.purchaseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.continueViaUrl.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.purchaseStatusUrl.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.checkoutServiceId.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.baseCheckoutUrl.as_ref() {
            os.write_string(14, v)?;
        }
        for v in &self.tosCheckboxHtml {
            os.write_string(37, &v)?;
        };
        if let Some(v) = self.permissionError {
            os.write_int32(38, v)?;
        }
        if let Some(v) = self.purchaseStatusResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        }
        if let Some(v) = self.purchaseCookie.as_ref() {
            os.write_string(46, v)?;
        }
        if let Some(v) = self.challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        }
        if let Some(v) = self.addInstrumentPromptHtml.as_ref() {
            os.write_string(50, v)?;
        }
        if let Some(v) = self.confirmButtonText.as_ref() {
            os.write_string(51, v)?;
        }
        if let Some(v) = self.permissionErrorTitleText.as_ref() {
            os.write_string(52, v)?;
        }
        if let Some(v) = self.permissionErrorMessageText.as_ref() {
            os.write_string(53, v)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(54, v)?;
        }
        if let Some(v) = self.encodedDeliveryToken.as_ref() {
            os.write_string(55, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyResponse {
        BuyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseNotificationResponse>, _>(
                "purchaseResponse",
                |m: &BuyResponse| { &m.purchaseResponse },
                |m: &mut BuyResponse| { &mut m.purchaseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "continueViaUrl",
                |m: &BuyResponse| { &m.continueViaUrl },
                |m: &mut BuyResponse| { &mut m.continueViaUrl },
                BuyResponse::get_continueViaUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "purchaseStatusUrl",
                |m: &BuyResponse| { &m.purchaseStatusUrl },
                |m: &mut BuyResponse| { &mut m.purchaseStatusUrl },
                BuyResponse::get_purchaseStatusUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "checkoutServiceId",
                |m: &BuyResponse| { &m.checkoutServiceId },
                |m: &mut BuyResponse| { &mut m.checkoutServiceId },
                BuyResponse::get_checkoutServiceId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "checkoutTokenRequired",
                |m: &BuyResponse| { &m.checkoutTokenRequired },
                |m: &mut BuyResponse| { &mut m.checkoutTokenRequired },
                BuyResponse::get_checkoutTokenRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "baseCheckoutUrl",
                |m: &BuyResponse| { &m.baseCheckoutUrl },
                |m: &mut BuyResponse| { &mut m.baseCheckoutUrl },
                BuyResponse::get_baseCheckoutUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosCheckboxHtml",
                |m: &BuyResponse| { &m.tosCheckboxHtml },
                |m: &mut BuyResponse| { &mut m.tosCheckboxHtml },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "permissionError",
                |m: &BuyResponse| { &m.permissionError },
                |m: &mut BuyResponse| { &mut m.permissionError },
                BuyResponse::get_permissionError,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatusResponse>, _>(
                "purchaseStatusResponse",
                |m: &BuyResponse| { &m.purchaseStatusResponse },
                |m: &mut BuyResponse| { &mut m.purchaseStatusResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "purchaseCookie",
                |m: &BuyResponse| { &m.purchaseCookie },
                |m: &mut BuyResponse| { &mut m.purchaseCookie },
                BuyResponse::get_purchaseCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>, _>(
                "challenge",
                |m: &BuyResponse| { &m.challenge },
                |m: &mut BuyResponse| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "addInstrumentPromptHtml",
                |m: &BuyResponse| { &m.addInstrumentPromptHtml },
                |m: &mut BuyResponse| { &mut m.addInstrumentPromptHtml },
                BuyResponse::get_addInstrumentPromptHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "confirmButtonText",
                |m: &BuyResponse| { &m.confirmButtonText },
                |m: &mut BuyResponse| { &mut m.confirmButtonText },
                BuyResponse::get_confirmButtonText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "permissionErrorTitleText",
                |m: &BuyResponse| { &m.permissionErrorTitleText },
                |m: &mut BuyResponse| { &mut m.permissionErrorTitleText },
                BuyResponse::get_permissionErrorTitleText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "permissionErrorMessageText",
                |m: &BuyResponse| { &m.permissionErrorMessageText },
                |m: &mut BuyResponse| { &mut m.permissionErrorMessageText },
                BuyResponse::get_permissionErrorMessageText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &BuyResponse| { &m.serverLogsCookie },
                |m: &mut BuyResponse| { &mut m.serverLogsCookie },
                BuyResponse::get_serverLogsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "encodedDeliveryToken",
                |m: &BuyResponse| { &m.encodedDeliveryToken },
                |m: &mut BuyResponse| { &mut m.encodedDeliveryToken },
                BuyResponse::get_encodedDeliveryToken,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BuyResponse>(
                "BuyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyResponse {
        static instance: ::protobuf::rt::Lazy<BuyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(BuyResponse::new)
    }
}

impl ::protobuf::Clear for BuyResponse {
    fn clear(&mut self) {
        self.purchaseResponse.clear();
        self.continueViaUrl.clear();
        self.purchaseStatusUrl.clear();
        self.checkoutServiceId.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.baseCheckoutUrl.clear();
        self.tosCheckboxHtml.clear();
        self.permissionError = ::std::option::Option::None;
        self.purchaseStatusResponse.clear();
        self.purchaseCookie.clear();
        self.challenge.clear();
        self.addInstrumentPromptHtml.clear();
        self.confirmButtonText.clear();
        self.permissionErrorTitleText.clear();
        self.permissionErrorMessageText.clear();
        self.serverLogsCookie.clear();
        self.encodedDeliveryToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BuyResponse_CheckoutInfo {
    // message fields
    pub item: ::protobuf::SingularPtrField<LineItem>,
    pub subItem: ::protobuf::RepeatedField<LineItem>,
    // checkoutoption: <group>
    pub deprecatedCheckoutUrl: ::protobuf::SingularField<::std::string::String>,
    pub addInstrumentUrl: ::protobuf::SingularField<::std::string::String>,
    pub footerHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub eligibleInstrumentFamily: ::std::vec::Vec<i32>,
    pub footnoteHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub eligibleInstrument: ::protobuf::RepeatedField<Instrument>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BuyResponse_CheckoutInfo {
    pub fn new() -> BuyResponse_CheckoutInfo {
        ::std::default::Default::default()
    }

    // optional string deprecatedCheckoutUrl = 10;

    pub fn get_deprecatedCheckoutUrl(&self) -> &str {
        match self.deprecatedCheckoutUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string addInstrumentUrl = 11;

    pub fn get_addInstrumentUrl(&self) -> &str {
        match self.addInstrumentUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BuyResponse_CheckoutInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subItem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eligibleInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into::<LineItem, _>(wire_type, is, &mut self.item)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.subItem)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deprecatedCheckoutUrl)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addInstrumentUrl)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.eligibleInstrumentFamily)?;
                },
                36 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footnoteHtml)?;
                },
                44 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.eligibleInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.subItem {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.deprecatedCheckoutUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.addInstrumentUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.footerHtml {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.eligibleInstrumentFamily {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.footnoteHtml {
            my_size += ::protobuf::rt::string_size(36, &value);
        };
        for value in &self.eligibleInstrument {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.subItem {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.deprecatedCheckoutUrl.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.addInstrumentUrl.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.footerHtml {
            os.write_string(20, &v)?;
        };
        for v in &self.eligibleInstrumentFamily {
            os.write_int32(31, *v)?;
        };
        for v in &self.footnoteHtml {
            os.write_string(36, &v)?;
        };
        for v in &self.eligibleInstrument {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyResponse_CheckoutInfo {
        BuyResponse_CheckoutInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>, _>(
                "item",
                |m: &BuyResponse_CheckoutInfo| { &m.item },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>>(
                "subItem",
                |m: &BuyResponse_CheckoutInfo| { &m.subItem },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.subItem },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "deprecatedCheckoutUrl",
                |m: &BuyResponse_CheckoutInfo| { &m.deprecatedCheckoutUrl },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.deprecatedCheckoutUrl },
                BuyResponse_CheckoutInfo::get_deprecatedCheckoutUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "addInstrumentUrl",
                |m: &BuyResponse_CheckoutInfo| { &m.addInstrumentUrl },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.addInstrumentUrl },
                BuyResponse_CheckoutInfo::get_addInstrumentUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &BuyResponse_CheckoutInfo| { &m.footerHtml },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.footerHtml },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eligibleInstrumentFamily",
                |m: &BuyResponse_CheckoutInfo| { &m.eligibleInstrumentFamily },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.eligibleInstrumentFamily },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footnoteHtml",
                |m: &BuyResponse_CheckoutInfo| { &m.footnoteHtml },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.footnoteHtml },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "eligibleInstrument",
                |m: &BuyResponse_CheckoutInfo| { &m.eligibleInstrument },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.eligibleInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BuyResponse_CheckoutInfo>(
                "BuyResponse_CheckoutInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyResponse_CheckoutInfo {
        static instance: ::protobuf::rt::Lazy<BuyResponse_CheckoutInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(BuyResponse_CheckoutInfo::new)
    }
}

impl ::protobuf::Clear for BuyResponse_CheckoutInfo {
    fn clear(&mut self) {
        self.item.clear();
        self.subItem.clear();
        self.deprecatedCheckoutUrl.clear();
        self.addInstrumentUrl.clear();
        self.footerHtml.clear();
        self.eligibleInstrumentFamily.clear();
        self.footnoteHtml.clear();
        self.eligibleInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyResponse_CheckoutInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyResponse_CheckoutInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BuyResponse_CheckoutInfo_CheckoutOption {
    // message fields
    pub formOfPayment: ::protobuf::SingularField<::std::string::String>,
    pub encodedAdjustedCart: ::protobuf::SingularField<::std::string::String>,
    pub instrumentId: ::protobuf::SingularField<::std::string::String>,
    pub item: ::protobuf::RepeatedField<LineItem>,
    pub subItem: ::protobuf::RepeatedField<LineItem>,
    pub total: ::protobuf::SingularPtrField<LineItem>,
    pub footerHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub instrumentFamily: ::std::option::Option<i32>,
    pub selectedInstrument: ::std::option::Option<bool>,
    pub summary: ::protobuf::SingularPtrField<LineItem>,
    pub footnoteHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub instrument: ::protobuf::SingularPtrField<Instrument>,
    pub purchaseCookie: ::protobuf::SingularField<::std::string::String>,
    pub disabledReason: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BuyResponse_CheckoutInfo_CheckoutOption {
    pub fn new() -> BuyResponse_CheckoutInfo_CheckoutOption {
        ::std::default::Default::default()
    }

    // optional string formOfPayment = 6;

    pub fn get_formOfPayment(&self) -> &str {
        match self.formOfPayment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string encodedAdjustedCart = 7;

    pub fn get_encodedAdjustedCart(&self) -> &str {
        match self.encodedAdjustedCart.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string instrumentId = 15;

    pub fn get_instrumentId(&self) -> &str {
        match self.instrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 instrumentFamily = 29;

    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }

    // optional bool selectedInstrument = 32;

    pub fn get_selectedInstrument(&self) -> bool {
        self.selectedInstrument.unwrap_or(false)
    }

    // optional string purchaseCookie = 45;

    pub fn get_purchaseCookie(&self) -> &str {
        match self.purchaseCookie.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BuyResponse_CheckoutInfo_CheckoutOption {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subItem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.total {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formOfPayment)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encodedAdjustedCart)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentId)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.item)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.subItem)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into::<LineItem, _>(wire_type, is, &mut self.total)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selectedInstrument = ::std::option::Option::Some(tmp);
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into::<LineItem, _>(wire_type, is, &mut self.summary)?;
                },
                35 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footnoteHtml)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_message_into::<Instrument, _>(wire_type, is, &mut self.instrument)?;
                },
                45 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseCookie)?;
                },
                48 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.disabledReason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.formOfPayment.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.encodedAdjustedCart.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.instrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        for value in &self.item {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.subItem {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.footerHtml {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.selectedInstrument {
            my_size += 3;
        }
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.footnoteHtml {
            my_size += ::protobuf::rt::string_size(35, &value);
        };
        if let Some(v) = self.instrument.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(45, &v);
        }
        for value in &self.disabledReason {
            my_size += ::protobuf::rt::string_size(48, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.formOfPayment.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.encodedAdjustedCart.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.instrumentId.as_ref() {
            os.write_string(15, v)?;
        }
        for v in &self.item {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.subItem {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.total.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        for v in &self.footerHtml {
            os.write_string(19, &v)?;
        };
        if let Some(v) = self.instrumentFamily {
            os.write_int32(29, v)?;
        }
        if let Some(v) = self.selectedInstrument {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        for v in &self.footnoteHtml {
            os.write_string(35, &v)?;
        };
        if let Some(v) = self.instrument.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        }
        if let Some(v) = self.purchaseCookie.as_ref() {
            os.write_string(45, v)?;
        }
        for v in &self.disabledReason {
            os.write_string(48, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyResponse_CheckoutInfo_CheckoutOption {
        BuyResponse_CheckoutInfo_CheckoutOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "formOfPayment",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.formOfPayment },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.formOfPayment },
                BuyResponse_CheckoutInfo_CheckoutOption::get_formOfPayment,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "encodedAdjustedCart",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.encodedAdjustedCart },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.encodedAdjustedCart },
                BuyResponse_CheckoutInfo_CheckoutOption::get_encodedAdjustedCart,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "instrumentId",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.instrumentId },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.instrumentId },
                BuyResponse_CheckoutInfo_CheckoutOption::get_instrumentId,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>>(
                "item",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.item },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>>(
                "subItem",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.subItem },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.subItem },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>, _>(
                "total",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.total },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.total },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.footerHtml },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.footerHtml },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "instrumentFamily",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.instrumentFamily },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.instrumentFamily },
                BuyResponse_CheckoutInfo_CheckoutOption::get_instrumentFamily,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "selectedInstrument",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.selectedInstrument },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.selectedInstrument },
                BuyResponse_CheckoutInfo_CheckoutOption::get_selectedInstrument,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>, _>(
                "summary",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.summary },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.summary },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footnoteHtml",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.footnoteHtml },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.footnoteHtml },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>, _>(
                "instrument",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.instrument },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "purchaseCookie",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.purchaseCookie },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.purchaseCookie },
                BuyResponse_CheckoutInfo_CheckoutOption::get_purchaseCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "disabledReason",
                |m: &BuyResponse_CheckoutInfo_CheckoutOption| { &m.disabledReason },
                |m: &mut BuyResponse_CheckoutInfo_CheckoutOption| { &mut m.disabledReason },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BuyResponse_CheckoutInfo_CheckoutOption>(
                "BuyResponse_CheckoutInfo_CheckoutOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyResponse_CheckoutInfo_CheckoutOption {
        static instance: ::protobuf::rt::Lazy<BuyResponse_CheckoutInfo_CheckoutOption> = ::protobuf::rt::Lazy::INIT;
        instance.get(BuyResponse_CheckoutInfo_CheckoutOption::new)
    }
}

impl ::protobuf::Clear for BuyResponse_CheckoutInfo_CheckoutOption {
    fn clear(&mut self) {
        self.formOfPayment.clear();
        self.encodedAdjustedCart.clear();
        self.instrumentId.clear();
        self.item.clear();
        self.subItem.clear();
        self.total.clear();
        self.footerHtml.clear();
        self.instrumentFamily = ::std::option::Option::None;
        self.selectedInstrument = ::std::option::Option::None;
        self.summary.clear();
        self.footnoteHtml.clear();
        self.instrument.clear();
        self.purchaseCookie.clear();
        self.disabledReason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyResponse_CheckoutInfo_CheckoutOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyResponse_CheckoutInfo_CheckoutOption {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LineItem {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub offer: ::protobuf::SingularPtrField<Offer>,
    pub amount: ::protobuf::SingularPtrField<Money>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LineItem {
    pub fn new() -> LineItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string description = 2;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LineItem {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<Offer, _>(wire_type, is, &mut self.offer)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<Money, _>(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.offer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.offer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.amount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LineItem {
        LineItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &LineItem| { &m.name },
                |m: &mut LineItem| { &mut m.name },
                LineItem::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "description",
                |m: &LineItem| { &m.description },
                |m: &mut LineItem| { &mut m.description },
                LineItem::get_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>, _>(
                "offer",
                |m: &LineItem| { &m.offer },
                |m: &mut LineItem| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Money>, _>(
                "amount",
                |m: &LineItem| { &m.amount },
                |m: &mut LineItem| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LineItem>(
                "LineItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LineItem {
        static instance: ::protobuf::rt::Lazy<LineItem> = ::protobuf::rt::Lazy::INIT;
        instance.get(LineItem::new)
    }
}

impl ::protobuf::Clear for LineItem {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.offer.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LineItem {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Money {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub formattedAmount: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Money {
    pub fn new() -> Money {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;

    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional string currencyCode = 2;

    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string formattedAmount = 3;

    pub fn get_formattedAmount(&self) -> &str {
        match self.formattedAmount.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Money {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedAmount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.formattedAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.currencyCode.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.formattedAmount.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Money {
        Money::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "micros",
                |m: &Money| { &m.micros },
                |m: &mut Money| { &mut m.micros },
                Money::get_micros,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "currencyCode",
                |m: &Money| { &m.currencyCode },
                |m: &mut Money| { &mut m.currencyCode },
                Money::get_currencyCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "formattedAmount",
                |m: &Money| { &m.formattedAmount },
                |m: &mut Money| { &mut m.formattedAmount },
                Money::get_formattedAmount,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Money>(
                "Money",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Money {
        static instance: ::protobuf::rt::Lazy<Money> = ::protobuf::rt::Lazy::INIT;
        instance.get(Money::new)
    }
}

impl ::protobuf::Clear for Money {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.currencyCode.clear();
        self.formattedAmount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Money {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Money {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseNotificationResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub debugInfo: ::protobuf::SingularPtrField<DebugInfo>,
    pub localizedErrorMessage: ::protobuf::SingularField<::std::string::String>,
    pub purchaseId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseNotificationResponse {
    pub fn new() -> PurchaseNotificationResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;

    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional string localizedErrorMessage = 3;

    pub fn get_localizedErrorMessage(&self) -> &str {
        match self.localizedErrorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string purchaseId = 4;

    pub fn get_purchaseId(&self) -> &str {
        match self.purchaseId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseNotificationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.debugInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<DebugInfo, _>(wire_type, is, &mut self.debugInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedErrorMessage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.debugInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.localizedErrorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.purchaseId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.debugInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.localizedErrorMessage.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.purchaseId.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseNotificationResponse {
        PurchaseNotificationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "status",
                |m: &PurchaseNotificationResponse| { &m.status },
                |m: &mut PurchaseNotificationResponse| { &mut m.status },
                PurchaseNotificationResponse::get_status,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugInfo>, _>(
                "debugInfo",
                |m: &PurchaseNotificationResponse| { &m.debugInfo },
                |m: &mut PurchaseNotificationResponse| { &mut m.debugInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "localizedErrorMessage",
                |m: &PurchaseNotificationResponse| { &m.localizedErrorMessage },
                |m: &mut PurchaseNotificationResponse| { &mut m.localizedErrorMessage },
                PurchaseNotificationResponse::get_localizedErrorMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "purchaseId",
                |m: &PurchaseNotificationResponse| { &m.purchaseId },
                |m: &mut PurchaseNotificationResponse| { &mut m.purchaseId },
                PurchaseNotificationResponse::get_purchaseId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseNotificationResponse>(
                "PurchaseNotificationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseNotificationResponse {
        static instance: ::protobuf::rt::Lazy<PurchaseNotificationResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseNotificationResponse::new)
    }
}

impl ::protobuf::Clear for PurchaseNotificationResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.debugInfo.clear();
        self.localizedErrorMessage.clear();
        self.purchaseId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseNotificationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseNotificationResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseStatusResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub statusMsg: ::protobuf::SingularField<::std::string::String>,
    pub statusTitle: ::protobuf::SingularField<::std::string::String>,
    pub briefMessage: ::protobuf::SingularField<::std::string::String>,
    pub infoUrl: ::protobuf::SingularField<::std::string::String>,
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    pub rejectedInstrument: ::protobuf::SingularPtrField<Instrument>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseStatusResponse {
    pub fn new() -> PurchaseStatusResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;

    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional string statusMsg = 2;

    pub fn get_statusMsg(&self) -> &str {
        match self.statusMsg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string statusTitle = 3;

    pub fn get_statusTitle(&self) -> &str {
        match self.statusTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string briefMessage = 4;

    pub fn get_briefMessage(&self) -> &str {
        match self.briefMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string infoUrl = 5;

    pub fn get_infoUrl(&self) -> &str {
        match self.infoUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rejectedInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.statusMsg)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.statusTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.briefMessage)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.infoUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryUpdate, _>(wire_type, is, &mut self.libraryUpdate)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<Instrument, _>(wire_type, is, &mut self.rejectedInstrument)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<AndroidAppDeliveryData, _>(wire_type, is, &mut self.appDeliveryData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.statusMsg.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.statusTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.briefMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.infoUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rejectedInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.statusMsg.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.statusTitle.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.briefMessage.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.infoUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.libraryUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.rejectedInstrument.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.appDeliveryData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseStatusResponse {
        PurchaseStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "status",
                |m: &PurchaseStatusResponse| { &m.status },
                |m: &mut PurchaseStatusResponse| { &mut m.status },
                PurchaseStatusResponse::get_status,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "statusMsg",
                |m: &PurchaseStatusResponse| { &m.statusMsg },
                |m: &mut PurchaseStatusResponse| { &mut m.statusMsg },
                PurchaseStatusResponse::get_statusMsg,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "statusTitle",
                |m: &PurchaseStatusResponse| { &m.statusTitle },
                |m: &mut PurchaseStatusResponse| { &mut m.statusTitle },
                PurchaseStatusResponse::get_statusTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "briefMessage",
                |m: &PurchaseStatusResponse| { &m.briefMessage },
                |m: &mut PurchaseStatusResponse| { &mut m.briefMessage },
                PurchaseStatusResponse::get_briefMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "infoUrl",
                |m: &PurchaseStatusResponse| { &m.infoUrl },
                |m: &mut PurchaseStatusResponse| { &mut m.infoUrl },
                PurchaseStatusResponse::get_infoUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>, _>(
                "libraryUpdate",
                |m: &PurchaseStatusResponse| { &m.libraryUpdate },
                |m: &mut PurchaseStatusResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>, _>(
                "rejectedInstrument",
                |m: &PurchaseStatusResponse| { &m.rejectedInstrument },
                |m: &mut PurchaseStatusResponse| { &mut m.rejectedInstrument },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>, _>(
                "appDeliveryData",
                |m: &PurchaseStatusResponse| { &m.appDeliveryData },
                |m: &mut PurchaseStatusResponse| { &mut m.appDeliveryData },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseStatusResponse>(
                "PurchaseStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseStatusResponse {
        static instance: ::protobuf::rt::Lazy<PurchaseStatusResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseStatusResponse::new)
    }
}

impl ::protobuf::Clear for PurchaseStatusResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.statusMsg.clear();
        self.statusTitle.clear();
        self.briefMessage.clear();
        self.infoUrl.clear();
        self.libraryUpdate.clear();
        self.rejectedInstrument.clear();
        self.appDeliveryData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseStatusResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BillingProfileResponse {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub billingProfile: ::protobuf::SingularPtrField<BillingProfile>,
    pub userMessageHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BillingProfileResponse {
    pub fn new() -> BillingProfileResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional string userMessageHtml = 3;

    pub fn get_userMessageHtml(&self) -> &str {
        match self.userMessageHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BillingProfileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.billingProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<BillingProfile, _>(wire_type, is, &mut self.billingProfile)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userMessageHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.billingProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.userMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.billingProfile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.userMessageHtml.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingProfileResponse {
        BillingProfileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "result",
                |m: &BillingProfileResponse| { &m.result },
                |m: &mut BillingProfileResponse| { &mut m.result },
                BillingProfileResponse::get_result,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingProfile>, _>(
                "billingProfile",
                |m: &BillingProfileResponse| { &m.billingProfile },
                |m: &mut BillingProfileResponse| { &mut m.billingProfile },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userMessageHtml",
                |m: &BillingProfileResponse| { &m.userMessageHtml },
                |m: &mut BillingProfileResponse| { &mut m.userMessageHtml },
                BillingProfileResponse::get_userMessageHtml,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BillingProfileResponse>(
                "BillingProfileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingProfileResponse {
        static instance: ::protobuf::rt::Lazy<BillingProfileResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(BillingProfileResponse::new)
    }
}

impl ::protobuf::Clear for BillingProfileResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.billingProfile.clear();
        self.userMessageHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingProfileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingProfileResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CheckInstrumentResponse {
    // message fields
    pub userHasValidInstrument: ::std::option::Option<bool>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    pub instrument: ::protobuf::RepeatedField<Instrument>,
    pub eligibleInstrument: ::protobuf::RepeatedField<Instrument>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CheckInstrumentResponse {
    pub fn new() -> CheckInstrumentResponse {
        ::std::default::Default::default()
    }

    // optional bool userHasValidInstrument = 1;

    pub fn get_userHasValidInstrument(&self) -> bool {
        self.userHasValidInstrument.unwrap_or(false)
    }

    // optional bool checkoutTokenRequired = 2;

    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for CheckInstrumentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eligibleInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.userHasValidInstrument = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.instrument)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.eligibleInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.userHasValidInstrument {
            my_size += 2;
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        for value in &self.instrument {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.eligibleInstrument {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.userHasValidInstrument {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(2, v)?;
        }
        for v in &self.instrument {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.eligibleInstrument {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckInstrumentResponse {
        CheckInstrumentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "userHasValidInstrument",
                |m: &CheckInstrumentResponse| { &m.userHasValidInstrument },
                |m: &mut CheckInstrumentResponse| { &mut m.userHasValidInstrument },
                CheckInstrumentResponse::get_userHasValidInstrument,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "checkoutTokenRequired",
                |m: &CheckInstrumentResponse| { &m.checkoutTokenRequired },
                |m: &mut CheckInstrumentResponse| { &mut m.checkoutTokenRequired },
                CheckInstrumentResponse::get_checkoutTokenRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "instrument",
                |m: &CheckInstrumentResponse| { &m.instrument },
                |m: &mut CheckInstrumentResponse| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "eligibleInstrument",
                |m: &CheckInstrumentResponse| { &m.eligibleInstrument },
                |m: &mut CheckInstrumentResponse| { &mut m.eligibleInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CheckInstrumentResponse>(
                "CheckInstrumentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckInstrumentResponse {
        static instance: ::protobuf::rt::Lazy<CheckInstrumentResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CheckInstrumentResponse::new)
    }
}

impl ::protobuf::Clear for CheckInstrumentResponse {
    fn clear(&mut self) {
        self.userHasValidInstrument = ::std::option::Option::None;
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.instrument.clear();
        self.eligibleInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckInstrumentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckInstrumentResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InstrumentSetupInfoResponse {
    // message fields
    pub setupInfo: ::protobuf::RepeatedField<InstrumentSetupInfo>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InstrumentSetupInfoResponse {
    pub fn new() -> InstrumentSetupInfoResponse {
        ::std::default::Default::default()
    }

    // optional bool checkoutTokenRequired = 2;

    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for InstrumentSetupInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.setupInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.setupInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.setupInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.setupInfo {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentSetupInfoResponse {
        InstrumentSetupInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstrumentSetupInfo>>(
                "setupInfo",
                |m: &InstrumentSetupInfoResponse| { &m.setupInfo },
                |m: &mut InstrumentSetupInfoResponse| { &mut m.setupInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "checkoutTokenRequired",
                |m: &InstrumentSetupInfoResponse| { &m.checkoutTokenRequired },
                |m: &mut InstrumentSetupInfoResponse| { &mut m.checkoutTokenRequired },
                InstrumentSetupInfoResponse::get_checkoutTokenRequired,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InstrumentSetupInfoResponse>(
                "InstrumentSetupInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentSetupInfoResponse {
        static instance: ::protobuf::rt::Lazy<InstrumentSetupInfoResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(InstrumentSetupInfoResponse::new)
    }
}

impl ::protobuf::Clear for InstrumentSetupInfoResponse {
    fn clear(&mut self) {
        self.setupInfo.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentSetupInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentSetupInfoResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RedeemGiftCardRequest {
    // message fields
    pub giftCardPin: ::protobuf::SingularField<::std::string::String>,
    pub address: ::protobuf::SingularPtrField<Address>,
    pub acceptedLegalDocumentId: ::protobuf::RepeatedField<::std::string::String>,
    pub checkoutToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RedeemGiftCardRequest {
    pub fn new() -> RedeemGiftCardRequest {
        ::std::default::Default::default()
    }

    // optional string giftCardPin = 1;

    pub fn get_giftCardPin(&self) -> &str {
        match self.giftCardPin.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string checkoutToken = 4;

    pub fn get_checkoutToken(&self) -> &str {
        match self.checkoutToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RedeemGiftCardRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.giftCardPin)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Address, _>(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.acceptedLegalDocumentId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.giftCardPin.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.acceptedLegalDocumentId {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.checkoutToken.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.giftCardPin.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.acceptedLegalDocumentId {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.checkoutToken.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemGiftCardRequest {
        RedeemGiftCardRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "giftCardPin",
                |m: &RedeemGiftCardRequest| { &m.giftCardPin },
                |m: &mut RedeemGiftCardRequest| { &mut m.giftCardPin },
                RedeemGiftCardRequest::get_giftCardPin,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>, _>(
                "address",
                |m: &RedeemGiftCardRequest| { &m.address },
                |m: &mut RedeemGiftCardRequest| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acceptedLegalDocumentId",
                |m: &RedeemGiftCardRequest| { &m.acceptedLegalDocumentId },
                |m: &mut RedeemGiftCardRequest| { &mut m.acceptedLegalDocumentId },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "checkoutToken",
                |m: &RedeemGiftCardRequest| { &m.checkoutToken },
                |m: &mut RedeemGiftCardRequest| { &mut m.checkoutToken },
                RedeemGiftCardRequest::get_checkoutToken,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RedeemGiftCardRequest>(
                "RedeemGiftCardRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemGiftCardRequest {
        static instance: ::protobuf::rt::Lazy<RedeemGiftCardRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(RedeemGiftCardRequest::new)
    }
}

impl ::protobuf::Clear for RedeemGiftCardRequest {
    fn clear(&mut self) {
        self.giftCardPin.clear();
        self.address.clear();
        self.acceptedLegalDocumentId.clear();
        self.checkoutToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemGiftCardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemGiftCardRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RedeemGiftCardResponse {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub userMessageHtml: ::protobuf::SingularField<::std::string::String>,
    pub balanceHtml: ::protobuf::SingularField<::std::string::String>,
    pub addressChallenge: ::protobuf::SingularPtrField<AddressChallenge>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RedeemGiftCardResponse {
    pub fn new() -> RedeemGiftCardResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional string userMessageHtml = 2;

    pub fn get_userMessageHtml(&self) -> &str {
        match self.userMessageHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string balanceHtml = 3;

    pub fn get_balanceHtml(&self) -> &str {
        match self.balanceHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool checkoutTokenRequired = 5;

    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for RedeemGiftCardResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.addressChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userMessageHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.balanceHtml)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<AddressChallenge, _>(wire_type, is, &mut self.addressChallenge)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.userMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.balanceHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.addressChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.userMessageHtml.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.balanceHtml.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.addressChallenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemGiftCardResponse {
        RedeemGiftCardResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "result",
                |m: &RedeemGiftCardResponse| { &m.result },
                |m: &mut RedeemGiftCardResponse| { &mut m.result },
                RedeemGiftCardResponse::get_result,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userMessageHtml",
                |m: &RedeemGiftCardResponse| { &m.userMessageHtml },
                |m: &mut RedeemGiftCardResponse| { &mut m.userMessageHtml },
                RedeemGiftCardResponse::get_userMessageHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "balanceHtml",
                |m: &RedeemGiftCardResponse| { &m.balanceHtml },
                |m: &mut RedeemGiftCardResponse| { &mut m.balanceHtml },
                RedeemGiftCardResponse::get_balanceHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressChallenge>, _>(
                "addressChallenge",
                |m: &RedeemGiftCardResponse| { &m.addressChallenge },
                |m: &mut RedeemGiftCardResponse| { &mut m.addressChallenge },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "checkoutTokenRequired",
                |m: &RedeemGiftCardResponse| { &m.checkoutTokenRequired },
                |m: &mut RedeemGiftCardResponse| { &mut m.checkoutTokenRequired },
                RedeemGiftCardResponse::get_checkoutTokenRequired,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RedeemGiftCardResponse>(
                "RedeemGiftCardResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemGiftCardResponse {
        static instance: ::protobuf::rt::Lazy<RedeemGiftCardResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(RedeemGiftCardResponse::new)
    }
}

impl ::protobuf::Clear for RedeemGiftCardResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.userMessageHtml.clear();
        self.balanceHtml.clear();
        self.addressChallenge.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemGiftCardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemGiftCardResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UpdateInstrumentRequest {
    // message fields
    pub instrument: ::protobuf::SingularPtrField<Instrument>,
    pub checkoutToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UpdateInstrumentRequest {
    pub fn new() -> UpdateInstrumentRequest {
        ::std::default::Default::default()
    }

    // optional string checkoutToken = 2;

    pub fn get_checkoutToken(&self) -> &str {
        match self.checkoutToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UpdateInstrumentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Instrument, _>(wire_type, is, &mut self.instrument)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkoutToken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrument.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.checkoutToken.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateInstrumentRequest {
        UpdateInstrumentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>, _>(
                "instrument",
                |m: &UpdateInstrumentRequest| { &m.instrument },
                |m: &mut UpdateInstrumentRequest| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "checkoutToken",
                |m: &UpdateInstrumentRequest| { &m.checkoutToken },
                |m: &mut UpdateInstrumentRequest| { &mut m.checkoutToken },
                UpdateInstrumentRequest::get_checkoutToken,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<UpdateInstrumentRequest>(
                "UpdateInstrumentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateInstrumentRequest {
        static instance: ::protobuf::rt::Lazy<UpdateInstrumentRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(UpdateInstrumentRequest::new)
    }
}

impl ::protobuf::Clear for UpdateInstrumentRequest {
    fn clear(&mut self) {
        self.instrument.clear();
        self.checkoutToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateInstrumentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateInstrumentRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UpdateInstrumentResponse {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub instrumentId: ::protobuf::SingularField<::std::string::String>,
    pub userMessageHtml: ::protobuf::SingularField<::std::string::String>,
    pub errorInputField: ::protobuf::RepeatedField<InputValidationError>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    pub redeemedOffer: ::protobuf::SingularPtrField<RedeemedPromoOffer>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UpdateInstrumentResponse {
    pub fn new() -> UpdateInstrumentResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional string instrumentId = 2;

    pub fn get_instrumentId(&self) -> &str {
        match self.instrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string userMessageHtml = 3;

    pub fn get_userMessageHtml(&self) -> &str {
        match self.userMessageHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool checkoutTokenRequired = 5;

    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for UpdateInstrumentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.errorInputField {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemedOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userMessageHtml)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.errorInputField)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<RedeemedPromoOffer, _>(wire_type, is, &mut self.redeemedOffer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.instrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.userMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.errorInputField {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        if let Some(v) = self.redeemedOffer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.instrumentId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.userMessageHtml.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.errorInputField {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.redeemedOffer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateInstrumentResponse {
        UpdateInstrumentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "result",
                |m: &UpdateInstrumentResponse| { &m.result },
                |m: &mut UpdateInstrumentResponse| { &mut m.result },
                UpdateInstrumentResponse::get_result,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "instrumentId",
                |m: &UpdateInstrumentResponse| { &m.instrumentId },
                |m: &mut UpdateInstrumentResponse| { &mut m.instrumentId },
                UpdateInstrumentResponse::get_instrumentId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userMessageHtml",
                |m: &UpdateInstrumentResponse| { &m.userMessageHtml },
                |m: &mut UpdateInstrumentResponse| { &mut m.userMessageHtml },
                UpdateInstrumentResponse::get_userMessageHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputValidationError>>(
                "errorInputField",
                |m: &UpdateInstrumentResponse| { &m.errorInputField },
                |m: &mut UpdateInstrumentResponse| { &mut m.errorInputField },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "checkoutTokenRequired",
                |m: &UpdateInstrumentResponse| { &m.checkoutTokenRequired },
                |m: &mut UpdateInstrumentResponse| { &mut m.checkoutTokenRequired },
                UpdateInstrumentResponse::get_checkoutTokenRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemedPromoOffer>, _>(
                "redeemedOffer",
                |m: &UpdateInstrumentResponse| { &m.redeemedOffer },
                |m: &mut UpdateInstrumentResponse| { &mut m.redeemedOffer },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<UpdateInstrumentResponse>(
                "UpdateInstrumentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateInstrumentResponse {
        static instance: ::protobuf::rt::Lazy<UpdateInstrumentResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(UpdateInstrumentResponse::new)
    }
}

impl ::protobuf::Clear for UpdateInstrumentResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.instrumentId.clear();
        self.userMessageHtml.clear();
        self.errorInputField.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.redeemedOffer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateInstrumentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateInstrumentResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InitiateAssociationResponse {
    // message fields
    pub userToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InitiateAssociationResponse {
    pub fn new() -> InitiateAssociationResponse {
        ::std::default::Default::default()
    }

    // optional string userToken = 1;

    pub fn get_userToken(&self) -> &str {
        match self.userToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for InitiateAssociationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.userToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.userToken.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitiateAssociationResponse {
        InitiateAssociationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userToken",
                |m: &InitiateAssociationResponse| { &m.userToken },
                |m: &mut InitiateAssociationResponse| { &mut m.userToken },
                InitiateAssociationResponse::get_userToken,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InitiateAssociationResponse>(
                "InitiateAssociationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InitiateAssociationResponse {
        static instance: ::protobuf::rt::Lazy<InitiateAssociationResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(InitiateAssociationResponse::new)
    }
}

impl ::protobuf::Clear for InitiateAssociationResponse {
    fn clear(&mut self) {
        self.userToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitiateAssociationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitiateAssociationResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct VerifyAssociationResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub billingAddress: ::protobuf::SingularPtrField<Address>,
    pub carrierTos: ::protobuf::SingularPtrField<CarrierTos>,
    pub carrierErrorMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl VerifyAssociationResponse {
    pub fn new() -> VerifyAssociationResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;

    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional string carrierErrorMessage = 4;

    pub fn get_carrierErrorMessage(&self) -> &str {
        match self.carrierErrorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VerifyAssociationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.billingAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierTos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Address, _>(wire_type, is, &mut self.billingAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierTos, _>(wire_type, is, &mut self.carrierTos)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrierErrorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.billingAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.carrierTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.carrierErrorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.billingAddress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.carrierTos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.carrierErrorMessage.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyAssociationResponse {
        VerifyAssociationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "status",
                |m: &VerifyAssociationResponse| { &m.status },
                |m: &mut VerifyAssociationResponse| { &mut m.status },
                VerifyAssociationResponse::get_status,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>, _>(
                "billingAddress",
                |m: &VerifyAssociationResponse| { &m.billingAddress },
                |m: &mut VerifyAssociationResponse| { &mut m.billingAddress },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTos>, _>(
                "carrierTos",
                |m: &VerifyAssociationResponse| { &m.carrierTos },
                |m: &mut VerifyAssociationResponse| { &mut m.carrierTos },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "carrierErrorMessage",
                |m: &VerifyAssociationResponse| { &m.carrierErrorMessage },
                |m: &mut VerifyAssociationResponse| { &mut m.carrierErrorMessage },
                VerifyAssociationResponse::get_carrierErrorMessage,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<VerifyAssociationResponse>(
                "VerifyAssociationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyAssociationResponse {
        static instance: ::protobuf::rt::Lazy<VerifyAssociationResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(VerifyAssociationResponse::new)
    }
}

impl ::protobuf::Clear for VerifyAssociationResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.billingAddress.clear();
        self.carrierTos.clear();
        self.carrierErrorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyAssociationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyAssociationResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AddressChallenge {
    // message fields
    pub responseAddressParam: ::protobuf::SingularField<::std::string::String>,
    pub responseCheckboxesParam: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub checkbox: ::protobuf::RepeatedField<FormCheckbox>,
    pub address: ::protobuf::SingularPtrField<Address>,
    pub errorInputField: ::protobuf::RepeatedField<InputValidationError>,
    pub errorHtml: ::protobuf::SingularField<::std::string::String>,
    pub requiredField: ::std::vec::Vec<i32>,
    pub supportedCountry: ::protobuf::RepeatedField<Country>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AddressChallenge {
    pub fn new() -> AddressChallenge {
        ::std::default::Default::default()
    }

    // optional string responseAddressParam = 1;

    pub fn get_responseAddressParam(&self) -> &str {
        match self.responseAddressParam.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string responseCheckboxesParam = 2;

    pub fn get_responseCheckboxesParam(&self) -> &str {
        match self.responseCheckboxesParam.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string title = 3;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string descriptionHtml = 4;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string errorHtml = 8;

    pub fn get_errorHtml(&self) -> &str {
        match self.errorHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AddressChallenge {
    fn is_initialized(&self) -> bool {
        for v in &self.checkbox {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.errorInputField {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.supportedCountry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseAddressParam)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseCheckboxesParam)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.checkbox)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<Address, _>(wire_type, is, &mut self.address)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.errorInputField)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorHtml)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.requiredField)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.supportedCountry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.responseAddressParam.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.responseCheckboxesParam.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.checkbox {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errorInputField {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.errorHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.requiredField {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.supportedCountry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.responseAddressParam.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.responseCheckboxesParam.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.checkbox {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.errorInputField {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.errorHtml.as_ref() {
            os.write_string(8, v)?;
        }
        for v in &self.requiredField {
            os.write_int32(9, *v)?;
        };
        for v in &self.supportedCountry {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressChallenge {
        AddressChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "responseAddressParam",
                |m: &AddressChallenge| { &m.responseAddressParam },
                |m: &mut AddressChallenge| { &mut m.responseAddressParam },
                AddressChallenge::get_responseAddressParam,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "responseCheckboxesParam",
                |m: &AddressChallenge| { &m.responseCheckboxesParam },
                |m: &mut AddressChallenge| { &mut m.responseCheckboxesParam },
                AddressChallenge::get_responseCheckboxesParam,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &AddressChallenge| { &m.title },
                |m: &mut AddressChallenge| { &mut m.title },
                AddressChallenge::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &AddressChallenge| { &m.descriptionHtml },
                |m: &mut AddressChallenge| { &mut m.descriptionHtml },
                AddressChallenge::get_descriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FormCheckbox>>(
                "checkbox",
                |m: &AddressChallenge| { &m.checkbox },
                |m: &mut AddressChallenge| { &mut m.checkbox },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>, _>(
                "address",
                |m: &AddressChallenge| { &m.address },
                |m: &mut AddressChallenge| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputValidationError>>(
                "errorInputField",
                |m: &AddressChallenge| { &m.errorInputField },
                |m: &mut AddressChallenge| { &mut m.errorInputField },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "errorHtml",
                |m: &AddressChallenge| { &m.errorHtml },
                |m: &mut AddressChallenge| { &mut m.errorHtml },
                AddressChallenge::get_errorHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "requiredField",
                |m: &AddressChallenge| { &m.requiredField },
                |m: &mut AddressChallenge| { &mut m.requiredField },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Country>>(
                "supportedCountry",
                |m: &AddressChallenge| { &m.supportedCountry },
                |m: &mut AddressChallenge| { &mut m.supportedCountry },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AddressChallenge>(
                "AddressChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressChallenge {
        static instance: ::protobuf::rt::Lazy<AddressChallenge> = ::protobuf::rt::Lazy::INIT;
        instance.get(AddressChallenge::new)
    }
}

impl ::protobuf::Clear for AddressChallenge {
    fn clear(&mut self) {
        self.responseAddressParam.clear();
        self.responseCheckboxesParam.clear();
        self.title.clear();
        self.descriptionHtml.clear();
        self.checkbox.clear();
        self.address.clear();
        self.errorInputField.clear();
        self.errorHtml.clear();
        self.requiredField.clear();
        self.supportedCountry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressChallenge {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AuthenticationChallenge {
    // message fields
    pub authenticationType: ::std::option::Option<i32>,
    pub responseAuthenticationTypeParam: ::protobuf::SingularField<::std::string::String>,
    pub responseRetryCountParam: ::protobuf::SingularField<::std::string::String>,
    pub gaiaHeaderText: ::protobuf::SingularField<::std::string::String>,
    pub gaiaDescriptionTextHtml: ::protobuf::SingularField<::std::string::String>,
    pub gaiaFooterTextHtml: ::protobuf::SingularField<::std::string::String>,
    pub gaiaOptOutCheckbox: ::protobuf::SingularPtrField<FormCheckbox>,
    pub gaiaOptOutDescriptionTextHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AuthenticationChallenge {
    pub fn new() -> AuthenticationChallenge {
        ::std::default::Default::default()
    }

    // optional int32 authenticationType = 1;

    pub fn get_authenticationType(&self) -> i32 {
        self.authenticationType.unwrap_or(0)
    }

    // optional string responseAuthenticationTypeParam = 2;

    pub fn get_responseAuthenticationTypeParam(&self) -> &str {
        match self.responseAuthenticationTypeParam.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string responseRetryCountParam = 3;

    pub fn get_responseRetryCountParam(&self) -> &str {
        match self.responseRetryCountParam.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string gaiaHeaderText = 6;

    pub fn get_gaiaHeaderText(&self) -> &str {
        match self.gaiaHeaderText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string gaiaDescriptionTextHtml = 7;

    pub fn get_gaiaDescriptionTextHtml(&self) -> &str {
        match self.gaiaDescriptionTextHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string gaiaFooterTextHtml = 8;

    pub fn get_gaiaFooterTextHtml(&self) -> &str {
        match self.gaiaFooterTextHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string gaiaOptOutDescriptionTextHtml = 10;

    pub fn get_gaiaOptOutDescriptionTextHtml(&self) -> &str {
        match self.gaiaOptOutDescriptionTextHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AuthenticationChallenge {
    fn is_initialized(&self) -> bool {
        for v in &self.gaiaOptOutCheckbox {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.authenticationType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseAuthenticationTypeParam)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseRetryCountParam)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaHeaderText)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaDescriptionTextHtml)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaFooterTextHtml)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<FormCheckbox, _>(wire_type, is, &mut self.gaiaOptOutCheckbox)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaOptOutDescriptionTextHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.authenticationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.responseAuthenticationTypeParam.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.responseRetryCountParam.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.gaiaHeaderText.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.gaiaDescriptionTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.gaiaFooterTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.gaiaOptOutCheckbox.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.gaiaOptOutDescriptionTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.authenticationType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.responseAuthenticationTypeParam.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.responseRetryCountParam.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.gaiaHeaderText.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.gaiaDescriptionTextHtml.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.gaiaFooterTextHtml.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.gaiaOptOutCheckbox.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.gaiaOptOutDescriptionTextHtml.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticationChallenge {
        AuthenticationChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "authenticationType",
                |m: &AuthenticationChallenge| { &m.authenticationType },
                |m: &mut AuthenticationChallenge| { &mut m.authenticationType },
                AuthenticationChallenge::get_authenticationType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "responseAuthenticationTypeParam",
                |m: &AuthenticationChallenge| { &m.responseAuthenticationTypeParam },
                |m: &mut AuthenticationChallenge| { &mut m.responseAuthenticationTypeParam },
                AuthenticationChallenge::get_responseAuthenticationTypeParam,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "responseRetryCountParam",
                |m: &AuthenticationChallenge| { &m.responseRetryCountParam },
                |m: &mut AuthenticationChallenge| { &mut m.responseRetryCountParam },
                AuthenticationChallenge::get_responseRetryCountParam,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gaiaHeaderText",
                |m: &AuthenticationChallenge| { &m.gaiaHeaderText },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaHeaderText },
                AuthenticationChallenge::get_gaiaHeaderText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gaiaDescriptionTextHtml",
                |m: &AuthenticationChallenge| { &m.gaiaDescriptionTextHtml },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaDescriptionTextHtml },
                AuthenticationChallenge::get_gaiaDescriptionTextHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gaiaFooterTextHtml",
                |m: &AuthenticationChallenge| { &m.gaiaFooterTextHtml },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaFooterTextHtml },
                AuthenticationChallenge::get_gaiaFooterTextHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FormCheckbox>, _>(
                "gaiaOptOutCheckbox",
                |m: &AuthenticationChallenge| { &m.gaiaOptOutCheckbox },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaOptOutCheckbox },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gaiaOptOutDescriptionTextHtml",
                |m: &AuthenticationChallenge| { &m.gaiaOptOutDescriptionTextHtml },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaOptOutDescriptionTextHtml },
                AuthenticationChallenge::get_gaiaOptOutDescriptionTextHtml,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AuthenticationChallenge>(
                "AuthenticationChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticationChallenge {
        static instance: ::protobuf::rt::Lazy<AuthenticationChallenge> = ::protobuf::rt::Lazy::INIT;
        instance.get(AuthenticationChallenge::new)
    }
}

impl ::protobuf::Clear for AuthenticationChallenge {
    fn clear(&mut self) {
        self.authenticationType = ::std::option::Option::None;
        self.responseAuthenticationTypeParam.clear();
        self.responseRetryCountParam.clear();
        self.gaiaHeaderText.clear();
        self.gaiaDescriptionTextHtml.clear();
        self.gaiaFooterTextHtml.clear();
        self.gaiaOptOutCheckbox.clear();
        self.gaiaOptOutDescriptionTextHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticationChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticationChallenge {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Challenge {
    // message fields
    pub addressChallenge: ::protobuf::SingularPtrField<AddressChallenge>,
    pub authenticationChallenge: ::protobuf::SingularPtrField<AuthenticationChallenge>,
    pub webViewChallenge: ::protobuf::SingularPtrField<WebViewChallenge>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Challenge {
    pub fn new() -> Challenge {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Challenge {
    fn is_initialized(&self) -> bool {
        for v in &self.addressChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authenticationChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.webViewChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<AddressChallenge, _>(wire_type, is, &mut self.addressChallenge)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<AuthenticationChallenge, _>(wire_type, is, &mut self.authenticationChallenge)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<WebViewChallenge, _>(wire_type, is, &mut self.webViewChallenge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.addressChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.authenticationChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.webViewChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.addressChallenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.authenticationChallenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.webViewChallenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Challenge {
        Challenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressChallenge>, _>(
                "addressChallenge",
                |m: &Challenge| { &m.addressChallenge },
                |m: &mut Challenge| { &mut m.addressChallenge },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthenticationChallenge>, _>(
                "authenticationChallenge",
                |m: &Challenge| { &m.authenticationChallenge },
                |m: &mut Challenge| { &mut m.authenticationChallenge },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WebViewChallenge>, _>(
                "webViewChallenge",
                |m: &Challenge| { &m.webViewChallenge },
                |m: &mut Challenge| { &mut m.webViewChallenge },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Challenge>(
                "Challenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Challenge {
        static instance: ::protobuf::rt::Lazy<Challenge> = ::protobuf::rt::Lazy::INIT;
        instance.get(Challenge::new)
    }
}

impl ::protobuf::Clear for Challenge {
    fn clear(&mut self) {
        self.addressChallenge.clear();
        self.authenticationChallenge.clear();
        self.webViewChallenge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Challenge {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Country {
    // message fields
    pub regionCode: ::protobuf::SingularField<::std::string::String>,
    pub displayName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Country {
    pub fn new() -> Country {
        ::std::default::Default::default()
    }

    // optional string regionCode = 1;

    pub fn get_regionCode(&self) -> &str {
        match self.regionCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string displayName = 2;

    pub fn get_displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Country {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.regionCode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.regionCode.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.regionCode.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Country {
        Country::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "regionCode",
                |m: &Country| { &m.regionCode },
                |m: &mut Country| { &mut m.regionCode },
                Country::get_regionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "displayName",
                |m: &Country| { &m.displayName },
                |m: &mut Country| { &mut m.displayName },
                Country::get_displayName,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Country>(
                "Country",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Country {
        static instance: ::protobuf::rt::Lazy<Country> = ::protobuf::rt::Lazy::INIT;
        instance.get(Country::new)
    }
}

impl ::protobuf::Clear for Country {
    fn clear(&mut self) {
        self.regionCode.clear();
        self.displayName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Country {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Country {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct FormCheckbox {
    // message fields
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub checked: ::std::option::Option<bool>,
    pub required: ::std::option::Option<bool>,
    pub id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl FormCheckbox {
    pub fn new() -> FormCheckbox {
        ::std::default::Default::default()
    }

    // optional string description = 1;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool checked = 2;

    pub fn get_checked(&self) -> bool {
        self.checked.unwrap_or(false)
    }

    // optional bool required = 3;

    pub fn get_required(&self) -> bool {
        self.required.unwrap_or(false)
    }

    // optional string id = 4;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for FormCheckbox {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checked = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.required = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.checked {
            my_size += 2;
        }
        if let Some(v) = self.required {
            my_size += 2;
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.checked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FormCheckbox {
        FormCheckbox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "description",
                |m: &FormCheckbox| { &m.description },
                |m: &mut FormCheckbox| { &mut m.description },
                FormCheckbox::get_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "checked",
                |m: &FormCheckbox| { &m.checked },
                |m: &mut FormCheckbox| { &mut m.checked },
                FormCheckbox::get_checked,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "required",
                |m: &FormCheckbox| { &m.required },
                |m: &mut FormCheckbox| { &mut m.required },
                FormCheckbox::get_required,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "id",
                |m: &FormCheckbox| { &m.id },
                |m: &mut FormCheckbox| { &mut m.id },
                FormCheckbox::get_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<FormCheckbox>(
                "FormCheckbox",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FormCheckbox {
        static instance: ::protobuf::rt::Lazy<FormCheckbox> = ::protobuf::rt::Lazy::INIT;
        instance.get(FormCheckbox::new)
    }
}

impl ::protobuf::Clear for FormCheckbox {
    fn clear(&mut self) {
        self.description.clear();
        self.checked = ::std::option::Option::None;
        self.required = ::std::option::Option::None;
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FormCheckbox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormCheckbox {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InputValidationError {
    // message fields
    pub inputField: ::std::option::Option<i32>,
    pub errorMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InputValidationError {
    pub fn new() -> InputValidationError {
        ::std::default::Default::default()
    }

    // optional int32 inputField = 1;

    pub fn get_inputField(&self) -> i32 {
        self.inputField.unwrap_or(0)
    }

    // optional string errorMessage = 2;

    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for InputValidationError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inputField = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.inputField {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.inputField {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.errorMessage.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputValidationError {
        InputValidationError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "inputField",
                |m: &InputValidationError| { &m.inputField },
                |m: &mut InputValidationError| { &mut m.inputField },
                InputValidationError::get_inputField,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "errorMessage",
                |m: &InputValidationError| { &m.errorMessage },
                |m: &mut InputValidationError| { &mut m.errorMessage },
                InputValidationError::get_errorMessage,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InputValidationError>(
                "InputValidationError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputValidationError {
        static instance: ::protobuf::rt::Lazy<InputValidationError> = ::protobuf::rt::Lazy::INIT;
        instance.get(InputValidationError::new)
    }
}

impl ::protobuf::Clear for InputValidationError {
    fn clear(&mut self) {
        self.inputField = ::std::option::Option::None;
        self.errorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputValidationError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputValidationError {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct WebViewChallenge {
    // message fields
    pub startUrl: ::protobuf::SingularField<::std::string::String>,
    pub targetUrlRegexp: ::protobuf::SingularField<::std::string::String>,
    pub cancelButtonDisplayLabel: ::protobuf::SingularField<::std::string::String>,
    pub responseTargetUrlParam: ::protobuf::SingularField<::std::string::String>,
    pub cancelUrlRegexp: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl WebViewChallenge {
    pub fn new() -> WebViewChallenge {
        ::std::default::Default::default()
    }

    // optional string startUrl = 1;

    pub fn get_startUrl(&self) -> &str {
        match self.startUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string targetUrlRegexp = 2;

    pub fn get_targetUrlRegexp(&self) -> &str {
        match self.targetUrlRegexp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string cancelButtonDisplayLabel = 3;

    pub fn get_cancelButtonDisplayLabel(&self) -> &str {
        match self.cancelButtonDisplayLabel.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string responseTargetUrlParam = 4;

    pub fn get_responseTargetUrlParam(&self) -> &str {
        match self.responseTargetUrlParam.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string cancelUrlRegexp = 5;

    pub fn get_cancelUrlRegexp(&self) -> &str {
        match self.cancelUrlRegexp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string title = 6;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for WebViewChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.startUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetUrlRegexp)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cancelButtonDisplayLabel)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseTargetUrlParam)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cancelUrlRegexp)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.startUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.targetUrlRegexp.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cancelButtonDisplayLabel.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.responseTargetUrlParam.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.cancelUrlRegexp.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.startUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.targetUrlRegexp.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.cancelButtonDisplayLabel.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.responseTargetUrlParam.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.cancelUrlRegexp.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebViewChallenge {
        WebViewChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "startUrl",
                |m: &WebViewChallenge| { &m.startUrl },
                |m: &mut WebViewChallenge| { &mut m.startUrl },
                WebViewChallenge::get_startUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "targetUrlRegexp",
                |m: &WebViewChallenge| { &m.targetUrlRegexp },
                |m: &mut WebViewChallenge| { &mut m.targetUrlRegexp },
                WebViewChallenge::get_targetUrlRegexp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "cancelButtonDisplayLabel",
                |m: &WebViewChallenge| { &m.cancelButtonDisplayLabel },
                |m: &mut WebViewChallenge| { &mut m.cancelButtonDisplayLabel },
                WebViewChallenge::get_cancelButtonDisplayLabel,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "responseTargetUrlParam",
                |m: &WebViewChallenge| { &m.responseTargetUrlParam },
                |m: &mut WebViewChallenge| { &mut m.responseTargetUrlParam },
                WebViewChallenge::get_responseTargetUrlParam,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "cancelUrlRegexp",
                |m: &WebViewChallenge| { &m.cancelUrlRegexp },
                |m: &mut WebViewChallenge| { &mut m.cancelUrlRegexp },
                WebViewChallenge::get_cancelUrlRegexp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &WebViewChallenge| { &m.title },
                |m: &mut WebViewChallenge| { &mut m.title },
                WebViewChallenge::get_title,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<WebViewChallenge>(
                "WebViewChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WebViewChallenge {
        static instance: ::protobuf::rt::Lazy<WebViewChallenge> = ::protobuf::rt::Lazy::INIT;
        instance.get(WebViewChallenge::new)
    }
}

impl ::protobuf::Clear for WebViewChallenge {
    fn clear(&mut self) {
        self.startUrl.clear();
        self.targetUrlRegexp.clear();
        self.cancelButtonDisplayLabel.clear();
        self.responseTargetUrlParam.clear();
        self.cancelUrlRegexp.clear();
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebViewChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebViewChallenge {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AddCreditCardPromoOffer {
    // message fields
    pub headerText: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    pub introductoryTextHtml: ::protobuf::SingularField<::std::string::String>,
    pub offerTitle: ::protobuf::SingularField<::std::string::String>,
    pub noActionDescription: ::protobuf::SingularField<::std::string::String>,
    pub termsAndConditionsHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AddCreditCardPromoOffer {
    pub fn new() -> AddCreditCardPromoOffer {
        ::std::default::Default::default()
    }

    // optional string headerText = 1;

    pub fn get_headerText(&self) -> &str {
        match self.headerText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string descriptionHtml = 2;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string introductoryTextHtml = 4;

    pub fn get_introductoryTextHtml(&self) -> &str {
        match self.introductoryTextHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string offerTitle = 5;

    pub fn get_offerTitle(&self) -> &str {
        match self.offerTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string noActionDescription = 6;

    pub fn get_noActionDescription(&self) -> &str {
        match self.noActionDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string termsAndConditionsHtml = 7;

    pub fn get_termsAndConditionsHtml(&self) -> &str {
        match self.termsAndConditionsHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AddCreditCardPromoOffer {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headerText)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<Image, _>(wire_type, is, &mut self.image)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.introductoryTextHtml)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerTitle)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.noActionDescription)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsAndConditionsHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.headerText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.introductoryTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.offerTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.noActionDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.termsAndConditionsHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.headerText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.introductoryTextHtml.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.offerTitle.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.noActionDescription.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.termsAndConditionsHtml.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCreditCardPromoOffer {
        AddCreditCardPromoOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "headerText",
                |m: &AddCreditCardPromoOffer| { &m.headerText },
                |m: &mut AddCreditCardPromoOffer| { &mut m.headerText },
                AddCreditCardPromoOffer::get_headerText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &AddCreditCardPromoOffer| { &m.descriptionHtml },
                |m: &mut AddCreditCardPromoOffer| { &mut m.descriptionHtml },
                AddCreditCardPromoOffer::get_descriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>, _>(
                "image",
                |m: &AddCreditCardPromoOffer| { &m.image },
                |m: &mut AddCreditCardPromoOffer| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "introductoryTextHtml",
                |m: &AddCreditCardPromoOffer| { &m.introductoryTextHtml },
                |m: &mut AddCreditCardPromoOffer| { &mut m.introductoryTextHtml },
                AddCreditCardPromoOffer::get_introductoryTextHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "offerTitle",
                |m: &AddCreditCardPromoOffer| { &m.offerTitle },
                |m: &mut AddCreditCardPromoOffer| { &mut m.offerTitle },
                AddCreditCardPromoOffer::get_offerTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "noActionDescription",
                |m: &AddCreditCardPromoOffer| { &m.noActionDescription },
                |m: &mut AddCreditCardPromoOffer| { &mut m.noActionDescription },
                AddCreditCardPromoOffer::get_noActionDescription,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "termsAndConditionsHtml",
                |m: &AddCreditCardPromoOffer| { &m.termsAndConditionsHtml },
                |m: &mut AddCreditCardPromoOffer| { &mut m.termsAndConditionsHtml },
                AddCreditCardPromoOffer::get_termsAndConditionsHtml,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AddCreditCardPromoOffer>(
                "AddCreditCardPromoOffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddCreditCardPromoOffer {
        static instance: ::protobuf::rt::Lazy<AddCreditCardPromoOffer> = ::protobuf::rt::Lazy::INIT;
        instance.get(AddCreditCardPromoOffer::new)
    }
}

impl ::protobuf::Clear for AddCreditCardPromoOffer {
    fn clear(&mut self) {
        self.headerText.clear();
        self.descriptionHtml.clear();
        self.image.clear();
        self.introductoryTextHtml.clear();
        self.offerTitle.clear();
        self.noActionDescription.clear();
        self.termsAndConditionsHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCreditCardPromoOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCreditCardPromoOffer {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AvailablePromoOffer {
    // message fields
    pub addCreditCardOffer: ::protobuf::SingularPtrField<AddCreditCardPromoOffer>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AvailablePromoOffer {
    pub fn new() -> AvailablePromoOffer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AvailablePromoOffer {
    fn is_initialized(&self) -> bool {
        for v in &self.addCreditCardOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<AddCreditCardPromoOffer, _>(wire_type, is, &mut self.addCreditCardOffer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.addCreditCardOffer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.addCreditCardOffer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AvailablePromoOffer {
        AvailablePromoOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddCreditCardPromoOffer>, _>(
                "addCreditCardOffer",
                |m: &AvailablePromoOffer| { &m.addCreditCardOffer },
                |m: &mut AvailablePromoOffer| { &mut m.addCreditCardOffer },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AvailablePromoOffer>(
                "AvailablePromoOffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AvailablePromoOffer {
        static instance: ::protobuf::rt::Lazy<AvailablePromoOffer> = ::protobuf::rt::Lazy::INIT;
        instance.get(AvailablePromoOffer::new)
    }
}

impl ::protobuf::Clear for AvailablePromoOffer {
    fn clear(&mut self) {
        self.addCreditCardOffer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AvailablePromoOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvailablePromoOffer {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CheckPromoOfferResponse {
    // message fields
    pub availableOffer: ::protobuf::RepeatedField<AvailablePromoOffer>,
    pub redeemedOffer: ::protobuf::SingularPtrField<RedeemedPromoOffer>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CheckPromoOfferResponse {
    pub fn new() -> CheckPromoOfferResponse {
        ::std::default::Default::default()
    }

    // optional bool checkoutTokenRequired = 3;

    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for CheckPromoOfferResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.availableOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemedOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.availableOffer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<RedeemedPromoOffer, _>(wire_type, is, &mut self.redeemedOffer)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.availableOffer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.redeemedOffer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.availableOffer {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.redeemedOffer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckPromoOfferResponse {
        CheckPromoOfferResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AvailablePromoOffer>>(
                "availableOffer",
                |m: &CheckPromoOfferResponse| { &m.availableOffer },
                |m: &mut CheckPromoOfferResponse| { &mut m.availableOffer },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemedPromoOffer>, _>(
                "redeemedOffer",
                |m: &CheckPromoOfferResponse| { &m.redeemedOffer },
                |m: &mut CheckPromoOfferResponse| { &mut m.redeemedOffer },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "checkoutTokenRequired",
                |m: &CheckPromoOfferResponse| { &m.checkoutTokenRequired },
                |m: &mut CheckPromoOfferResponse| { &mut m.checkoutTokenRequired },
                CheckPromoOfferResponse::get_checkoutTokenRequired,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CheckPromoOfferResponse>(
                "CheckPromoOfferResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckPromoOfferResponse {
        static instance: ::protobuf::rt::Lazy<CheckPromoOfferResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CheckPromoOfferResponse::new)
    }
}

impl ::protobuf::Clear for CheckPromoOfferResponse {
    fn clear(&mut self) {
        self.availableOffer.clear();
        self.redeemedOffer.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckPromoOfferResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckPromoOfferResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RedeemedPromoOffer {
    // message fields
    pub headerText: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RedeemedPromoOffer {
    pub fn new() -> RedeemedPromoOffer {
        ::std::default::Default::default()
    }

    // optional string headerText = 1;

    pub fn get_headerText(&self) -> &str {
        match self.headerText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string descriptionHtml = 2;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RedeemedPromoOffer {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headerText)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<Image, _>(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.headerText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.headerText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemedPromoOffer {
        RedeemedPromoOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "headerText",
                |m: &RedeemedPromoOffer| { &m.headerText },
                |m: &mut RedeemedPromoOffer| { &mut m.headerText },
                RedeemedPromoOffer::get_headerText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &RedeemedPromoOffer| { &m.descriptionHtml },
                |m: &mut RedeemedPromoOffer| { &mut m.descriptionHtml },
                RedeemedPromoOffer::get_descriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>, _>(
                "image",
                |m: &RedeemedPromoOffer| { &m.image },
                |m: &mut RedeemedPromoOffer| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RedeemedPromoOffer>(
                "RedeemedPromoOffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemedPromoOffer {
        static instance: ::protobuf::rt::Lazy<RedeemedPromoOffer> = ::protobuf::rt::Lazy::INIT;
        instance.get(RedeemedPromoOffer::new)
    }
}

impl ::protobuf::Clear for RedeemedPromoOffer {
    fn clear(&mut self) {
        self.headerText.clear();
        self.descriptionHtml.clear();
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemedPromoOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemedPromoOffer {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ActiveExperiments {
    // message fields
    pub clientAlteringExperiment: ::protobuf::RepeatedField<::std::string::String>,
    pub otherExperiment: ::protobuf::RepeatedField<::std::string::String>,
    pub gwsExperiment: ::std::vec::Vec<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ActiveExperiments {
    pub fn new() -> ActiveExperiments {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ActiveExperiments {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.clientAlteringExperiment)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.otherExperiment)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.gwsExperiment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clientAlteringExperiment {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.otherExperiment {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.gwsExperiment {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clientAlteringExperiment {
            os.write_string(1, &v)?;
        };
        for v in &self.otherExperiment {
            os.write_string(2, &v)?;
        };
        for v in &self.gwsExperiment {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActiveExperiments {
        ActiveExperiments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientAlteringExperiment",
                |m: &ActiveExperiments| { &m.clientAlteringExperiment },
                |m: &mut ActiveExperiments| { &mut m.clientAlteringExperiment },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "otherExperiment",
                |m: &ActiveExperiments| { &m.otherExperiment },
                |m: &mut ActiveExperiments| { &mut m.otherExperiment },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "gwsExperiment",
                |m: &ActiveExperiments| { &m.gwsExperiment },
                |m: &mut ActiveExperiments| { &mut m.gwsExperiment },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ActiveExperiments>(
                "ActiveExperiments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActiveExperiments {
        static instance: ::protobuf::rt::Lazy<ActiveExperiments> = ::protobuf::rt::Lazy::INIT;
        instance.get(ActiveExperiments::new)
    }
}

impl ::protobuf::Clear for ActiveExperiments {
    fn clear(&mut self) {
        self.clientAlteringExperiment.clear();
        self.otherExperiment.clear();
        self.gwsExperiment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActiveExperiments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActiveExperiments {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AndroidClientInfo {
    // message fields
    pub androidId: ::std::option::Option<i64>,
    pub loggingId: ::protobuf::SingularField<::std::string::String>,
    pub sdkVersion: ::std::option::Option<i32>,
    pub model: ::protobuf::SingularField<::std::string::String>,
    pub product: ::protobuf::SingularField<::std::string::String>,
    pub osBuild: ::protobuf::SingularField<::std::string::String>,
    pub applicationBuild: ::protobuf::SingularField<::std::string::String>,
    pub hardware: ::protobuf::SingularField<::std::string::String>,
    pub device: ::protobuf::SingularField<::std::string::String>,
    pub mccMnc: ::protobuf::SingularField<::std::string::String>,
    pub locale: ::protobuf::SingularField<::std::string::String>,
    pub country: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AndroidClientInfo {
    pub fn new() -> AndroidClientInfo {
        ::std::default::Default::default()
    }

    // optional int64 androidId = 1;

    pub fn get_androidId(&self) -> i64 {
        self.androidId.unwrap_or(0)
    }

    // optional string loggingId = 2;

    pub fn get_loggingId(&self) -> &str {
        match self.loggingId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 sdkVersion = 3;

    pub fn get_sdkVersion(&self) -> i32 {
        self.sdkVersion.unwrap_or(0)
    }

    // optional string model = 4;

    pub fn get_model(&self) -> &str {
        match self.model.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string product = 5;

    pub fn get_product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string osBuild = 6;

    pub fn get_osBuild(&self) -> &str {
        match self.osBuild.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string applicationBuild = 7;

    pub fn get_applicationBuild(&self) -> &str {
        match self.applicationBuild.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string hardware = 8;

    pub fn get_hardware(&self) -> &str {
        match self.hardware.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string device = 9;

    pub fn get_device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string mccMnc = 10;

    pub fn get_mccMnc(&self) -> &str {
        match self.mccMnc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string locale = 11;

    pub fn get_locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string country = 12;

    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidClientInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loggingId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sdkVersion = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.model)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.product)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osBuild)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.applicationBuild)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hardware)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mccMnc)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.locale)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.loggingId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sdkVersion {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.model.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.osBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.applicationBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.hardware.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.mccMnc.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.loggingId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sdkVersion {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.model.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.product.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.osBuild.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.applicationBuild.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.hardware.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.device.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.mccMnc.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.locale.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.country.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidClientInfo {
        AndroidClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "androidId",
                |m: &AndroidClientInfo| { &m.androidId },
                |m: &mut AndroidClientInfo| { &mut m.androidId },
                AndroidClientInfo::get_androidId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "loggingId",
                |m: &AndroidClientInfo| { &m.loggingId },
                |m: &mut AndroidClientInfo| { &mut m.loggingId },
                AndroidClientInfo::get_loggingId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "sdkVersion",
                |m: &AndroidClientInfo| { &m.sdkVersion },
                |m: &mut AndroidClientInfo| { &mut m.sdkVersion },
                AndroidClientInfo::get_sdkVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "model",
                |m: &AndroidClientInfo| { &m.model },
                |m: &mut AndroidClientInfo| { &mut m.model },
                AndroidClientInfo::get_model,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "product",
                |m: &AndroidClientInfo| { &m.product },
                |m: &mut AndroidClientInfo| { &mut m.product },
                AndroidClientInfo::get_product,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "osBuild",
                |m: &AndroidClientInfo| { &m.osBuild },
                |m: &mut AndroidClientInfo| { &mut m.osBuild },
                AndroidClientInfo::get_osBuild,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "applicationBuild",
                |m: &AndroidClientInfo| { &m.applicationBuild },
                |m: &mut AndroidClientInfo| { &mut m.applicationBuild },
                AndroidClientInfo::get_applicationBuild,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "hardware",
                |m: &AndroidClientInfo| { &m.hardware },
                |m: &mut AndroidClientInfo| { &mut m.hardware },
                AndroidClientInfo::get_hardware,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "device",
                |m: &AndroidClientInfo| { &m.device },
                |m: &mut AndroidClientInfo| { &mut m.device },
                AndroidClientInfo::get_device,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "mccMnc",
                |m: &AndroidClientInfo| { &m.mccMnc },
                |m: &mut AndroidClientInfo| { &mut m.mccMnc },
                AndroidClientInfo::get_mccMnc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "locale",
                |m: &AndroidClientInfo| { &m.locale },
                |m: &mut AndroidClientInfo| { &mut m.locale },
                AndroidClientInfo::get_locale,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "country",
                |m: &AndroidClientInfo| { &m.country },
                |m: &mut AndroidClientInfo| { &mut m.country },
                AndroidClientInfo::get_country,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AndroidClientInfo>(
                "AndroidClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidClientInfo {
        static instance: ::protobuf::rt::Lazy<AndroidClientInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(AndroidClientInfo::new)
    }
}

impl ::protobuf::Clear for AndroidClientInfo {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.loggingId.clear();
        self.sdkVersion = ::std::option::Option::None;
        self.model.clear();
        self.product.clear();
        self.osBuild.clear();
        self.applicationBuild.clear();
        self.hardware.clear();
        self.device.clear();
        self.mccMnc.clear();
        self.locale.clear();
        self.country.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidClientInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientInfo {
    // message fields
    pub clientType: ::std::option::Option<i32>,
    pub androidClientInfo: ::protobuf::SingularPtrField<AndroidClientInfo>,
    pub desktopClientInfo: ::protobuf::SingularPtrField<DesktopClientInfo>,
    pub iosClientInfo: ::protobuf::SingularPtrField<IosClientInfo>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientInfo {
    pub fn new() -> ClientInfo {
        ::std::default::Default::default()
    }

    // optional int32 clientType = 1;

    pub fn get_clientType(&self) -> i32 {
        self.clientType.unwrap_or(0)
    }
}

impl ::protobuf::Message for ClientInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.androidClientInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desktopClientInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iosClientInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.clientType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<AndroidClientInfo, _>(wire_type, is, &mut self.androidClientInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<DesktopClientInfo, _>(wire_type, is, &mut self.desktopClientInfo)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<IosClientInfo, _>(wire_type, is, &mut self.iosClientInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clientType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.androidClientInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.desktopClientInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.iosClientInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clientType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.androidClientInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.desktopClientInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.iosClientInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientInfo {
        ClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "clientType",
                |m: &ClientInfo| { &m.clientType },
                |m: &mut ClientInfo| { &mut m.clientType },
                ClientInfo::get_clientType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidClientInfo>, _>(
                "androidClientInfo",
                |m: &ClientInfo| { &m.androidClientInfo },
                |m: &mut ClientInfo| { &mut m.androidClientInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DesktopClientInfo>, _>(
                "desktopClientInfo",
                |m: &ClientInfo| { &m.desktopClientInfo },
                |m: &mut ClientInfo| { &mut m.desktopClientInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IosClientInfo>, _>(
                "iosClientInfo",
                |m: &ClientInfo| { &m.iosClientInfo },
                |m: &mut ClientInfo| { &mut m.iosClientInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientInfo>(
                "ClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientInfo {
        static instance: ::protobuf::rt::Lazy<ClientInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientInfo::new)
    }
}

impl ::protobuf::Clear for ClientInfo {
    fn clear(&mut self) {
        self.clientType = ::std::option::Option::None;
        self.androidClientInfo.clear();
        self.desktopClientInfo.clear();
        self.iosClientInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DesktopClientInfo {
    // message fields
    pub clientId: ::protobuf::SingularField<::std::string::String>,
    pub loggingId: ::protobuf::SingularField<::std::string::String>,
    pub os: ::protobuf::SingularField<::std::string::String>,
    pub osMajorVersion: ::protobuf::SingularField<::std::string::String>,
    pub osFullVersion: ::protobuf::SingularField<::std::string::String>,
    pub applicationBuild: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DesktopClientInfo {
    pub fn new() -> DesktopClientInfo {
        ::std::default::Default::default()
    }

    // optional string clientId = 1;

    pub fn get_clientId(&self) -> &str {
        match self.clientId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string loggingId = 2;

    pub fn get_loggingId(&self) -> &str {
        match self.loggingId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string os = 3;

    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string osMajorVersion = 4;

    pub fn get_osMajorVersion(&self) -> &str {
        match self.osMajorVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string osFullVersion = 5;

    pub fn get_osFullVersion(&self) -> &str {
        match self.osFullVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string applicationBuild = 6;

    pub fn get_applicationBuild(&self) -> &str {
        match self.applicationBuild.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DesktopClientInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loggingId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osMajorVersion)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osFullVersion)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.applicationBuild)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clientId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.loggingId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.osMajorVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.osFullVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.applicationBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clientId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.loggingId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.osMajorVersion.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.osFullVersion.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.applicationBuild.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DesktopClientInfo {
        DesktopClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "clientId",
                |m: &DesktopClientInfo| { &m.clientId },
                |m: &mut DesktopClientInfo| { &mut m.clientId },
                DesktopClientInfo::get_clientId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "loggingId",
                |m: &DesktopClientInfo| { &m.loggingId },
                |m: &mut DesktopClientInfo| { &mut m.loggingId },
                DesktopClientInfo::get_loggingId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "os",
                |m: &DesktopClientInfo| { &m.os },
                |m: &mut DesktopClientInfo| { &mut m.os },
                DesktopClientInfo::get_os,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "osMajorVersion",
                |m: &DesktopClientInfo| { &m.osMajorVersion },
                |m: &mut DesktopClientInfo| { &mut m.osMajorVersion },
                DesktopClientInfo::get_osMajorVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "osFullVersion",
                |m: &DesktopClientInfo| { &m.osFullVersion },
                |m: &mut DesktopClientInfo| { &mut m.osFullVersion },
                DesktopClientInfo::get_osFullVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "applicationBuild",
                |m: &DesktopClientInfo| { &m.applicationBuild },
                |m: &mut DesktopClientInfo| { &mut m.applicationBuild },
                DesktopClientInfo::get_applicationBuild,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DesktopClientInfo>(
                "DesktopClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DesktopClientInfo {
        static instance: ::protobuf::rt::Lazy<DesktopClientInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(DesktopClientInfo::new)
    }
}

impl ::protobuf::Clear for DesktopClientInfo {
    fn clear(&mut self) {
        self.clientId.clear();
        self.loggingId.clear();
        self.os.clear();
        self.osMajorVersion.clear();
        self.osFullVersion.clear();
        self.applicationBuild.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DesktopClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DesktopClientInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExperimentIdList {
    // message fields
    pub id: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExperimentIdList {
    pub fn new() -> ExperimentIdList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ExperimentIdList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.id {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.id {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExperimentIdList {
        ExperimentIdList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ExperimentIdList| { &m.id },
                |m: &mut ExperimentIdList| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExperimentIdList>(
                "ExperimentIdList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExperimentIdList {
        static instance: ::protobuf::rt::Lazy<ExperimentIdList> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExperimentIdList::new)
    }
}

impl ::protobuf::Clear for ExperimentIdList {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExperimentIdList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExperimentIdList {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct IosClientInfo {
    // message fields
    pub clientId: ::protobuf::SingularField<::std::string::String>,
    pub loggingId: ::protobuf::SingularField<::std::string::String>,
    pub osMajorVersion: ::protobuf::SingularField<::std::string::String>,
    pub osFullVersion: ::protobuf::SingularField<::std::string::String>,
    pub applicationBuild: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl IosClientInfo {
    pub fn new() -> IosClientInfo {
        ::std::default::Default::default()
    }

    // optional string clientId = 1;

    pub fn get_clientId(&self) -> &str {
        match self.clientId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string loggingId = 2;

    pub fn get_loggingId(&self) -> &str {
        match self.loggingId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string osMajorVersion = 3;

    pub fn get_osMajorVersion(&self) -> &str {
        match self.osMajorVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string osFullVersion = 4;

    pub fn get_osFullVersion(&self) -> &str {
        match self.osFullVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string applicationBuild = 5;

    pub fn get_applicationBuild(&self) -> &str {
        match self.applicationBuild.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for IosClientInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loggingId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osMajorVersion)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osFullVersion)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.applicationBuild)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clientId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.loggingId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.osMajorVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.osFullVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.applicationBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clientId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.loggingId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.osMajorVersion.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.osFullVersion.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.applicationBuild.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IosClientInfo {
        IosClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "clientId",
                |m: &IosClientInfo| { &m.clientId },
                |m: &mut IosClientInfo| { &mut m.clientId },
                IosClientInfo::get_clientId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "loggingId",
                |m: &IosClientInfo| { &m.loggingId },
                |m: &mut IosClientInfo| { &mut m.loggingId },
                IosClientInfo::get_loggingId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "osMajorVersion",
                |m: &IosClientInfo| { &m.osMajorVersion },
                |m: &mut IosClientInfo| { &mut m.osMajorVersion },
                IosClientInfo::get_osMajorVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "osFullVersion",
                |m: &IosClientInfo| { &m.osFullVersion },
                |m: &mut IosClientInfo| { &mut m.osFullVersion },
                IosClientInfo::get_osFullVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "applicationBuild",
                |m: &IosClientInfo| { &m.applicationBuild },
                |m: &mut IosClientInfo| { &mut m.applicationBuild },
                IosClientInfo::get_applicationBuild,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<IosClientInfo>(
                "IosClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IosClientInfo {
        static instance: ::protobuf::rt::Lazy<IosClientInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(IosClientInfo::new)
    }
}

impl ::protobuf::Clear for IosClientInfo {
    fn clear(&mut self) {
        self.clientId.clear();
        self.loggingId.clear();
        self.osMajorVersion.clear();
        self.osFullVersion.clear();
        self.applicationBuild.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IosClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IosClientInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LogEvent {
    // message fields
    pub eventTimeMs: ::std::option::Option<i64>,
    pub tag: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::RepeatedField<LogEventKeyValues>,
    pub store: ::protobuf::SingularPtrField<PlayStoreLogEvent>,
    pub sourceExtension: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub exp: ::protobuf::SingularPtrField<ActiveExperiments>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LogEvent {
    pub fn new() -> LogEvent {
        ::std::default::Default::default()
    }

    // optional int64 eventTimeMs = 1;

    pub fn get_eventTimeMs(&self) -> i64 {
        self.eventTimeMs.unwrap_or(0)
    }

    // optional string tag = 2;

    pub fn get_tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes sourceExtension = 6;

    pub fn get_sourceExtension(&self) -> &[u8] {
        match self.sourceExtension.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for LogEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.store {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.eventTimeMs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreLogEvent, _>(wire_type, is, &mut self.store)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sourceExtension)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<ActiveExperiments, _>(wire_type, is, &mut self.exp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventTimeMs {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.store.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sourceExtension.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.exp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventTimeMs {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.tag.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.value {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.store.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.sourceExtension.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.exp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogEvent {
        LogEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "eventTimeMs",
                |m: &LogEvent| { &m.eventTimeMs },
                |m: &mut LogEvent| { &mut m.eventTimeMs },
                LogEvent::get_eventTimeMs,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tag",
                |m: &LogEvent| { &m.tag },
                |m: &mut LogEvent| { &mut m.tag },
                LogEvent::get_tag,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogEventKeyValues>>(
                "value",
                |m: &LogEvent| { &m.value },
                |m: &mut LogEvent| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreLogEvent>, _>(
                "store",
                |m: &LogEvent| { &m.store },
                |m: &mut LogEvent| { &mut m.store },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "sourceExtension",
                |m: &LogEvent| { &m.sourceExtension },
                |m: &mut LogEvent| { &mut m.sourceExtension },
                LogEvent::get_sourceExtension,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActiveExperiments>, _>(
                "exp",
                |m: &LogEvent| { &m.exp },
                |m: &mut LogEvent| { &mut m.exp },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LogEvent>(
                "LogEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogEvent {
        static instance: ::protobuf::rt::Lazy<LogEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(LogEvent::new)
    }
}

impl ::protobuf::Clear for LogEvent {
    fn clear(&mut self) {
        self.eventTimeMs = ::std::option::Option::None;
        self.tag.clear();
        self.value.clear();
        self.store.clear();
        self.sourceExtension.clear();
        self.exp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEvent {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LogEventKeyValues {
    // message fields
    pub key: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LogEventKeyValues {
    pub fn new() -> LogEventKeyValues {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string value = 2;

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LogEventKeyValues {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogEventKeyValues {
        LogEventKeyValues::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "key",
                |m: &LogEventKeyValues| { &m.key },
                |m: &mut LogEventKeyValues| { &mut m.key },
                LogEventKeyValues::get_key,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "value",
                |m: &LogEventKeyValues| { &m.value },
                |m: &mut LogEventKeyValues| { &mut m.value },
                LogEventKeyValues::get_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LogEventKeyValues>(
                "LogEventKeyValues",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogEventKeyValues {
        static instance: ::protobuf::rt::Lazy<LogEventKeyValues> = ::protobuf::rt::Lazy::INIT;
        instance.get(LogEventKeyValues::new)
    }
}

impl ::protobuf::Clear for LogEventKeyValues {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogEventKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEventKeyValues {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LogRequest {
    // message fields
    pub clientInfo: ::protobuf::SingularPtrField<ClientInfo>,
    pub logSource: ::std::option::Option<i32>,
    pub logEvent: ::protobuf::RepeatedField<LogEvent>,
    pub requestTimeMs: ::std::option::Option<i64>,
    pub serializedLogEvents: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LogRequest {
    pub fn new() -> LogRequest {
        ::std::default::Default::default()
    }

    // optional int32 logSource = 2;

    pub fn get_logSource(&self) -> i32 {
        self.logSource.unwrap_or(0)
    }

    // optional int64 requestTimeMs = 4;

    pub fn get_requestTimeMs(&self) -> i64 {
        self.requestTimeMs.unwrap_or(0)
    }

    // optional bytes serializedLogEvents = 5;

    pub fn get_serializedLogEvents(&self) -> &[u8] {
        match self.serializedLogEvents.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for LogRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.clientInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logEvent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<ClientInfo, _>(wire_type, is, &mut self.clientInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.logSource = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.logEvent)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.requestTimeMs = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serializedLogEvents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clientInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.logSource {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.logEvent {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.requestTimeMs {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serializedLogEvents.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clientInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.logSource {
            os.write_int32(2, v)?;
        }
        for v in &self.logEvent {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.requestTimeMs {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.serializedLogEvents.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogRequest {
        LogRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientInfo>, _>(
                "clientInfo",
                |m: &LogRequest| { &m.clientInfo },
                |m: &mut LogRequest| { &mut m.clientInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "logSource",
                |m: &LogRequest| { &m.logSource },
                |m: &mut LogRequest| { &mut m.logSource },
                LogRequest::get_logSource,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogEvent>>(
                "logEvent",
                |m: &LogRequest| { &m.logEvent },
                |m: &mut LogRequest| { &mut m.logEvent },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "requestTimeMs",
                |m: &LogRequest| { &m.requestTimeMs },
                |m: &mut LogRequest| { &mut m.requestTimeMs },
                LogRequest::get_requestTimeMs,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serializedLogEvents",
                |m: &LogRequest| { &m.serializedLogEvents },
                |m: &mut LogRequest| { &mut m.serializedLogEvents },
                LogRequest::get_serializedLogEvents,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LogRequest>(
                "LogRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogRequest {
        static instance: ::protobuf::rt::Lazy<LogRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(LogRequest::new)
    }
}

impl ::protobuf::Clear for LogRequest {
    fn clear(&mut self) {
        self.clientInfo.clear();
        self.logSource = ::std::option::Option::None;
        self.logEvent.clear();
        self.requestTimeMs = ::std::option::Option::None;
        self.serializedLogEvents.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LogResponse {
    // message fields
    pub nextRequestWaitMillis: ::std::option::Option<i64>,
    pub experiments: ::protobuf::SingularPtrField<ExperimentIdList>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LogResponse {
    pub fn new() -> LogResponse {
        ::std::default::Default::default()
    }

    // optional int64 nextRequestWaitMillis = 1;

    pub fn get_nextRequestWaitMillis(&self) -> i64 {
        self.nextRequestWaitMillis.unwrap_or(0)
    }
}

impl ::protobuf::Message for LogResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.experiments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nextRequestWaitMillis = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ExperimentIdList, _>(wire_type, is, &mut self.experiments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.nextRequestWaitMillis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.experiments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nextRequestWaitMillis {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.experiments.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogResponse {
        LogResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "nextRequestWaitMillis",
                |m: &LogResponse| { &m.nextRequestWaitMillis },
                |m: &mut LogResponse| { &mut m.nextRequestWaitMillis },
                LogResponse::get_nextRequestWaitMillis,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExperimentIdList>, _>(
                "experiments",
                |m: &LogResponse| { &m.experiments },
                |m: &mut LogResponse| { &mut m.experiments },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LogResponse>(
                "LogResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogResponse {
        static instance: ::protobuf::rt::Lazy<LogResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(LogResponse::new)
    }
}

impl ::protobuf::Clear for LogResponse {
    fn clear(&mut self) {
        self.nextRequestWaitMillis = ::std::option::Option::None;
        self.experiments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Docid {
    // message fields
    pub backendDocid: ::protobuf::SingularField<::std::string::String>,
    pub field_type: ::std::option::Option<i32>,
    pub backend: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Docid {
    pub fn new() -> Docid {
        ::std::default::Default::default()
    }

    // optional string backendDocid = 1;

    pub fn get_backendDocid(&self) -> &str {
        match self.backendDocid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 type = 2;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional int32 backend = 3;

    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }
}

impl ::protobuf::Message for Docid {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendDocid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.backendDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.backendDocid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.backend {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Docid {
        Docid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "backendDocid",
                |m: &Docid| { &m.backendDocid },
                |m: &mut Docid| { &mut m.backendDocid },
                Docid::get_backendDocid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &Docid| { &m.field_type },
                |m: &mut Docid| { &mut m.field_type },
                Docid::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "backend",
                |m: &Docid| { &m.backend },
                |m: &mut Docid| { &mut m.backend },
                Docid::get_backend,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Docid>(
                "Docid",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Docid {
        static instance: ::protobuf::rt::Lazy<Docid> = ::protobuf::rt::Lazy::INIT;
        instance.get(Docid::new)
    }
}

impl ::protobuf::Clear for Docid {
    fn clear(&mut self) {
        self.backendDocid.clear();
        self.field_type = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Docid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Docid {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Install {
    // message fields
    pub androidId: ::std::option::Option<u64>,
    pub version: ::std::option::Option<i32>,
    pub bundled: ::std::option::Option<bool>,
    pub pending: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Install {
    pub fn new() -> Install {
        ::std::default::Default::default()
    }

    // optional fixed64 androidId = 1;

    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }

    // optional int32 version = 2;

    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional bool bundled = 3;

    pub fn get_bundled(&self) -> bool {
        self.bundled.unwrap_or(false)
    }

    // optional bool pending = 4;

    pub fn get_pending(&self) -> bool {
        self.pending.unwrap_or(false)
    }
}

impl ::protobuf::Message for Install {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bundled = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pending = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bundled {
            my_size += 2;
        }
        if let Some(v) = self.pending {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.bundled {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.pending {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Install {
        Install::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeFixed64, _>(
                "androidId",
                |m: &Install| { &m.androidId },
                |m: &mut Install| { &mut m.androidId },
                Install::get_androidId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "version",
                |m: &Install| { &m.version },
                |m: &mut Install| { &mut m.version },
                Install::get_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "bundled",
                |m: &Install| { &m.bundled },
                |m: &mut Install| { &mut m.bundled },
                Install::get_bundled,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "pending",
                |m: &Install| { &m.pending },
                |m: &mut Install| { &mut m.pending },
                Install::get_pending,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Install>(
                "Install",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Install {
        static instance: ::protobuf::rt::Lazy<Install> = ::protobuf::rt::Lazy::INIT;
        instance.get(Install::new)
    }
}

impl ::protobuf::Clear for Install {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.bundled = ::std::option::Option::None;
        self.pending = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Install {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Install {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GroupLicenseKey {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GroupLicenseKey {
    pub fn new() -> GroupLicenseKey {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GroupLicenseKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupLicenseKey {
        GroupLicenseKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<GroupLicenseKey>(
                "GroupLicenseKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupLicenseKey {
        static instance: ::protobuf::rt::Lazy<GroupLicenseKey> = ::protobuf::rt::Lazy::INIT;
        instance.get(GroupLicenseKey::new)
    }
}

impl ::protobuf::Clear for GroupLicenseKey {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupLicenseKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupLicenseKey {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LicenseTerms {
    // message fields
    pub groupLicenseKey: ::protobuf::SingularPtrField<GroupLicenseKey>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LicenseTerms {
    pub fn new() -> LicenseTerms {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LicenseTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.groupLicenseKey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<GroupLicenseKey, _>(wire_type, is, &mut self.groupLicenseKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupLicenseKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupLicenseKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LicenseTerms {
        LicenseTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupLicenseKey>, _>(
                "groupLicenseKey",
                |m: &LicenseTerms| { &m.groupLicenseKey },
                |m: &mut LicenseTerms| { &mut m.groupLicenseKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LicenseTerms>(
                "LicenseTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LicenseTerms {
        static instance: ::protobuf::rt::Lazy<LicenseTerms> = ::protobuf::rt::Lazy::INIT;
        instance.get(LicenseTerms::new)
    }
}

impl ::protobuf::Clear for LicenseTerms {
    fn clear(&mut self) {
        self.groupLicenseKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LicenseTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LicenseTerms {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Offer {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub formattedAmount: ::protobuf::SingularField<::std::string::String>,
    pub convertedPrice: ::protobuf::RepeatedField<Offer>,
    pub checkoutFlowRequired: ::std::option::Option<bool>,
    pub fullPriceMicros: ::std::option::Option<i64>,
    pub formattedFullAmount: ::protobuf::SingularField<::std::string::String>,
    pub offerType: ::std::option::Option<i32>,
    pub rentalTerms: ::protobuf::SingularPtrField<RentalTerms>,
    pub onSaleDate: ::std::option::Option<i64>,
    pub promotionLabel: ::protobuf::RepeatedField<::std::string::String>,
    pub subscriptionTerms: ::protobuf::SingularPtrField<SubscriptionTerms>,
    pub formattedName: ::protobuf::SingularField<::std::string::String>,
    pub formattedDescription: ::protobuf::SingularField<::std::string::String>,
    pub preorder: ::std::option::Option<bool>,
    pub onSaleDateDisplayTimeZoneOffsetMsec: ::std::option::Option<i32>,
    pub licensedOfferType: ::std::option::Option<i32>,
    pub subscriptionContentTerms: ::protobuf::SingularPtrField<SubscriptionContentTerms>,
    pub offerId: ::protobuf::SingularField<::std::string::String>,
    pub preorderFulfillmentDisplayDate: ::std::option::Option<i64>,
    pub licenseTerms: ::protobuf::SingularPtrField<LicenseTerms>,
    pub temporarilyFree: ::std::option::Option<bool>,
    pub voucherTerms: ::protobuf::SingularPtrField<VoucherTerms>,
    pub offerPayment: ::protobuf::RepeatedField<OfferPayment>,
    pub repeatLastPayment: ::std::option::Option<bool>,
    pub buyButtonLabel: ::protobuf::SingularField<::std::string::String>,
    pub instantPurchaseEnabled: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Offer {
    pub fn new() -> Offer {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;

    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional string currencyCode = 2;

    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string formattedAmount = 3;

    pub fn get_formattedAmount(&self) -> &str {
        match self.formattedAmount.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool checkoutFlowRequired = 5;

    pub fn get_checkoutFlowRequired(&self) -> bool {
        self.checkoutFlowRequired.unwrap_or(false)
    }

    // optional int64 fullPriceMicros = 6;

    pub fn get_fullPriceMicros(&self) -> i64 {
        self.fullPriceMicros.unwrap_or(0)
    }

    // optional string formattedFullAmount = 7;

    pub fn get_formattedFullAmount(&self) -> &str {
        match self.formattedFullAmount.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 offerType = 8;

    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional int64 onSaleDate = 10;

    pub fn get_onSaleDate(&self) -> i64 {
        self.onSaleDate.unwrap_or(0)
    }

    // optional string formattedName = 13;

    pub fn get_formattedName(&self) -> &str {
        match self.formattedName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string formattedDescription = 14;

    pub fn get_formattedDescription(&self) -> &str {
        match self.formattedDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool preorder = 15;

    pub fn get_preorder(&self) -> bool {
        self.preorder.unwrap_or(false)
    }

    // optional int32 onSaleDateDisplayTimeZoneOffsetMsec = 16;

    pub fn get_onSaleDateDisplayTimeZoneOffsetMsec(&self) -> i32 {
        self.onSaleDateDisplayTimeZoneOffsetMsec.unwrap_or(0)
    }

    // optional int32 licensedOfferType = 17;

    pub fn get_licensedOfferType(&self) -> i32 {
        self.licensedOfferType.unwrap_or(0)
    }

    // optional string offerId = 19;

    pub fn get_offerId(&self) -> &str {
        match self.offerId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 preorderFulfillmentDisplayDate = 20;

    pub fn get_preorderFulfillmentDisplayDate(&self) -> i64 {
        self.preorderFulfillmentDisplayDate.unwrap_or(0)
    }

    // optional bool temporarilyFree = 22;

    pub fn get_temporarilyFree(&self) -> bool {
        self.temporarilyFree.unwrap_or(false)
    }

    // optional bool repeatLastPayment = 25;

    pub fn get_repeatLastPayment(&self) -> bool {
        self.repeatLastPayment.unwrap_or(false)
    }

    // optional string buyButtonLabel = 26;

    pub fn get_buyButtonLabel(&self) -> &str {
        match self.buyButtonLabel.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool instantPurchaseEnabled = 27;

    pub fn get_instantPurchaseEnabled(&self) -> bool {
        self.instantPurchaseEnabled.unwrap_or(false)
    }
}

impl ::protobuf::Message for Offer {
    fn is_initialized(&self) -> bool {
        for v in &self.convertedPrice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rentalTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionContentTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.licenseTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voucherTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offerPayment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedAmount)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.convertedPrice)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutFlowRequired = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fullPriceMicros = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedFullAmount)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<RentalTerms, _>(wire_type, is, &mut self.rentalTerms)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.onSaleDate = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotionLabel)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<SubscriptionTerms, _>(wire_type, is, &mut self.subscriptionTerms)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedDescription)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.preorder = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.onSaleDateDisplayTimeZoneOffsetMsec = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.licensedOfferType = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into::<SubscriptionContentTerms, _>(wire_type, is, &mut self.subscriptionContentTerms)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerId)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.preorderFulfillmentDisplayDate = ::std::option::Option::Some(tmp);
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into::<LicenseTerms, _>(wire_type, is, &mut self.licenseTerms)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.temporarilyFree = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into::<VoucherTerms, _>(wire_type, is, &mut self.voucherTerms)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.offerPayment)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.repeatLastPayment = ::std::option::Option::Some(tmp);
                },
                26 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.buyButtonLabel)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.instantPurchaseEnabled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.formattedAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.convertedPrice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.checkoutFlowRequired {
            my_size += 2;
        }
        if let Some(v) = self.fullPriceMicros {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.formattedFullAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rentalTerms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.onSaleDate {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.promotionLabel {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(v) = self.subscriptionTerms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.formattedName.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.formattedDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.preorder {
            my_size += 2;
        }
        if let Some(v) = self.onSaleDateDisplayTimeZoneOffsetMsec {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.licensedOfferType {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subscriptionContentTerms.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offerId.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.preorderFulfillmentDisplayDate {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.licenseTerms.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.temporarilyFree {
            my_size += 3;
        }
        if let Some(v) = self.voucherTerms.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.offerPayment {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.repeatLastPayment {
            my_size += 3;
        }
        if let Some(v) = self.buyButtonLabel.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.instantPurchaseEnabled {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.currencyCode.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.formattedAmount.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.convertedPrice {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.checkoutFlowRequired {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.fullPriceMicros {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.formattedFullAmount.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.rentalTerms.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.onSaleDate {
            os.write_int64(10, v)?;
        }
        for v in &self.promotionLabel {
            os.write_string(11, &v)?;
        };
        if let Some(v) = self.subscriptionTerms.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.formattedName.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.formattedDescription.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.preorder {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.onSaleDateDisplayTimeZoneOffsetMsec {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.licensedOfferType {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.subscriptionContentTerms.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.offerId.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.preorderFulfillmentDisplayDate {
            os.write_int64(20, v)?;
        }
        if let Some(v) = self.licenseTerms.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.temporarilyFree {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.voucherTerms.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        for v in &self.offerPayment {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        if let Some(v) = self.repeatLastPayment {
            os.write_bool(25, v)?;
        }
        if let Some(v) = self.buyButtonLabel.as_ref() {
            os.write_string(26, v)?;
        }
        if let Some(v) = self.instantPurchaseEnabled {
            os.write_bool(27, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Offer {
        Offer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "micros",
                |m: &Offer| { &m.micros },
                |m: &mut Offer| { &mut m.micros },
                Offer::get_micros,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "currencyCode",
                |m: &Offer| { &m.currencyCode },
                |m: &mut Offer| { &mut m.currencyCode },
                Offer::get_currencyCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "formattedAmount",
                |m: &Offer| { &m.formattedAmount },
                |m: &mut Offer| { &mut m.formattedAmount },
                Offer::get_formattedAmount,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "convertedPrice",
                |m: &Offer| { &m.convertedPrice },
                |m: &mut Offer| { &mut m.convertedPrice },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "checkoutFlowRequired",
                |m: &Offer| { &m.checkoutFlowRequired },
                |m: &mut Offer| { &mut m.checkoutFlowRequired },
                Offer::get_checkoutFlowRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "fullPriceMicros",
                |m: &Offer| { &m.fullPriceMicros },
                |m: &mut Offer| { &mut m.fullPriceMicros },
                Offer::get_fullPriceMicros,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "formattedFullAmount",
                |m: &Offer| { &m.formattedFullAmount },
                |m: &mut Offer| { &mut m.formattedFullAmount },
                Offer::get_formattedFullAmount,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "offerType",
                |m: &Offer| { &m.offerType },
                |m: &mut Offer| { &mut m.offerType },
                Offer::get_offerType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RentalTerms>, _>(
                "rentalTerms",
                |m: &Offer| { &m.rentalTerms },
                |m: &mut Offer| { &mut m.rentalTerms },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "onSaleDate",
                |m: &Offer| { &m.onSaleDate },
                |m: &mut Offer| { &mut m.onSaleDate },
                Offer::get_onSaleDate,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotionLabel",
                |m: &Offer| { &m.promotionLabel },
                |m: &mut Offer| { &mut m.promotionLabel },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubscriptionTerms>, _>(
                "subscriptionTerms",
                |m: &Offer| { &m.subscriptionTerms },
                |m: &mut Offer| { &mut m.subscriptionTerms },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "formattedName",
                |m: &Offer| { &m.formattedName },
                |m: &mut Offer| { &mut m.formattedName },
                Offer::get_formattedName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "formattedDescription",
                |m: &Offer| { &m.formattedDescription },
                |m: &mut Offer| { &mut m.formattedDescription },
                Offer::get_formattedDescription,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "preorder",
                |m: &Offer| { &m.preorder },
                |m: &mut Offer| { &mut m.preorder },
                Offer::get_preorder,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "onSaleDateDisplayTimeZoneOffsetMsec",
                |m: &Offer| { &m.onSaleDateDisplayTimeZoneOffsetMsec },
                |m: &mut Offer| { &mut m.onSaleDateDisplayTimeZoneOffsetMsec },
                Offer::get_onSaleDateDisplayTimeZoneOffsetMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "licensedOfferType",
                |m: &Offer| { &m.licensedOfferType },
                |m: &mut Offer| { &mut m.licensedOfferType },
                Offer::get_licensedOfferType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubscriptionContentTerms>, _>(
                "subscriptionContentTerms",
                |m: &Offer| { &m.subscriptionContentTerms },
                |m: &mut Offer| { &mut m.subscriptionContentTerms },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "offerId",
                |m: &Offer| { &m.offerId },
                |m: &mut Offer| { &mut m.offerId },
                Offer::get_offerId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "preorderFulfillmentDisplayDate",
                |m: &Offer| { &m.preorderFulfillmentDisplayDate },
                |m: &mut Offer| { &mut m.preorderFulfillmentDisplayDate },
                Offer::get_preorderFulfillmentDisplayDate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LicenseTerms>, _>(
                "licenseTerms",
                |m: &Offer| { &m.licenseTerms },
                |m: &mut Offer| { &mut m.licenseTerms },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "temporarilyFree",
                |m: &Offer| { &m.temporarilyFree },
                |m: &mut Offer| { &mut m.temporarilyFree },
                Offer::get_temporarilyFree,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoucherTerms>, _>(
                "voucherTerms",
                |m: &Offer| { &m.voucherTerms },
                |m: &mut Offer| { &mut m.voucherTerms },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OfferPayment>>(
                "offerPayment",
                |m: &Offer| { &m.offerPayment },
                |m: &mut Offer| { &mut m.offerPayment },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "repeatLastPayment",
                |m: &Offer| { &m.repeatLastPayment },
                |m: &mut Offer| { &mut m.repeatLastPayment },
                Offer::get_repeatLastPayment,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "buyButtonLabel",
                |m: &Offer| { &m.buyButtonLabel },
                |m: &mut Offer| { &mut m.buyButtonLabel },
                Offer::get_buyButtonLabel,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "instantPurchaseEnabled",
                |m: &Offer| { &m.instantPurchaseEnabled },
                |m: &mut Offer| { &mut m.instantPurchaseEnabled },
                Offer::get_instantPurchaseEnabled,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Offer>(
                "Offer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Offer {
        static instance: ::protobuf::rt::Lazy<Offer> = ::protobuf::rt::Lazy::INIT;
        instance.get(Offer::new)
    }
}

impl ::protobuf::Clear for Offer {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.currencyCode.clear();
        self.formattedAmount.clear();
        self.convertedPrice.clear();
        self.checkoutFlowRequired = ::std::option::Option::None;
        self.fullPriceMicros = ::std::option::Option::None;
        self.formattedFullAmount.clear();
        self.offerType = ::std::option::Option::None;
        self.rentalTerms.clear();
        self.onSaleDate = ::std::option::Option::None;
        self.promotionLabel.clear();
        self.subscriptionTerms.clear();
        self.formattedName.clear();
        self.formattedDescription.clear();
        self.preorder = ::std::option::Option::None;
        self.onSaleDateDisplayTimeZoneOffsetMsec = ::std::option::Option::None;
        self.licensedOfferType = ::std::option::Option::None;
        self.subscriptionContentTerms.clear();
        self.offerId.clear();
        self.preorderFulfillmentDisplayDate = ::std::option::Option::None;
        self.licenseTerms.clear();
        self.temporarilyFree = ::std::option::Option::None;
        self.voucherTerms.clear();
        self.offerPayment.clear();
        self.repeatLastPayment = ::std::option::Option::None;
        self.buyButtonLabel.clear();
        self.instantPurchaseEnabled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct MonthAndDay {
    // message fields
    pub month: ::std::option::Option<u32>,
    pub day: ::std::option::Option<u32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl MonthAndDay {
    pub fn new() -> MonthAndDay {
        ::std::default::Default::default()
    }

    // optional uint32 month = 1;

    pub fn get_month(&self) -> u32 {
        self.month.unwrap_or(0)
    }

    // optional uint32 day = 2;

    pub fn get_day(&self) -> u32 {
        self.day.unwrap_or(0)
    }
}

impl ::protobuf::Message for MonthAndDay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.month = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.day = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.month {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.day {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.month {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.day {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonthAndDay {
        MonthAndDay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint32, _>(
                "month",
                |m: &MonthAndDay| { &m.month },
                |m: &mut MonthAndDay| { &mut m.month },
                MonthAndDay::get_month,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint32, _>(
                "day",
                |m: &MonthAndDay| { &m.day },
                |m: &mut MonthAndDay| { &mut m.day },
                MonthAndDay::get_day,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<MonthAndDay>(
                "MonthAndDay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonthAndDay {
        static instance: ::protobuf::rt::Lazy<MonthAndDay> = ::protobuf::rt::Lazy::INIT;
        instance.get(MonthAndDay::new)
    }
}

impl ::protobuf::Clear for MonthAndDay {
    fn clear(&mut self) {
        self.month = ::std::option::Option::None;
        self.day = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonthAndDay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonthAndDay {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct OfferPaymentPeriod {
    // message fields
    pub duration: ::protobuf::SingularPtrField<TimePeriod>,
    pub start: ::protobuf::SingularPtrField<MonthAndDay>,
    pub end: ::protobuf::SingularPtrField<MonthAndDay>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl OfferPaymentPeriod {
    pub fn new() -> OfferPaymentPeriod {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for OfferPaymentPeriod {
    fn is_initialized(&self) -> bool {
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<TimePeriod, _>(wire_type, is, &mut self.duration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<MonthAndDay, _>(wire_type, is, &mut self.start)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<MonthAndDay, _>(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.duration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferPaymentPeriod {
        OfferPaymentPeriod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>, _>(
                "duration",
                |m: &OfferPaymentPeriod| { &m.duration },
                |m: &mut OfferPaymentPeriod| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonthAndDay>, _>(
                "start",
                |m: &OfferPaymentPeriod| { &m.start },
                |m: &mut OfferPaymentPeriod| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonthAndDay>, _>(
                "end",
                |m: &OfferPaymentPeriod| { &m.end },
                |m: &mut OfferPaymentPeriod| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<OfferPaymentPeriod>(
                "OfferPaymentPeriod",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OfferPaymentPeriod {
        static instance: ::protobuf::rt::Lazy<OfferPaymentPeriod> = ::protobuf::rt::Lazy::INIT;
        instance.get(OfferPaymentPeriod::new)
    }
}

impl ::protobuf::Clear for OfferPaymentPeriod {
    fn clear(&mut self) {
        self.duration.clear();
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferPaymentPeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferPaymentPeriod {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct OfferPaymentOverride {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub start: ::protobuf::SingularPtrField<MonthAndDay>,
    pub end: ::protobuf::SingularPtrField<MonthAndDay>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl OfferPaymentOverride {
    pub fn new() -> OfferPaymentOverride {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;

    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }
}

impl ::protobuf::Message for OfferPaymentOverride {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<MonthAndDay, _>(wire_type, is, &mut self.start)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<MonthAndDay, _>(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferPaymentOverride {
        OfferPaymentOverride::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "micros",
                |m: &OfferPaymentOverride| { &m.micros },
                |m: &mut OfferPaymentOverride| { &mut m.micros },
                OfferPaymentOverride::get_micros,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonthAndDay>, _>(
                "start",
                |m: &OfferPaymentOverride| { &m.start },
                |m: &mut OfferPaymentOverride| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonthAndDay>, _>(
                "end",
                |m: &OfferPaymentOverride| { &m.end },
                |m: &mut OfferPaymentOverride| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<OfferPaymentOverride>(
                "OfferPaymentOverride",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OfferPaymentOverride {
        static instance: ::protobuf::rt::Lazy<OfferPaymentOverride> = ::protobuf::rt::Lazy::INIT;
        instance.get(OfferPaymentOverride::new)
    }
}

impl ::protobuf::Clear for OfferPaymentOverride {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferPaymentOverride {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferPaymentOverride {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct OfferPayment {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub offerPaymentPeriod: ::protobuf::SingularPtrField<OfferPaymentPeriod>,
    pub offerPaymentOverride: ::protobuf::RepeatedField<OfferPaymentOverride>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl OfferPayment {
    pub fn new() -> OfferPayment {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;

    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional string currencyCode = 2;

    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for OfferPayment {
    fn is_initialized(&self) -> bool {
        for v in &self.offerPaymentPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offerPaymentOverride {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<OfferPaymentPeriod, _>(wire_type, is, &mut self.offerPaymentPeriod)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.offerPaymentOverride)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.offerPaymentPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.offerPaymentOverride {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.currencyCode.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.offerPaymentPeriod.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.offerPaymentOverride {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferPayment {
        OfferPayment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "micros",
                |m: &OfferPayment| { &m.micros },
                |m: &mut OfferPayment| { &mut m.micros },
                OfferPayment::get_micros,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "currencyCode",
                |m: &OfferPayment| { &m.currencyCode },
                |m: &mut OfferPayment| { &mut m.currencyCode },
                OfferPayment::get_currencyCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OfferPaymentPeriod>, _>(
                "offerPaymentPeriod",
                |m: &OfferPayment| { &m.offerPaymentPeriod },
                |m: &mut OfferPayment| { &mut m.offerPaymentPeriod },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OfferPaymentOverride>>(
                "offerPaymentOverride",
                |m: &OfferPayment| { &m.offerPaymentOverride },
                |m: &mut OfferPayment| { &mut m.offerPaymentOverride },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<OfferPayment>(
                "OfferPayment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OfferPayment {
        static instance: ::protobuf::rt::Lazy<OfferPayment> = ::protobuf::rt::Lazy::INIT;
        instance.get(OfferPayment::new)
    }
}

impl ::protobuf::Clear for OfferPayment {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.currencyCode.clear();
        self.offerPaymentPeriod.clear();
        self.offerPaymentOverride.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferPayment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferPayment {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct VoucherTerms {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl VoucherTerms {
    pub fn new() -> VoucherTerms {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VoucherTerms {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoucherTerms {
        VoucherTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<VoucherTerms>(
                "VoucherTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoucherTerms {
        static instance: ::protobuf::rt::Lazy<VoucherTerms> = ::protobuf::rt::Lazy::INIT;
        instance.get(VoucherTerms::new)
    }
}

impl ::protobuf::Clear for VoucherTerms {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoucherTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoucherTerms {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RentalTerms {
    // message fields
    pub dEPRECATEDGrantPeriodSeconds: ::std::option::Option<i32>,
    pub dEPRECATEDActivatePeriodSeconds: ::std::option::Option<i32>,
    pub grantPeriod: ::protobuf::SingularPtrField<TimePeriod>,
    pub activatePeriod: ::protobuf::SingularPtrField<TimePeriod>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RentalTerms {
    pub fn new() -> RentalTerms {
        ::std::default::Default::default()
    }

    // optional int32 dEPRECATEDGrantPeriodSeconds = 1;

    pub fn get_dEPRECATEDGrantPeriodSeconds(&self) -> i32 {
        self.dEPRECATEDGrantPeriodSeconds.unwrap_or(0)
    }

    // optional int32 dEPRECATEDActivatePeriodSeconds = 2;

    pub fn get_dEPRECATEDActivatePeriodSeconds(&self) -> i32 {
        self.dEPRECATEDActivatePeriodSeconds.unwrap_or(0)
    }
}

impl ::protobuf::Message for RentalTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.grantPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activatePeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dEPRECATEDGrantPeriodSeconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dEPRECATEDActivatePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<TimePeriod, _>(wire_type, is, &mut self.grantPeriod)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<TimePeriod, _>(wire_type, is, &mut self.activatePeriod)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dEPRECATEDGrantPeriodSeconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dEPRECATEDActivatePeriodSeconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.grantPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.activatePeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dEPRECATEDGrantPeriodSeconds {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.dEPRECATEDActivatePeriodSeconds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.grantPeriod.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.activatePeriod.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RentalTerms {
        RentalTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "dEPRECATEDGrantPeriodSeconds",
                |m: &RentalTerms| { &m.dEPRECATEDGrantPeriodSeconds },
                |m: &mut RentalTerms| { &mut m.dEPRECATEDGrantPeriodSeconds },
                RentalTerms::get_dEPRECATEDGrantPeriodSeconds,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "dEPRECATEDActivatePeriodSeconds",
                |m: &RentalTerms| { &m.dEPRECATEDActivatePeriodSeconds },
                |m: &mut RentalTerms| { &mut m.dEPRECATEDActivatePeriodSeconds },
                RentalTerms::get_dEPRECATEDActivatePeriodSeconds,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>, _>(
                "grantPeriod",
                |m: &RentalTerms| { &m.grantPeriod },
                |m: &mut RentalTerms| { &mut m.grantPeriod },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>, _>(
                "activatePeriod",
                |m: &RentalTerms| { &m.activatePeriod },
                |m: &mut RentalTerms| { &mut m.activatePeriod },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RentalTerms>(
                "RentalTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RentalTerms {
        static instance: ::protobuf::rt::Lazy<RentalTerms> = ::protobuf::rt::Lazy::INIT;
        instance.get(RentalTerms::new)
    }
}

impl ::protobuf::Clear for RentalTerms {
    fn clear(&mut self) {
        self.dEPRECATEDGrantPeriodSeconds = ::std::option::Option::None;
        self.dEPRECATEDActivatePeriodSeconds = ::std::option::Option::None;
        self.grantPeriod.clear();
        self.activatePeriod.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RentalTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RentalTerms {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SignedData {
    // message fields
    pub signedData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SignedData {
    pub fn new() -> SignedData {
        ::std::default::Default::default()
    }

    // optional string signedData = 1;

    pub fn get_signedData(&self) -> &str {
        match self.signedData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string signature = 2;

    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SignedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedData)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.signedData.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.signedData.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedData {
        SignedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signedData",
                |m: &SignedData| { &m.signedData },
                |m: &mut SignedData| { &mut m.signedData },
                SignedData::get_signedData,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signature",
                |m: &SignedData| { &m.signature },
                |m: &mut SignedData| { &mut m.signature },
                SignedData::get_signature,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SignedData>(
                "SignedData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedData {
        static instance: ::protobuf::rt::Lazy<SignedData> = ::protobuf::rt::Lazy::INIT;
        instance.get(SignedData::new)
    }
}

impl ::protobuf::Clear for SignedData {
    fn clear(&mut self) {
        self.signedData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SubscriptionContentTerms {
    // message fields
    pub requiredSubscription: ::protobuf::SingularPtrField<Docid>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SubscriptionContentTerms {
    pub fn new() -> SubscriptionContentTerms {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscriptionContentTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.requiredSubscription {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.requiredSubscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.requiredSubscription.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.requiredSubscription.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionContentTerms {
        SubscriptionContentTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "requiredSubscription",
                |m: &SubscriptionContentTerms| { &m.requiredSubscription },
                |m: &mut SubscriptionContentTerms| { &mut m.requiredSubscription },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SubscriptionContentTerms>(
                "SubscriptionContentTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscriptionContentTerms {
        static instance: ::protobuf::rt::Lazy<SubscriptionContentTerms> = ::protobuf::rt::Lazy::INIT;
        instance.get(SubscriptionContentTerms::new)
    }
}

impl ::protobuf::Clear for SubscriptionContentTerms {
    fn clear(&mut self) {
        self.requiredSubscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionContentTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionContentTerms {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SubscriptionTerms {
    // message fields
    pub recurringPeriod: ::protobuf::SingularPtrField<TimePeriod>,
    pub trialPeriod: ::protobuf::SingularPtrField<TimePeriod>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SubscriptionTerms {
    pub fn new() -> SubscriptionTerms {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscriptionTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.recurringPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trialPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<TimePeriod, _>(wire_type, is, &mut self.recurringPeriod)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<TimePeriod, _>(wire_type, is, &mut self.trialPeriod)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.recurringPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.trialPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.recurringPeriod.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.trialPeriod.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionTerms {
        SubscriptionTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>, _>(
                "recurringPeriod",
                |m: &SubscriptionTerms| { &m.recurringPeriod },
                |m: &mut SubscriptionTerms| { &mut m.recurringPeriod },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>, _>(
                "trialPeriod",
                |m: &SubscriptionTerms| { &m.trialPeriod },
                |m: &mut SubscriptionTerms| { &mut m.trialPeriod },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SubscriptionTerms>(
                "SubscriptionTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscriptionTerms {
        static instance: ::protobuf::rt::Lazy<SubscriptionTerms> = ::protobuf::rt::Lazy::INIT;
        instance.get(SubscriptionTerms::new)
    }
}

impl ::protobuf::Clear for SubscriptionTerms {
    fn clear(&mut self) {
        self.recurringPeriod.clear();
        self.trialPeriod.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionTerms {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct TimePeriod {
    // message fields
    pub unit: ::std::option::Option<i32>,
    pub count: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl TimePeriod {
    pub fn new() -> TimePeriod {
        ::std::default::Default::default()
    }

    // optional int32 unit = 1;

    pub fn get_unit(&self) -> i32 {
        self.unit.unwrap_or(0)
    }

    // optional int32 count = 2;

    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
}

impl ::protobuf::Message for TimePeriod {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unit = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimePeriod {
        TimePeriod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "unit",
                |m: &TimePeriod| { &m.unit },
                |m: &mut TimePeriod| { &mut m.unit },
                TimePeriod::get_unit,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "count",
                |m: &TimePeriod| { &m.count },
                |m: &mut TimePeriod| { &mut m.count },
                TimePeriod::get_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<TimePeriod>(
                "TimePeriod",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimePeriod {
        static instance: ::protobuf::rt::Lazy<TimePeriod> = ::protobuf::rt::Lazy::INIT;
        instance.get(TimePeriod::new)
    }
}

impl ::protobuf::Clear for TimePeriod {
    fn clear(&mut self) {
        self.unit = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimePeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimePeriod {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BillingAddressSpec {
    // message fields
    pub billingAddressType: ::std::option::Option<i32>,
    pub requiredField: ::std::vec::Vec<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BillingAddressSpec {
    pub fn new() -> BillingAddressSpec {
        ::std::default::Default::default()
    }

    // optional int32 billingAddressType = 1;

    pub fn get_billingAddressType(&self) -> i32 {
        self.billingAddressType.unwrap_or(0)
    }
}

impl ::protobuf::Message for BillingAddressSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingAddressType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.requiredField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.billingAddressType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requiredField {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.billingAddressType {
            os.write_int32(1, v)?;
        }
        for v in &self.requiredField {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingAddressSpec {
        BillingAddressSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "billingAddressType",
                |m: &BillingAddressSpec| { &m.billingAddressType },
                |m: &mut BillingAddressSpec| { &mut m.billingAddressType },
                BillingAddressSpec::get_billingAddressType,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "requiredField",
                |m: &BillingAddressSpec| { &m.requiredField },
                |m: &mut BillingAddressSpec| { &mut m.requiredField },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BillingAddressSpec>(
                "BillingAddressSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingAddressSpec {
        static instance: ::protobuf::rt::Lazy<BillingAddressSpec> = ::protobuf::rt::Lazy::INIT;
        instance.get(BillingAddressSpec::new)
    }
}

impl ::protobuf::Clear for BillingAddressSpec {
    fn clear(&mut self) {
        self.billingAddressType = ::std::option::Option::None;
        self.requiredField.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingAddressSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingAddressSpec {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BillingProfile {
    // message fields
    pub instrument: ::protobuf::RepeatedField<Instrument>,
    pub selectedExternalInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub billingProfileOption: ::protobuf::RepeatedField<BillingProfileOption>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BillingProfile {
    pub fn new() -> BillingProfile {
        ::std::default::Default::default()
    }

    // optional string selectedExternalInstrumentId = 2;

    pub fn get_selectedExternalInstrumentId(&self) -> &str {
        match self.selectedExternalInstrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BillingProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingProfileOption {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.instrument)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.selectedExternalInstrumentId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.billingProfileOption)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.instrument {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.selectedExternalInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.billingProfileOption {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.instrument {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.selectedExternalInstrumentId.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.billingProfileOption {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingProfile {
        BillingProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "instrument",
                |m: &BillingProfile| { &m.instrument },
                |m: &mut BillingProfile| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "selectedExternalInstrumentId",
                |m: &BillingProfile| { &m.selectedExternalInstrumentId },
                |m: &mut BillingProfile| { &mut m.selectedExternalInstrumentId },
                BillingProfile::get_selectedExternalInstrumentId,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingProfileOption>>(
                "billingProfileOption",
                |m: &BillingProfile| { &m.billingProfileOption },
                |m: &mut BillingProfile| { &mut m.billingProfileOption },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BillingProfile>(
                "BillingProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingProfile {
        static instance: ::protobuf::rt::Lazy<BillingProfile> = ::protobuf::rt::Lazy::INIT;
        instance.get(BillingProfile::new)
    }
}

impl ::protobuf::Clear for BillingProfile {
    fn clear(&mut self) {
        self.instrument.clear();
        self.selectedExternalInstrumentId.clear();
        self.billingProfileOption.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingProfile {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BillingProfileOption {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub displayTitle: ::protobuf::SingularField<::std::string::String>,
    pub externalInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub topupInfo: ::protobuf::SingularPtrField<TopupInfo>,
    pub carrierBillingInstrumentStatus: ::protobuf::SingularPtrField<CarrierBillingInstrumentStatus>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BillingProfileOption {
    pub fn new() -> BillingProfileOption {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string displayTitle = 2;

    pub fn get_displayTitle(&self) -> &str {
        match self.displayTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string externalInstrumentId = 3;

    pub fn get_externalInstrumentId(&self) -> &str {
        match self.externalInstrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BillingProfileOption {
    fn is_initialized(&self) -> bool {
        for v in &self.topupInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierBillingInstrumentStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayTitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalInstrumentId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<TopupInfo, _>(wire_type, is, &mut self.topupInfo)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierBillingInstrumentStatus, _>(wire_type, is, &mut self.carrierBillingInstrumentStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.displayTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.externalInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.topupInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.carrierBillingInstrumentStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.displayTitle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.externalInstrumentId.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.topupInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.carrierBillingInstrumentStatus.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingProfileOption {
        BillingProfileOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &BillingProfileOption| { &m.field_type },
                |m: &mut BillingProfileOption| { &mut m.field_type },
                BillingProfileOption::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "displayTitle",
                |m: &BillingProfileOption| { &m.displayTitle },
                |m: &mut BillingProfileOption| { &mut m.displayTitle },
                BillingProfileOption::get_displayTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "externalInstrumentId",
                |m: &BillingProfileOption| { &m.externalInstrumentId },
                |m: &mut BillingProfileOption| { &mut m.externalInstrumentId },
                BillingProfileOption::get_externalInstrumentId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopupInfo>, _>(
                "topupInfo",
                |m: &BillingProfileOption| { &m.topupInfo },
                |m: &mut BillingProfileOption| { &mut m.topupInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingInstrumentStatus>, _>(
                "carrierBillingInstrumentStatus",
                |m: &BillingProfileOption| { &m.carrierBillingInstrumentStatus },
                |m: &mut BillingProfileOption| { &mut m.carrierBillingInstrumentStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BillingProfileOption>(
                "BillingProfileOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingProfileOption {
        static instance: ::protobuf::rt::Lazy<BillingProfileOption> = ::protobuf::rt::Lazy::INIT;
        instance.get(BillingProfileOption::new)
    }
}

impl ::protobuf::Clear for BillingProfileOption {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.displayTitle.clear();
        self.externalInstrumentId.clear();
        self.topupInfo.clear();
        self.carrierBillingInstrumentStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingProfileOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingProfileOption {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CarrierBillingCredentials {
    // message fields
    pub value: ::protobuf::SingularField<::std::string::String>,
    pub expiration: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CarrierBillingCredentials {
    pub fn new() -> CarrierBillingCredentials {
        ::std::default::Default::default()
    }

    // optional string value = 1;

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 expiration = 2;

    pub fn get_expiration(&self) -> i64 {
        self.expiration.unwrap_or(0)
    }
}

impl ::protobuf::Message for CarrierBillingCredentials {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingCredentials {
        CarrierBillingCredentials::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "value",
                |m: &CarrierBillingCredentials| { &m.value },
                |m: &mut CarrierBillingCredentials| { &mut m.value },
                CarrierBillingCredentials::get_value,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "expiration",
                |m: &CarrierBillingCredentials| { &m.expiration },
                |m: &mut CarrierBillingCredentials| { &mut m.expiration },
                CarrierBillingCredentials::get_expiration,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CarrierBillingCredentials>(
                "CarrierBillingCredentials",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingCredentials {
        static instance: ::protobuf::rt::Lazy<CarrierBillingCredentials> = ::protobuf::rt::Lazy::INIT;
        instance.get(CarrierBillingCredentials::new)
    }
}

impl ::protobuf::Clear for CarrierBillingCredentials {
    fn clear(&mut self) {
        self.value.clear();
        self.expiration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingCredentials {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingCredentials {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CarrierBillingInstrument {
    // message fields
    pub instrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub accountType: ::protobuf::SingularField<::std::string::String>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub transactionLimit: ::std::option::Option<i64>,
    pub subscriberIdentifier: ::protobuf::SingularField<::std::string::String>,
    pub encryptedSubscriberInfo: ::protobuf::SingularPtrField<EncryptedSubscriberInfo>,
    pub credentials: ::protobuf::SingularPtrField<CarrierBillingCredentials>,
    pub acceptedCarrierTos: ::protobuf::SingularPtrField<CarrierTos>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CarrierBillingInstrument {
    pub fn new() -> CarrierBillingInstrument {
        ::std::default::Default::default()
    }

    // optional string instrumentKey = 1;

    pub fn get_instrumentKey(&self) -> &str {
        match self.instrumentKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string accountType = 2;

    pub fn get_accountType(&self) -> &str {
        match self.accountType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string currencyCode = 3;

    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 transactionLimit = 4;

    pub fn get_transactionLimit(&self) -> i64 {
        self.transactionLimit.unwrap_or(0)
    }

    // optional string subscriberIdentifier = 5;

    pub fn get_subscriberIdentifier(&self) -> &str {
        match self.subscriberIdentifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CarrierBillingInstrument {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedSubscriberInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acceptedCarrierTos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.accountType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transactionLimit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberIdentifier)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<EncryptedSubscriberInfo, _>(wire_type, is, &mut self.encryptedSubscriberInfo)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierBillingCredentials, _>(wire_type, is, &mut self.credentials)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierTos, _>(wire_type, is, &mut self.acceptedCarrierTos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.accountType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.transactionLimit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subscriberIdentifier.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.encryptedSubscriberInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.acceptedCarrierTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentKey.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.accountType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.currencyCode.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.transactionLimit {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.subscriberIdentifier.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.encryptedSubscriberInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.credentials.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.acceptedCarrierTos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingInstrument {
        CarrierBillingInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "instrumentKey",
                |m: &CarrierBillingInstrument| { &m.instrumentKey },
                |m: &mut CarrierBillingInstrument| { &mut m.instrumentKey },
                CarrierBillingInstrument::get_instrumentKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "accountType",
                |m: &CarrierBillingInstrument| { &m.accountType },
                |m: &mut CarrierBillingInstrument| { &mut m.accountType },
                CarrierBillingInstrument::get_accountType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "currencyCode",
                |m: &CarrierBillingInstrument| { &m.currencyCode },
                |m: &mut CarrierBillingInstrument| { &mut m.currencyCode },
                CarrierBillingInstrument::get_currencyCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "transactionLimit",
                |m: &CarrierBillingInstrument| { &m.transactionLimit },
                |m: &mut CarrierBillingInstrument| { &mut m.transactionLimit },
                CarrierBillingInstrument::get_transactionLimit,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subscriberIdentifier",
                |m: &CarrierBillingInstrument| { &m.subscriberIdentifier },
                |m: &mut CarrierBillingInstrument| { &mut m.subscriberIdentifier },
                CarrierBillingInstrument::get_subscriberIdentifier,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedSubscriberInfo>, _>(
                "encryptedSubscriberInfo",
                |m: &CarrierBillingInstrument| { &m.encryptedSubscriberInfo },
                |m: &mut CarrierBillingInstrument| { &mut m.encryptedSubscriberInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingCredentials>, _>(
                "credentials",
                |m: &CarrierBillingInstrument| { &m.credentials },
                |m: &mut CarrierBillingInstrument| { &mut m.credentials },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTos>, _>(
                "acceptedCarrierTos",
                |m: &CarrierBillingInstrument| { &m.acceptedCarrierTos },
                |m: &mut CarrierBillingInstrument| { &mut m.acceptedCarrierTos },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CarrierBillingInstrument>(
                "CarrierBillingInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingInstrument {
        static instance: ::protobuf::rt::Lazy<CarrierBillingInstrument> = ::protobuf::rt::Lazy::INIT;
        instance.get(CarrierBillingInstrument::new)
    }
}

impl ::protobuf::Clear for CarrierBillingInstrument {
    fn clear(&mut self) {
        self.instrumentKey.clear();
        self.accountType.clear();
        self.currencyCode.clear();
        self.transactionLimit = ::std::option::Option::None;
        self.subscriberIdentifier.clear();
        self.encryptedSubscriberInfo.clear();
        self.credentials.clear();
        self.acceptedCarrierTos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingInstrument {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CarrierBillingInstrumentStatus {
    // message fields
    pub carrierTos: ::protobuf::SingularPtrField<CarrierTos>,
    pub associationRequired: ::std::option::Option<bool>,
    pub passwordRequired: ::std::option::Option<bool>,
    pub carrierPasswordPrompt: ::protobuf::SingularPtrField<PasswordPrompt>,
    pub apiVersion: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub deviceAssociation: ::protobuf::SingularPtrField<DeviceAssociation>,
    pub carrierSupportPhoneNumber: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CarrierBillingInstrumentStatus {
    pub fn new() -> CarrierBillingInstrumentStatus {
        ::std::default::Default::default()
    }

    // optional bool associationRequired = 2;

    pub fn get_associationRequired(&self) -> bool {
        self.associationRequired.unwrap_or(false)
    }

    // optional bool passwordRequired = 3;

    pub fn get_passwordRequired(&self) -> bool {
        self.passwordRequired.unwrap_or(false)
    }

    // optional int32 apiVersion = 5;

    pub fn get_apiVersion(&self) -> i32 {
        self.apiVersion.unwrap_or(0)
    }

    // optional string name = 6;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string carrierSupportPhoneNumber = 8;

    pub fn get_carrierSupportPhoneNumber(&self) -> &str {
        match self.carrierSupportPhoneNumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CarrierBillingInstrumentStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierTos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierPasswordPrompt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deviceAssociation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierTos, _>(wire_type, is, &mut self.carrierTos)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.associationRequired = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passwordRequired = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<PasswordPrompt, _>(wire_type, is, &mut self.carrierPasswordPrompt)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.apiVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<DeviceAssociation, _>(wire_type, is, &mut self.deviceAssociation)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrierSupportPhoneNumber)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.carrierTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.associationRequired {
            my_size += 2;
        }
        if let Some(v) = self.passwordRequired {
            my_size += 2;
        }
        if let Some(v) = self.carrierPasswordPrompt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.apiVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.deviceAssociation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.carrierSupportPhoneNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.carrierTos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.associationRequired {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.passwordRequired {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.carrierPasswordPrompt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.apiVersion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.deviceAssociation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.carrierSupportPhoneNumber.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingInstrumentStatus {
        CarrierBillingInstrumentStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTos>, _>(
                "carrierTos",
                |m: &CarrierBillingInstrumentStatus| { &m.carrierTos },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.carrierTos },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "associationRequired",
                |m: &CarrierBillingInstrumentStatus| { &m.associationRequired },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.associationRequired },
                CarrierBillingInstrumentStatus::get_associationRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "passwordRequired",
                |m: &CarrierBillingInstrumentStatus| { &m.passwordRequired },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.passwordRequired },
                CarrierBillingInstrumentStatus::get_passwordRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PasswordPrompt>, _>(
                "carrierPasswordPrompt",
                |m: &CarrierBillingInstrumentStatus| { &m.carrierPasswordPrompt },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.carrierPasswordPrompt },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "apiVersion",
                |m: &CarrierBillingInstrumentStatus| { &m.apiVersion },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.apiVersion },
                CarrierBillingInstrumentStatus::get_apiVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &CarrierBillingInstrumentStatus| { &m.name },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.name },
                CarrierBillingInstrumentStatus::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceAssociation>, _>(
                "deviceAssociation",
                |m: &CarrierBillingInstrumentStatus| { &m.deviceAssociation },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.deviceAssociation },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "carrierSupportPhoneNumber",
                |m: &CarrierBillingInstrumentStatus| { &m.carrierSupportPhoneNumber },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.carrierSupportPhoneNumber },
                CarrierBillingInstrumentStatus::get_carrierSupportPhoneNumber,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CarrierBillingInstrumentStatus>(
                "CarrierBillingInstrumentStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingInstrumentStatus {
        static instance: ::protobuf::rt::Lazy<CarrierBillingInstrumentStatus> = ::protobuf::rt::Lazy::INIT;
        instance.get(CarrierBillingInstrumentStatus::new)
    }
}

impl ::protobuf::Clear for CarrierBillingInstrumentStatus {
    fn clear(&mut self) {
        self.carrierTos.clear();
        self.associationRequired = ::std::option::Option::None;
        self.passwordRequired = ::std::option::Option::None;
        self.carrierPasswordPrompt.clear();
        self.apiVersion = ::std::option::Option::None;
        self.name.clear();
        self.deviceAssociation.clear();
        self.carrierSupportPhoneNumber.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingInstrumentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingInstrumentStatus {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CarrierTos {
    // message fields
    pub dcbTos: ::protobuf::SingularPtrField<CarrierTosEntry>,
    pub piiTos: ::protobuf::SingularPtrField<CarrierTosEntry>,
    pub needsDcbTosAcceptance: ::std::option::Option<bool>,
    pub needsPiiTosAcceptance: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CarrierTos {
    pub fn new() -> CarrierTos {
        ::std::default::Default::default()
    }

    // optional bool needsDcbTosAcceptance = 3;

    pub fn get_needsDcbTosAcceptance(&self) -> bool {
        self.needsDcbTosAcceptance.unwrap_or(false)
    }

    // optional bool needsPiiTosAcceptance = 4;

    pub fn get_needsPiiTosAcceptance(&self) -> bool {
        self.needsPiiTosAcceptance.unwrap_or(false)
    }
}

impl ::protobuf::Message for CarrierTos {
    fn is_initialized(&self) -> bool {
        for v in &self.dcbTos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.piiTos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierTosEntry, _>(wire_type, is, &mut self.dcbTos)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierTosEntry, _>(wire_type, is, &mut self.piiTos)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needsDcbTosAcceptance = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needsPiiTosAcceptance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dcbTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.piiTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.needsDcbTosAcceptance {
            my_size += 2;
        }
        if let Some(v) = self.needsPiiTosAcceptance {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dcbTos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.piiTos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.needsDcbTosAcceptance {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.needsPiiTosAcceptance {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierTos {
        CarrierTos::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTosEntry>, _>(
                "dcbTos",
                |m: &CarrierTos| { &m.dcbTos },
                |m: &mut CarrierTos| { &mut m.dcbTos },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTosEntry>, _>(
                "piiTos",
                |m: &CarrierTos| { &m.piiTos },
                |m: &mut CarrierTos| { &mut m.piiTos },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "needsDcbTosAcceptance",
                |m: &CarrierTos| { &m.needsDcbTosAcceptance },
                |m: &mut CarrierTos| { &mut m.needsDcbTosAcceptance },
                CarrierTos::get_needsDcbTosAcceptance,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "needsPiiTosAcceptance",
                |m: &CarrierTos| { &m.needsPiiTosAcceptance },
                |m: &mut CarrierTos| { &mut m.needsPiiTosAcceptance },
                CarrierTos::get_needsPiiTosAcceptance,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CarrierTos>(
                "CarrierTos",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierTos {
        static instance: ::protobuf::rt::Lazy<CarrierTos> = ::protobuf::rt::Lazy::INIT;
        instance.get(CarrierTos::new)
    }
}

impl ::protobuf::Clear for CarrierTos {
    fn clear(&mut self) {
        self.dcbTos.clear();
        self.piiTos.clear();
        self.needsDcbTosAcceptance = ::std::option::Option::None;
        self.needsPiiTosAcceptance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierTos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierTos {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CarrierTosEntry {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CarrierTosEntry {
    pub fn new() -> CarrierTosEntry {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string version = 2;

    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CarrierTosEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierTosEntry {
        CarrierTosEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &CarrierTosEntry| { &m.url },
                |m: &mut CarrierTosEntry| { &mut m.url },
                CarrierTosEntry::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "version",
                |m: &CarrierTosEntry| { &m.version },
                |m: &mut CarrierTosEntry| { &mut m.version },
                CarrierTosEntry::get_version,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CarrierTosEntry>(
                "CarrierTosEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierTosEntry {
        static instance: ::protobuf::rt::Lazy<CarrierTosEntry> = ::protobuf::rt::Lazy::INIT;
        instance.get(CarrierTosEntry::new)
    }
}

impl ::protobuf::Clear for CarrierTosEntry {
    fn clear(&mut self) {
        self.url.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierTosEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierTosEntry {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CreditCardInstrument {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub escrowHandle: ::protobuf::SingularField<::std::string::String>,
    pub lastDigits: ::protobuf::SingularField<::std::string::String>,
    pub expirationMonth: ::std::option::Option<i32>,
    pub expirationYear: ::std::option::Option<i32>,
    pub escrowEfeParam: ::protobuf::RepeatedField<EfeParam>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CreditCardInstrument {
    pub fn new() -> CreditCardInstrument {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string escrowHandle = 2;

    pub fn get_escrowHandle(&self) -> &str {
        match self.escrowHandle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string lastDigits = 3;

    pub fn get_lastDigits(&self) -> &str {
        match self.lastDigits.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 expirationMonth = 4;

    pub fn get_expirationMonth(&self) -> i32 {
        self.expirationMonth.unwrap_or(0)
    }

    // optional int32 expirationYear = 5;

    pub fn get_expirationYear(&self) -> i32 {
        self.expirationYear.unwrap_or(0)
    }
}

impl ::protobuf::Message for CreditCardInstrument {
    fn is_initialized(&self) -> bool {
        for v in &self.escrowEfeParam {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.escrowHandle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastDigits)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expirationMonth = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expirationYear = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.escrowEfeParam)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.escrowHandle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastDigits.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.expirationMonth {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expirationYear {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.escrowEfeParam {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.escrowHandle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastDigits.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.expirationMonth {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.expirationYear {
            os.write_int32(5, v)?;
        }
        for v in &self.escrowEfeParam {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreditCardInstrument {
        CreditCardInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &CreditCardInstrument| { &m.field_type },
                |m: &mut CreditCardInstrument| { &mut m.field_type },
                CreditCardInstrument::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "escrowHandle",
                |m: &CreditCardInstrument| { &m.escrowHandle },
                |m: &mut CreditCardInstrument| { &mut m.escrowHandle },
                CreditCardInstrument::get_escrowHandle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "lastDigits",
                |m: &CreditCardInstrument| { &m.lastDigits },
                |m: &mut CreditCardInstrument| { &mut m.lastDigits },
                CreditCardInstrument::get_lastDigits,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "expirationMonth",
                |m: &CreditCardInstrument| { &m.expirationMonth },
                |m: &mut CreditCardInstrument| { &mut m.expirationMonth },
                CreditCardInstrument::get_expirationMonth,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "expirationYear",
                |m: &CreditCardInstrument| { &m.expirationYear },
                |m: &mut CreditCardInstrument| { &mut m.expirationYear },
                CreditCardInstrument::get_expirationYear,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EfeParam>>(
                "escrowEfeParam",
                |m: &CreditCardInstrument| { &m.escrowEfeParam },
                |m: &mut CreditCardInstrument| { &mut m.escrowEfeParam },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CreditCardInstrument>(
                "CreditCardInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreditCardInstrument {
        static instance: ::protobuf::rt::Lazy<CreditCardInstrument> = ::protobuf::rt::Lazy::INIT;
        instance.get(CreditCardInstrument::new)
    }
}

impl ::protobuf::Clear for CreditCardInstrument {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.escrowHandle.clear();
        self.lastDigits.clear();
        self.expirationMonth = ::std::option::Option::None;
        self.expirationYear = ::std::option::Option::None;
        self.escrowEfeParam.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreditCardInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreditCardInstrument {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DeviceAssociation {
    // message fields
    pub userTokenRequestMessage: ::protobuf::SingularField<::std::string::String>,
    pub userTokenRequestAddress: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceAssociation {
    pub fn new() -> DeviceAssociation {
        ::std::default::Default::default()
    }

    // optional string userTokenRequestMessage = 1;

    pub fn get_userTokenRequestMessage(&self) -> &str {
        match self.userTokenRequestMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string userTokenRequestAddress = 2;

    pub fn get_userTokenRequestAddress(&self) -> &str {
        match self.userTokenRequestAddress.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DeviceAssociation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userTokenRequestMessage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userTokenRequestAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.userTokenRequestMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.userTokenRequestAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.userTokenRequestMessage.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.userTokenRequestAddress.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceAssociation {
        DeviceAssociation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userTokenRequestMessage",
                |m: &DeviceAssociation| { &m.userTokenRequestMessage },
                |m: &mut DeviceAssociation| { &mut m.userTokenRequestMessage },
                DeviceAssociation::get_userTokenRequestMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userTokenRequestAddress",
                |m: &DeviceAssociation| { &m.userTokenRequestAddress },
                |m: &mut DeviceAssociation| { &mut m.userTokenRequestAddress },
                DeviceAssociation::get_userTokenRequestAddress,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DeviceAssociation>(
                "DeviceAssociation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceAssociation {
        static instance: ::protobuf::rt::Lazy<DeviceAssociation> = ::protobuf::rt::Lazy::INIT;
        instance.get(DeviceAssociation::new)
    }
}

impl ::protobuf::Clear for DeviceAssociation {
    fn clear(&mut self) {
        self.userTokenRequestMessage.clear();
        self.userTokenRequestAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceAssociation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAssociation {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DisabledInfo {
    // message fields
    pub disabledReason: ::std::option::Option<i32>,
    pub disabledMessageHtml: ::protobuf::SingularField<::std::string::String>,
    pub errorMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DisabledInfo {
    pub fn new() -> DisabledInfo {
        ::std::default::Default::default()
    }

    // optional int32 disabledReason = 1;

    pub fn get_disabledReason(&self) -> i32 {
        self.disabledReason.unwrap_or(0)
    }

    // optional string disabledMessageHtml = 2;

    pub fn get_disabledMessageHtml(&self) -> &str {
        match self.disabledMessageHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string errorMessage = 3;

    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DisabledInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.disabledReason = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.disabledMessageHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.disabledReason {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.disabledMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.disabledReason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.disabledMessageHtml.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.errorMessage.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisabledInfo {
        DisabledInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "disabledReason",
                |m: &DisabledInfo| { &m.disabledReason },
                |m: &mut DisabledInfo| { &mut m.disabledReason },
                DisabledInfo::get_disabledReason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "disabledMessageHtml",
                |m: &DisabledInfo| { &m.disabledMessageHtml },
                |m: &mut DisabledInfo| { &mut m.disabledMessageHtml },
                DisabledInfo::get_disabledMessageHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "errorMessage",
                |m: &DisabledInfo| { &m.errorMessage },
                |m: &mut DisabledInfo| { &mut m.errorMessage },
                DisabledInfo::get_errorMessage,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DisabledInfo>(
                "DisabledInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisabledInfo {
        static instance: ::protobuf::rt::Lazy<DisabledInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(DisabledInfo::new)
    }
}

impl ::protobuf::Clear for DisabledInfo {
    fn clear(&mut self) {
        self.disabledReason = ::std::option::Option::None;
        self.disabledMessageHtml.clear();
        self.errorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisabledInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisabledInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct EfeParam {
    // message fields
    pub key: ::std::option::Option<i32>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl EfeParam {
    pub fn new() -> EfeParam {
        ::std::default::Default::default()
    }

    // optional int32 key = 1;

    pub fn get_key(&self) -> i32 {
        self.key.unwrap_or(0)
    }

    // optional string value = 2;

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for EfeParam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EfeParam {
        EfeParam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "key",
                |m: &EfeParam| { &m.key },
                |m: &mut EfeParam| { &mut m.key },
                EfeParam::get_key,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "value",
                |m: &EfeParam| { &m.value },
                |m: &mut EfeParam| { &mut m.value },
                EfeParam::get_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<EfeParam>(
                "EfeParam",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EfeParam {
        static instance: ::protobuf::rt::Lazy<EfeParam> = ::protobuf::rt::Lazy::INIT;
        instance.get(EfeParam::new)
    }
}

impl ::protobuf::Clear for EfeParam {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EfeParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EfeParam {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Instrument {
    // message fields
    pub externalInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub billingAddress: ::protobuf::SingularPtrField<Address>,
    pub creditCard: ::protobuf::SingularPtrField<CreditCardInstrument>,
    pub carrierBilling: ::protobuf::SingularPtrField<CarrierBillingInstrument>,
    pub billingAddressSpec: ::protobuf::SingularPtrField<BillingAddressSpec>,
    pub instrumentFamily: ::std::option::Option<i32>,
    pub carrierBillingStatus: ::protobuf::SingularPtrField<CarrierBillingInstrumentStatus>,
    pub displayTitle: ::protobuf::SingularField<::std::string::String>,
    pub topupInfoDeprecated: ::protobuf::SingularPtrField<TopupInfo>,
    pub version: ::std::option::Option<i32>,
    pub storedValue: ::protobuf::SingularPtrField<StoredValueInstrument>,
    pub disabledInfo: ::protobuf::RepeatedField<DisabledInfo>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Instrument {
    pub fn new() -> Instrument {
        ::std::default::Default::default()
    }

    // optional string externalInstrumentId = 1;

    pub fn get_externalInstrumentId(&self) -> &str {
        match self.externalInstrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 instrumentFamily = 6;

    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }

    // optional string displayTitle = 8;

    pub fn get_displayTitle(&self) -> &str {
        match self.displayTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 version = 10;

    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }
}

impl ::protobuf::Message for Instrument {
    fn is_initialized(&self) -> bool {
        for v in &self.billingAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creditCard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierBilling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingAddressSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierBillingStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.topupInfoDeprecated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storedValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.disabledInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalInstrumentId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Address, _>(wire_type, is, &mut self.billingAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<CreditCardInstrument, _>(wire_type, is, &mut self.creditCard)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierBillingInstrument, _>(wire_type, is, &mut self.carrierBilling)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<BillingAddressSpec, _>(wire_type, is, &mut self.billingAddressSpec)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierBillingInstrumentStatus, _>(wire_type, is, &mut self.carrierBillingStatus)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayTitle)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<TopupInfo, _>(wire_type, is, &mut self.topupInfoDeprecated)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<StoredValueInstrument, _>(wire_type, is, &mut self.storedValue)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.disabledInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.externalInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.billingAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.creditCard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.carrierBilling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.billingAddressSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.carrierBillingStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.displayTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.topupInfoDeprecated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storedValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.disabledInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.externalInstrumentId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.billingAddress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.creditCard.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.carrierBilling.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.billingAddressSpec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.instrumentFamily {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.carrierBillingStatus.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.displayTitle.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.topupInfoDeprecated.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.version {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.storedValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        for v in &self.disabledInfo {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Instrument {
        Instrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "externalInstrumentId",
                |m: &Instrument| { &m.externalInstrumentId },
                |m: &mut Instrument| { &mut m.externalInstrumentId },
                Instrument::get_externalInstrumentId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>, _>(
                "billingAddress",
                |m: &Instrument| { &m.billingAddress },
                |m: &mut Instrument| { &mut m.billingAddress },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreditCardInstrument>, _>(
                "creditCard",
                |m: &Instrument| { &m.creditCard },
                |m: &mut Instrument| { &mut m.creditCard },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingInstrument>, _>(
                "carrierBilling",
                |m: &Instrument| { &m.carrierBilling },
                |m: &mut Instrument| { &mut m.carrierBilling },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingAddressSpec>, _>(
                "billingAddressSpec",
                |m: &Instrument| { &m.billingAddressSpec },
                |m: &mut Instrument| { &mut m.billingAddressSpec },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "instrumentFamily",
                |m: &Instrument| { &m.instrumentFamily },
                |m: &mut Instrument| { &mut m.instrumentFamily },
                Instrument::get_instrumentFamily,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingInstrumentStatus>, _>(
                "carrierBillingStatus",
                |m: &Instrument| { &m.carrierBillingStatus },
                |m: &mut Instrument| { &mut m.carrierBillingStatus },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "displayTitle",
                |m: &Instrument| { &m.displayTitle },
                |m: &mut Instrument| { &mut m.displayTitle },
                Instrument::get_displayTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopupInfo>, _>(
                "topupInfoDeprecated",
                |m: &Instrument| { &m.topupInfoDeprecated },
                |m: &mut Instrument| { &mut m.topupInfoDeprecated },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "version",
                |m: &Instrument| { &m.version },
                |m: &mut Instrument| { &mut m.version },
                Instrument::get_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StoredValueInstrument>, _>(
                "storedValue",
                |m: &Instrument| { &m.storedValue },
                |m: &mut Instrument| { &mut m.storedValue },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DisabledInfo>>(
                "disabledInfo",
                |m: &Instrument| { &m.disabledInfo },
                |m: &mut Instrument| { &mut m.disabledInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Instrument>(
                "Instrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Instrument {
        static instance: ::protobuf::rt::Lazy<Instrument> = ::protobuf::rt::Lazy::INIT;
        instance.get(Instrument::new)
    }
}

impl ::protobuf::Clear for Instrument {
    fn clear(&mut self) {
        self.externalInstrumentId.clear();
        self.billingAddress.clear();
        self.creditCard.clear();
        self.carrierBilling.clear();
        self.billingAddressSpec.clear();
        self.instrumentFamily = ::std::option::Option::None;
        self.carrierBillingStatus.clear();
        self.displayTitle.clear();
        self.topupInfoDeprecated.clear();
        self.version = ::std::option::Option::None;
        self.storedValue.clear();
        self.disabledInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Instrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Instrument {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InstrumentSetupInfo {
    // message fields
    pub instrumentFamily: ::std::option::Option<i32>,
    pub supported: ::std::option::Option<bool>,
    pub addressChallenge: ::protobuf::SingularPtrField<AddressChallenge>,
    pub balance: ::protobuf::SingularPtrField<Money>,
    pub footerHtml: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InstrumentSetupInfo {
    pub fn new() -> InstrumentSetupInfo {
        ::std::default::Default::default()
    }

    // optional int32 instrumentFamily = 1;

    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }

    // optional bool supported = 2;

    pub fn get_supported(&self) -> bool {
        self.supported.unwrap_or(false)
    }
}

impl ::protobuf::Message for InstrumentSetupInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.addressChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.balance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supported = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<AddressChallenge, _>(wire_type, is, &mut self.addressChallenge)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<Money, _>(wire_type, is, &mut self.balance)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supported {
            my_size += 2;
        }
        if let Some(v) = self.addressChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.footerHtml {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentFamily {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.supported {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.addressChallenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.balance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.footerHtml {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentSetupInfo {
        InstrumentSetupInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "instrumentFamily",
                |m: &InstrumentSetupInfo| { &m.instrumentFamily },
                |m: &mut InstrumentSetupInfo| { &mut m.instrumentFamily },
                InstrumentSetupInfo::get_instrumentFamily,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "supported",
                |m: &InstrumentSetupInfo| { &m.supported },
                |m: &mut InstrumentSetupInfo| { &mut m.supported },
                InstrumentSetupInfo::get_supported,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressChallenge>, _>(
                "addressChallenge",
                |m: &InstrumentSetupInfo| { &m.addressChallenge },
                |m: &mut InstrumentSetupInfo| { &mut m.addressChallenge },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Money>, _>(
                "balance",
                |m: &InstrumentSetupInfo| { &m.balance },
                |m: &mut InstrumentSetupInfo| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &InstrumentSetupInfo| { &m.footerHtml },
                |m: &mut InstrumentSetupInfo| { &mut m.footerHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InstrumentSetupInfo>(
                "InstrumentSetupInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentSetupInfo {
        static instance: ::protobuf::rt::Lazy<InstrumentSetupInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(InstrumentSetupInfo::new)
    }
}

impl ::protobuf::Clear for InstrumentSetupInfo {
    fn clear(&mut self) {
        self.instrumentFamily = ::std::option::Option::None;
        self.supported = ::std::option::Option::None;
        self.addressChallenge.clear();
        self.balance.clear();
        self.footerHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentSetupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentSetupInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PasswordPrompt {
    // message fields
    pub prompt: ::protobuf::SingularField<::std::string::String>,
    pub forgotPasswordUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PasswordPrompt {
    pub fn new() -> PasswordPrompt {
        ::std::default::Default::default()
    }

    // optional string prompt = 1;

    pub fn get_prompt(&self) -> &str {
        match self.prompt.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string forgotPasswordUrl = 2;

    pub fn get_forgotPasswordUrl(&self) -> &str {
        match self.forgotPasswordUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PasswordPrompt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prompt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.forgotPasswordUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prompt.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.forgotPasswordUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prompt.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.forgotPasswordUrl.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PasswordPrompt {
        PasswordPrompt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "prompt",
                |m: &PasswordPrompt| { &m.prompt },
                |m: &mut PasswordPrompt| { &mut m.prompt },
                PasswordPrompt::get_prompt,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "forgotPasswordUrl",
                |m: &PasswordPrompt| { &m.forgotPasswordUrl },
                |m: &mut PasswordPrompt| { &mut m.forgotPasswordUrl },
                PasswordPrompt::get_forgotPasswordUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PasswordPrompt>(
                "PasswordPrompt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PasswordPrompt {
        static instance: ::protobuf::rt::Lazy<PasswordPrompt> = ::protobuf::rt::Lazy::INIT;
        instance.get(PasswordPrompt::new)
    }
}

impl ::protobuf::Clear for PasswordPrompt {
    fn clear(&mut self) {
        self.prompt.clear();
        self.forgotPasswordUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PasswordPrompt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PasswordPrompt {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct StoredValueInstrument {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub balance: ::protobuf::SingularPtrField<Money>,
    pub topupInfo: ::protobuf::SingularPtrField<TopupInfo>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl StoredValueInstrument {
    pub fn new() -> StoredValueInstrument {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
}

impl ::protobuf::Message for StoredValueInstrument {
    fn is_initialized(&self) -> bool {
        for v in &self.balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.topupInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Money, _>(wire_type, is, &mut self.balance)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<TopupInfo, _>(wire_type, is, &mut self.topupInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.topupInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.balance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.topupInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoredValueInstrument {
        StoredValueInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &StoredValueInstrument| { &m.field_type },
                |m: &mut StoredValueInstrument| { &mut m.field_type },
                StoredValueInstrument::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Money>, _>(
                "balance",
                |m: &StoredValueInstrument| { &m.balance },
                |m: &mut StoredValueInstrument| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopupInfo>, _>(
                "topupInfo",
                |m: &StoredValueInstrument| { &m.topupInfo },
                |m: &mut StoredValueInstrument| { &mut m.topupInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<StoredValueInstrument>(
                "StoredValueInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StoredValueInstrument {
        static instance: ::protobuf::rt::Lazy<StoredValueInstrument> = ::protobuf::rt::Lazy::INIT;
        instance.get(StoredValueInstrument::new)
    }
}

impl ::protobuf::Clear for StoredValueInstrument {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.balance.clear();
        self.topupInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoredValueInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoredValueInstrument {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct TopupInfo {
    // message fields
    pub optionsContainerDocidDeprecated: ::protobuf::SingularField<::std::string::String>,
    pub optionsListUrl: ::protobuf::SingularField<::std::string::String>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub optionsContainerDocid: ::protobuf::SingularPtrField<Docid>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl TopupInfo {
    pub fn new() -> TopupInfo {
        ::std::default::Default::default()
    }

    // optional string optionsContainerDocidDeprecated = 1;

    pub fn get_optionsContainerDocidDeprecated(&self) -> &str {
        match self.optionsContainerDocidDeprecated.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string optionsListUrl = 2;

    pub fn get_optionsListUrl(&self) -> &str {
        match self.optionsListUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string subtitle = 3;

    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TopupInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.optionsContainerDocid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.optionsContainerDocidDeprecated)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.optionsListUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.optionsContainerDocid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.optionsContainerDocidDeprecated.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.optionsListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.optionsContainerDocid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.optionsContainerDocidDeprecated.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.optionsListUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.subtitle.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.optionsContainerDocid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TopupInfo {
        TopupInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "optionsContainerDocidDeprecated",
                |m: &TopupInfo| { &m.optionsContainerDocidDeprecated },
                |m: &mut TopupInfo| { &mut m.optionsContainerDocidDeprecated },
                TopupInfo::get_optionsContainerDocidDeprecated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "optionsListUrl",
                |m: &TopupInfo| { &m.optionsListUrl },
                |m: &mut TopupInfo| { &mut m.optionsListUrl },
                TopupInfo::get_optionsListUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subtitle",
                |m: &TopupInfo| { &m.subtitle },
                |m: &mut TopupInfo| { &mut m.subtitle },
                TopupInfo::get_subtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "optionsContainerDocid",
                |m: &TopupInfo| { &m.optionsContainerDocid },
                |m: &mut TopupInfo| { &mut m.optionsContainerDocid },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<TopupInfo>(
                "TopupInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TopupInfo {
        static instance: ::protobuf::rt::Lazy<TopupInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(TopupInfo::new)
    }
}

impl ::protobuf::Clear for TopupInfo {
    fn clear(&mut self) {
        self.optionsContainerDocidDeprecated.clear();
        self.optionsListUrl.clear();
        self.subtitle.clear();
        self.optionsContainerDocid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TopupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopupInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ConsumePurchaseResponse {
    // message fields
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    pub status: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ConsumePurchaseResponse {
    pub fn new() -> ConsumePurchaseResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 2;

    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }
}

impl ::protobuf::Message for ConsumePurchaseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryUpdate, _>(wire_type, is, &mut self.libraryUpdate)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.libraryUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.status {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsumePurchaseResponse {
        ConsumePurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>, _>(
                "libraryUpdate",
                |m: &ConsumePurchaseResponse| { &m.libraryUpdate },
                |m: &mut ConsumePurchaseResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "status",
                |m: &ConsumePurchaseResponse| { &m.status },
                |m: &mut ConsumePurchaseResponse| { &mut m.status },
                ConsumePurchaseResponse::get_status,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ConsumePurchaseResponse>(
                "ConsumePurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsumePurchaseResponse {
        static instance: ::protobuf::rt::Lazy<ConsumePurchaseResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ConsumePurchaseResponse::new)
    }
}

impl ::protobuf::Clear for ConsumePurchaseResponse {
    fn clear(&mut self) {
        self.libraryUpdate.clear();
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsumePurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsumePurchaseResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ContainerMetadata {
    // message fields
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub relevance: ::std::option::Option<f64>,
    pub estimatedResults: ::std::option::Option<i64>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub ordered: ::std::option::Option<bool>,
    pub containerView: ::protobuf::RepeatedField<ContainerView>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ContainerMetadata {
    pub fn new() -> ContainerMetadata {
        ::std::default::Default::default()
    }

    // optional string browseUrl = 1;

    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string nextPageUrl = 2;

    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional double relevance = 3;

    pub fn get_relevance(&self) -> f64 {
        self.relevance.unwrap_or(0.)
    }

    // optional int64 estimatedResults = 4;

    pub fn get_estimatedResults(&self) -> i64 {
        self.estimatedResults.unwrap_or(0)
    }

    // optional string analyticsCookie = 5;

    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool ordered = 6;

    pub fn get_ordered(&self) -> bool {
        self.ordered.unwrap_or(false)
    }
}

impl ::protobuf::Message for ContainerMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.containerView {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.relevance = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.estimatedResults = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ordered = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.containerView)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.relevance {
            my_size += 9;
        }
        if let Some(v) = self.estimatedResults {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.ordered {
            my_size += 2;
        }
        for value in &self.containerView {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browseUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.nextPageUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.relevance {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.estimatedResults {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.analyticsCookie.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.ordered {
            os.write_bool(6, v)?;
        }
        for v in &self.containerView {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerMetadata {
        ContainerMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "browseUrl",
                |m: &ContainerMetadata| { &m.browseUrl },
                |m: &mut ContainerMetadata| { &mut m.browseUrl },
                ContainerMetadata::get_browseUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "nextPageUrl",
                |m: &ContainerMetadata| { &m.nextPageUrl },
                |m: &mut ContainerMetadata| { &mut m.nextPageUrl },
                ContainerMetadata::get_nextPageUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeDouble, _>(
                "relevance",
                |m: &ContainerMetadata| { &m.relevance },
                |m: &mut ContainerMetadata| { &mut m.relevance },
                ContainerMetadata::get_relevance,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "estimatedResults",
                |m: &ContainerMetadata| { &m.estimatedResults },
                |m: &mut ContainerMetadata| { &mut m.estimatedResults },
                ContainerMetadata::get_estimatedResults,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "analyticsCookie",
                |m: &ContainerMetadata| { &m.analyticsCookie },
                |m: &mut ContainerMetadata| { &mut m.analyticsCookie },
                ContainerMetadata::get_analyticsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "ordered",
                |m: &ContainerMetadata| { &m.ordered },
                |m: &mut ContainerMetadata| { &mut m.ordered },
                ContainerMetadata::get_ordered,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerView>>(
                "containerView",
                |m: &ContainerMetadata| { &m.containerView },
                |m: &mut ContainerMetadata| { &mut m.containerView },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ContainerMetadata>(
                "ContainerMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerMetadata {
        static instance: ::protobuf::rt::Lazy<ContainerMetadata> = ::protobuf::rt::Lazy::INIT;
        instance.get(ContainerMetadata::new)
    }
}

impl ::protobuf::Clear for ContainerMetadata {
    fn clear(&mut self) {
        self.browseUrl.clear();
        self.nextPageUrl.clear();
        self.relevance = ::std::option::Option::None;
        self.estimatedResults = ::std::option::Option::None;
        self.analyticsCookie.clear();
        self.ordered = ::std::option::Option::None;
        self.containerView.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerMetadata {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ContainerView {
    // message fields
    pub selected: ::std::option::Option<bool>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub listUrl: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ContainerView {
    pub fn new() -> ContainerView {
        ::std::default::Default::default()
    }

    // optional bool selected = 1;

    pub fn get_selected(&self) -> bool {
        self.selected.unwrap_or(false)
    }

    // optional string title = 2;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string listUrl = 3;

    pub fn get_listUrl(&self) -> &str {
        match self.listUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 4;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ContainerView {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selected = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.listUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selected {
            my_size += 2;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.listUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selected {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.listUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerView {
        ContainerView::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "selected",
                |m: &ContainerView| { &m.selected },
                |m: &mut ContainerView| { &mut m.selected },
                ContainerView::get_selected,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &ContainerView| { &m.title },
                |m: &mut ContainerView| { &mut m.title },
                ContainerView::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "listUrl",
                |m: &ContainerView| { &m.listUrl },
                |m: &mut ContainerView| { &mut m.listUrl },
                ContainerView::get_listUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &ContainerView| { &m.serverLogsCookie },
                |m: &mut ContainerView| { &mut m.serverLogsCookie },
                ContainerView::get_serverLogsCookie,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ContainerView>(
                "ContainerView",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerView {
        static instance: ::protobuf::rt::Lazy<ContainerView> = ::protobuf::rt::Lazy::INIT;
        instance.get(ContainerView::new)
    }
}

impl ::protobuf::Clear for ContainerView {
    fn clear(&mut self) {
        self.selected = ::std::option::Option::None;
        self.title.clear();
        self.listUrl.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerView {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct FlagContentResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl FlagContentResponse {
    pub fn new() -> FlagContentResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FlagContentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlagContentResponse {
        FlagContentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<FlagContentResponse>(
                "FlagContentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FlagContentResponse {
        static instance: ::protobuf::rt::Lazy<FlagContentResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(FlagContentResponse::new)
    }
}

impl ::protobuf::Clear for FlagContentResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlagContentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagContentResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadRequest {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub digests: ::protobuf::SingularPtrField<ClientDownloadRequest_Digests>,
    pub length: ::std::option::Option<i64>,
    pub resources: ::protobuf::RepeatedField<ClientDownloadRequest_Resource>,
    pub signature: ::protobuf::SingularPtrField<ClientDownloadRequest_SignatureInfo>,
    pub userInitiated: ::std::option::Option<bool>,
    pub clientAsn: ::protobuf::RepeatedField<::std::string::String>,
    pub fileBasename: ::protobuf::SingularField<::std::string::String>,
    pub downloadType: ::std::option::Option<i32>,
    pub locale: ::protobuf::SingularField<::std::string::String>,
    pub apkInfo: ::protobuf::SingularPtrField<ClientDownloadRequest_ApkInfo>,
    pub androidId: ::std::option::Option<u64>,
    pub originatingPackages: ::protobuf::RepeatedField<::std::string::String>,
    pub originatingSignature: ::protobuf::SingularPtrField<ClientDownloadRequest_SignatureInfo>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadRequest {
    pub fn new() -> ClientDownloadRequest {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 length = 3;

    pub fn get_length(&self) -> i64 {
        self.length.unwrap_or(0)
    }

    // optional bool userInitiated = 6;

    pub fn get_userInitiated(&self) -> bool {
        self.userInitiated.unwrap_or(false)
    }

    // optional string fileBasename = 9;

    pub fn get_fileBasename(&self) -> &str {
        match self.fileBasename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 downloadType = 10;

    pub fn get_downloadType(&self) -> i32 {
        self.downloadType.unwrap_or(0)
    }

    // optional string locale = 11;

    pub fn get_locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional fixed64 androidId = 13;

    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }
}

impl ::protobuf::Message for ClientDownloadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.digests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apkInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.originatingSignature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ClientDownloadRequest_Digests, _>(wire_type, is, &mut self.digests)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.resources)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<ClientDownloadRequest_SignatureInfo, _>(wire_type, is, &mut self.signature)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.userInitiated = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.clientAsn)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fileBasename)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.downloadType = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.locale)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<ClientDownloadRequest_ApkInfo, _>(wire_type, is, &mut self.apkInfo)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.originatingPackages)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<ClientDownloadRequest_SignatureInfo, _>(wire_type, is, &mut self.originatingSignature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.digests.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.userInitiated {
            my_size += 2;
        }
        for value in &self.clientAsn {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.fileBasename.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.downloadType {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.apkInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        for value in &self.originatingPackages {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.originatingSignature.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.digests.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.length {
            os.write_int64(3, v)?;
        }
        for v in &self.resources {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.signature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.userInitiated {
            os.write_bool(6, v)?;
        }
        for v in &self.clientAsn {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.fileBasename.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.downloadType {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.locale.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.apkInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.androidId {
            os.write_fixed64(13, v)?;
        }
        for v in &self.originatingPackages {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.originatingSignature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest {
        ClientDownloadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &ClientDownloadRequest| { &m.url },
                |m: &mut ClientDownloadRequest| { &mut m.url },
                ClientDownloadRequest::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_Digests>, _>(
                "digests",
                |m: &ClientDownloadRequest| { &m.digests },
                |m: &mut ClientDownloadRequest| { &mut m.digests },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "length",
                |m: &ClientDownloadRequest| { &m.length },
                |m: &mut ClientDownloadRequest| { &mut m.length },
                ClientDownloadRequest::get_length,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_Resource>>(
                "resources",
                |m: &ClientDownloadRequest| { &m.resources },
                |m: &mut ClientDownloadRequest| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_SignatureInfo>, _>(
                "signature",
                |m: &ClientDownloadRequest| { &m.signature },
                |m: &mut ClientDownloadRequest| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "userInitiated",
                |m: &ClientDownloadRequest| { &m.userInitiated },
                |m: &mut ClientDownloadRequest| { &mut m.userInitiated },
                ClientDownloadRequest::get_userInitiated,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientAsn",
                |m: &ClientDownloadRequest| { &m.clientAsn },
                |m: &mut ClientDownloadRequest| { &mut m.clientAsn },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "fileBasename",
                |m: &ClientDownloadRequest| { &m.fileBasename },
                |m: &mut ClientDownloadRequest| { &mut m.fileBasename },
                ClientDownloadRequest::get_fileBasename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "downloadType",
                |m: &ClientDownloadRequest| { &m.downloadType },
                |m: &mut ClientDownloadRequest| { &mut m.downloadType },
                ClientDownloadRequest::get_downloadType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "locale",
                |m: &ClientDownloadRequest| { &m.locale },
                |m: &mut ClientDownloadRequest| { &mut m.locale },
                ClientDownloadRequest::get_locale,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_ApkInfo>, _>(
                "apkInfo",
                |m: &ClientDownloadRequest| { &m.apkInfo },
                |m: &mut ClientDownloadRequest| { &mut m.apkInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeFixed64, _>(
                "androidId",
                |m: &ClientDownloadRequest| { &m.androidId },
                |m: &mut ClientDownloadRequest| { &mut m.androidId },
                ClientDownloadRequest::get_androidId,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "originatingPackages",
                |m: &ClientDownloadRequest| { &m.originatingPackages },
                |m: &mut ClientDownloadRequest| { &mut m.originatingPackages },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_SignatureInfo>, _>(
                "originatingSignature",
                |m: &ClientDownloadRequest| { &m.originatingSignature },
                |m: &mut ClientDownloadRequest| { &mut m.originatingSignature },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadRequest>(
                "ClientDownloadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest {
        static instance: ::protobuf::rt::Lazy<ClientDownloadRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadRequest::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest {
    fn clear(&mut self) {
        self.url.clear();
        self.digests.clear();
        self.length = ::std::option::Option::None;
        self.resources.clear();
        self.signature.clear();
        self.userInitiated = ::std::option::Option::None;
        self.clientAsn.clear();
        self.fileBasename.clear();
        self.downloadType = ::std::option::Option::None;
        self.locale.clear();
        self.apkInfo.clear();
        self.androidId = ::std::option::Option::None;
        self.originatingPackages.clear();
        self.originatingSignature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadRequest_ApkInfo {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadRequest_ApkInfo {
    pub fn new() -> ClientDownloadRequest_ApkInfo {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }
}

impl ::protobuf::Message for ClientDownloadRequest_ApkInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_ApkInfo {
        ClientDownloadRequest_ApkInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &ClientDownloadRequest_ApkInfo| { &m.packageName },
                |m: &mut ClientDownloadRequest_ApkInfo| { &mut m.packageName },
                ClientDownloadRequest_ApkInfo::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &ClientDownloadRequest_ApkInfo| { &m.versionCode },
                |m: &mut ClientDownloadRequest_ApkInfo| { &mut m.versionCode },
                ClientDownloadRequest_ApkInfo::get_versionCode,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadRequest_ApkInfo>(
                "ClientDownloadRequest_ApkInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_ApkInfo {
        static instance: ::protobuf::rt::Lazy<ClientDownloadRequest_ApkInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadRequest_ApkInfo::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_ApkInfo {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_ApkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_ApkInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadRequest_CertificateChain {
    // message fields
    pub element: ::protobuf::RepeatedField<ClientDownloadRequest_CertificateChain_Element>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadRequest_CertificateChain {
    pub fn new() -> ClientDownloadRequest_CertificateChain {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClientDownloadRequest_CertificateChain {
    fn is_initialized(&self) -> bool {
        for v in &self.element {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.element)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.element {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.element {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_CertificateChain {
        ClientDownloadRequest_CertificateChain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_CertificateChain_Element>>(
                "element",
                |m: &ClientDownloadRequest_CertificateChain| { &m.element },
                |m: &mut ClientDownloadRequest_CertificateChain| { &mut m.element },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadRequest_CertificateChain>(
                "ClientDownloadRequest_CertificateChain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_CertificateChain {
        static instance: ::protobuf::rt::Lazy<ClientDownloadRequest_CertificateChain> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadRequest_CertificateChain::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_CertificateChain {
    fn clear(&mut self) {
        self.element.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_CertificateChain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_CertificateChain {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadRequest_CertificateChain_Element {
    // message fields
    pub certificate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub parsedSuccessfully: ::std::option::Option<bool>,
    pub subject: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub issuer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub fingerprint: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub expiryTime: ::std::option::Option<i64>,
    pub startTime: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadRequest_CertificateChain_Element {
    pub fn new() -> ClientDownloadRequest_CertificateChain_Element {
        ::std::default::Default::default()
    }

    // optional bytes certificate = 1;

    pub fn get_certificate(&self) -> &[u8] {
        match self.certificate.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bool parsedSuccessfully = 2;

    pub fn get_parsedSuccessfully(&self) -> bool {
        self.parsedSuccessfully.unwrap_or(false)
    }

    // optional bytes subject = 3;

    pub fn get_subject(&self) -> &[u8] {
        match self.subject.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bytes issuer = 4;

    pub fn get_issuer(&self) -> &[u8] {
        match self.issuer.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bytes fingerprint = 5;

    pub fn get_fingerprint(&self) -> &[u8] {
        match self.fingerprint.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional int64 expiryTime = 6;

    pub fn get_expiryTime(&self) -> i64 {
        self.expiryTime.unwrap_or(0)
    }

    // optional int64 startTime = 7;

    pub fn get_startTime(&self) -> i64 {
        self.startTime.unwrap_or(0)
    }
}

impl ::protobuf::Message for ClientDownloadRequest_CertificateChain_Element {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.certificate)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.parsedSuccessfully = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.subject)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.issuer)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.fingerprint)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiryTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.certificate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.parsedSuccessfully {
            my_size += 2;
        }
        if let Some(v) = self.subject.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.issuer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.fingerprint.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.expiryTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startTime {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.certificate.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.parsedSuccessfully {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.subject.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.issuer.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.fingerprint.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.expiryTime {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.startTime {
            os.write_int64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_CertificateChain_Element {
        ClientDownloadRequest_CertificateChain_Element::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "certificate",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.certificate },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.certificate },
                ClientDownloadRequest_CertificateChain_Element::get_certificate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "parsedSuccessfully",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.parsedSuccessfully },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.parsedSuccessfully },
                ClientDownloadRequest_CertificateChain_Element::get_parsedSuccessfully,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "subject",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.subject },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.subject },
                ClientDownloadRequest_CertificateChain_Element::get_subject,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "issuer",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.issuer },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.issuer },
                ClientDownloadRequest_CertificateChain_Element::get_issuer,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "fingerprint",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.fingerprint },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.fingerprint },
                ClientDownloadRequest_CertificateChain_Element::get_fingerprint,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "expiryTime",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.expiryTime },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.expiryTime },
                ClientDownloadRequest_CertificateChain_Element::get_expiryTime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "startTime",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.startTime },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.startTime },
                ClientDownloadRequest_CertificateChain_Element::get_startTime,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadRequest_CertificateChain_Element>(
                "ClientDownloadRequest_CertificateChain_Element",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_CertificateChain_Element {
        static instance: ::protobuf::rt::Lazy<ClientDownloadRequest_CertificateChain_Element> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadRequest_CertificateChain_Element::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_CertificateChain_Element {
    fn clear(&mut self) {
        self.certificate.clear();
        self.parsedSuccessfully = ::std::option::Option::None;
        self.subject.clear();
        self.issuer.clear();
        self.fingerprint.clear();
        self.expiryTime = ::std::option::Option::None;
        self.startTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_CertificateChain_Element {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_CertificateChain_Element {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadRequest_Digests {
    // message fields
    pub sha256: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub sha1: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub md5: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadRequest_Digests {
    pub fn new() -> ClientDownloadRequest_Digests {
        ::std::default::Default::default()
    }

    // optional bytes sha256 = 1;

    pub fn get_sha256(&self) -> &[u8] {
        match self.sha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bytes sha1 = 2;

    pub fn get_sha1(&self) -> &[u8] {
        match self.sha1.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bytes md5 = 3;

    pub fn get_md5(&self) -> &[u8] {
        match self.md5.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ClientDownloadRequest_Digests {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha256)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.md5)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.sha1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.md5.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sha256.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.sha1.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.md5.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_Digests {
        ClientDownloadRequest_Digests::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "sha256",
                |m: &ClientDownloadRequest_Digests| { &m.sha256 },
                |m: &mut ClientDownloadRequest_Digests| { &mut m.sha256 },
                ClientDownloadRequest_Digests::get_sha256,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "sha1",
                |m: &ClientDownloadRequest_Digests| { &m.sha1 },
                |m: &mut ClientDownloadRequest_Digests| { &mut m.sha1 },
                ClientDownloadRequest_Digests::get_sha1,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "md5",
                |m: &ClientDownloadRequest_Digests| { &m.md5 },
                |m: &mut ClientDownloadRequest_Digests| { &mut m.md5 },
                ClientDownloadRequest_Digests::get_md5,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadRequest_Digests>(
                "ClientDownloadRequest_Digests",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_Digests {
        static instance: ::protobuf::rt::Lazy<ClientDownloadRequest_Digests> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadRequest_Digests::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_Digests {
    fn clear(&mut self) {
        self.sha256.clear();
        self.sha1.clear();
        self.md5.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_Digests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_Digests {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadRequest_Resource {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub field_type: ::std::option::Option<i32>,
    pub remoteIp: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub referrer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadRequest_Resource {
    pub fn new() -> ClientDownloadRequest_Resource {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 type = 2;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional bytes remoteIp = 3;

    pub fn get_remoteIp(&self) -> &[u8] {
        match self.remoteIp.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional string referrer = 4;

    pub fn get_referrer(&self) -> &str {
        match self.referrer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClientDownloadRequest_Resource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.remoteIp)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remoteIp.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.referrer.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.remoteIp.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.referrer.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_Resource {
        ClientDownloadRequest_Resource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &ClientDownloadRequest_Resource| { &m.url },
                |m: &mut ClientDownloadRequest_Resource| { &mut m.url },
                ClientDownloadRequest_Resource::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &ClientDownloadRequest_Resource| { &m.field_type },
                |m: &mut ClientDownloadRequest_Resource| { &mut m.field_type },
                ClientDownloadRequest_Resource::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "remoteIp",
                |m: &ClientDownloadRequest_Resource| { &m.remoteIp },
                |m: &mut ClientDownloadRequest_Resource| { &mut m.remoteIp },
                ClientDownloadRequest_Resource::get_remoteIp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "referrer",
                |m: &ClientDownloadRequest_Resource| { &m.referrer },
                |m: &mut ClientDownloadRequest_Resource| { &mut m.referrer },
                ClientDownloadRequest_Resource::get_referrer,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadRequest_Resource>(
                "ClientDownloadRequest_Resource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_Resource {
        static instance: ::protobuf::rt::Lazy<ClientDownloadRequest_Resource> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadRequest_Resource::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_Resource {
    fn clear(&mut self) {
        self.url.clear();
        self.field_type = ::std::option::Option::None;
        self.remoteIp.clear();
        self.referrer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_Resource {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadRequest_SignatureInfo {
    // message fields
    pub certificateChain: ::protobuf::RepeatedField<ClientDownloadRequest_CertificateChain>,
    pub trusted: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadRequest_SignatureInfo {
    pub fn new() -> ClientDownloadRequest_SignatureInfo {
        ::std::default::Default::default()
    }

    // optional bool trusted = 2;

    pub fn get_trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }
}

impl ::protobuf::Message for ClientDownloadRequest_SignatureInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.certificateChain {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.certificateChain)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trusted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.certificateChain {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.trusted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.certificateChain {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.trusted {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_SignatureInfo {
        ClientDownloadRequest_SignatureInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_CertificateChain>>(
                "certificateChain",
                |m: &ClientDownloadRequest_SignatureInfo| { &m.certificateChain },
                |m: &mut ClientDownloadRequest_SignatureInfo| { &mut m.certificateChain },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "trusted",
                |m: &ClientDownloadRequest_SignatureInfo| { &m.trusted },
                |m: &mut ClientDownloadRequest_SignatureInfo| { &mut m.trusted },
                ClientDownloadRequest_SignatureInfo::get_trusted,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadRequest_SignatureInfo>(
                "ClientDownloadRequest_SignatureInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_SignatureInfo {
        static instance: ::protobuf::rt::Lazy<ClientDownloadRequest_SignatureInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadRequest_SignatureInfo::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_SignatureInfo {
    fn clear(&mut self) {
        self.certificateChain.clear();
        self.trusted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_SignatureInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_SignatureInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadResponse {
    // message fields
    pub verdict: ::std::option::Option<i32>,
    pub moreInfo: ::protobuf::SingularPtrField<ClientDownloadResponse_MoreInfo>,
    pub token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadResponse {
    pub fn new() -> ClientDownloadResponse {
        ::std::default::Default::default()
    }

    // optional int32 verdict = 1;

    pub fn get_verdict(&self) -> i32 {
        self.verdict.unwrap_or(0)
    }

    // optional bytes token = 3;

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ClientDownloadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.moreInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.verdict = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ClientDownloadResponse_MoreInfo, _>(wire_type, is, &mut self.moreInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.verdict {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.moreInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.verdict {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.moreInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadResponse {
        ClientDownloadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "verdict",
                |m: &ClientDownloadResponse| { &m.verdict },
                |m: &mut ClientDownloadResponse| { &mut m.verdict },
                ClientDownloadResponse::get_verdict,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadResponse_MoreInfo>, _>(
                "moreInfo",
                |m: &ClientDownloadResponse| { &m.moreInfo },
                |m: &mut ClientDownloadResponse| { &mut m.moreInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "token",
                |m: &ClientDownloadResponse| { &m.token },
                |m: &mut ClientDownloadResponse| { &mut m.token },
                ClientDownloadResponse::get_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadResponse>(
                "ClientDownloadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadResponse {
        static instance: ::protobuf::rt::Lazy<ClientDownloadResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadResponse::new)
    }
}

impl ::protobuf::Clear for ClientDownloadResponse {
    fn clear(&mut self) {
        self.verdict = ::std::option::Option::None;
        self.moreInfo.clear();
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadResponse_MoreInfo {
    // message fields
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadResponse_MoreInfo {
    pub fn new() -> ClientDownloadResponse_MoreInfo {
        ::std::default::Default::default()
    }

    // optional string description = 1;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string url = 2;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClientDownloadResponse_MoreInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadResponse_MoreInfo {
        ClientDownloadResponse_MoreInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "description",
                |m: &ClientDownloadResponse_MoreInfo| { &m.description },
                |m: &mut ClientDownloadResponse_MoreInfo| { &mut m.description },
                ClientDownloadResponse_MoreInfo::get_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &ClientDownloadResponse_MoreInfo| { &m.url },
                |m: &mut ClientDownloadResponse_MoreInfo| { &mut m.url },
                ClientDownloadResponse_MoreInfo::get_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadResponse_MoreInfo>(
                "ClientDownloadResponse_MoreInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadResponse_MoreInfo {
        static instance: ::protobuf::rt::Lazy<ClientDownloadResponse_MoreInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadResponse_MoreInfo::new)
    }
}

impl ::protobuf::Clear for ClientDownloadResponse_MoreInfo {
    fn clear(&mut self) {
        self.description.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadResponse_MoreInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadResponse_MoreInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientDownloadStatsRequest {
    // message fields
    pub userDecision: ::std::option::Option<i32>,
    pub token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientDownloadStatsRequest {
    pub fn new() -> ClientDownloadStatsRequest {
        ::std::default::Default::default()
    }

    // optional int32 userDecision = 1;

    pub fn get_userDecision(&self) -> i32 {
        self.userDecision.unwrap_or(0)
    }

    // optional bytes token = 2;

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ClientDownloadStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.userDecision = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.userDecision {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.userDecision {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadStatsRequest {
        ClientDownloadStatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "userDecision",
                |m: &ClientDownloadStatsRequest| { &m.userDecision },
                |m: &mut ClientDownloadStatsRequest| { &mut m.userDecision },
                ClientDownloadStatsRequest::get_userDecision,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "token",
                |m: &ClientDownloadStatsRequest| { &m.token },
                |m: &mut ClientDownloadStatsRequest| { &mut m.token },
                ClientDownloadStatsRequest::get_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientDownloadStatsRequest>(
                "ClientDownloadStatsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadStatsRequest {
        static instance: ::protobuf::rt::Lazy<ClientDownloadStatsRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientDownloadStatsRequest::new)
    }
}

impl ::protobuf::Clear for ClientDownloadStatsRequest {
    fn clear(&mut self) {
        self.userDecision = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadStatsRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DebugInfo {
    // message fields
    pub message: ::protobuf::RepeatedField<::std::string::String>,
    // timing: <group>
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DebugInfo {
    pub fn new() -> DebugInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DebugInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.message {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.message {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugInfo {
        DebugInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &DebugInfo| { &m.message },
                |m: &mut DebugInfo| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DebugInfo>(
                "DebugInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugInfo {
        static instance: ::protobuf::rt::Lazy<DebugInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(DebugInfo::new)
    }
}

impl ::protobuf::Clear for DebugInfo {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DebugInfo_Timing {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub timeInMs: ::std::option::Option<f64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DebugInfo_Timing {
    pub fn new() -> DebugInfo_Timing {
        ::std::default::Default::default()
    }

    // optional string name = 3;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional double timeInMs = 4;

    pub fn get_timeInMs(&self) -> f64 {
        self.timeInMs.unwrap_or(0.)
    }
}

impl ::protobuf::Message for DebugInfo_Timing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.timeInMs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timeInMs {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.timeInMs {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugInfo_Timing {
        DebugInfo_Timing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &DebugInfo_Timing| { &m.name },
                |m: &mut DebugInfo_Timing| { &mut m.name },
                DebugInfo_Timing::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeDouble, _>(
                "timeInMs",
                |m: &DebugInfo_Timing| { &m.timeInMs },
                |m: &mut DebugInfo_Timing| { &mut m.timeInMs },
                DebugInfo_Timing::get_timeInMs,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DebugInfo_Timing>(
                "DebugInfo_Timing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugInfo_Timing {
        static instance: ::protobuf::rt::Lazy<DebugInfo_Timing> = ::protobuf::rt::Lazy::INIT;
        instance.get(DebugInfo_Timing::new)
    }
}

impl ::protobuf::Clear for DebugInfo_Timing {
    fn clear(&mut self) {
        self.name.clear();
        self.timeInMs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugInfo_Timing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugInfo_Timing {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DebugSettingsResponse {
    // message fields
    pub playCountryOverride: ::protobuf::SingularField<::std::string::String>,
    pub playCountryDebugInfo: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DebugSettingsResponse {
    pub fn new() -> DebugSettingsResponse {
        ::std::default::Default::default()
    }

    // optional string playCountryOverride = 1;

    pub fn get_playCountryOverride(&self) -> &str {
        match self.playCountryOverride.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string playCountryDebugInfo = 2;

    pub fn get_playCountryDebugInfo(&self) -> &str {
        match self.playCountryDebugInfo.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DebugSettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.playCountryOverride)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.playCountryDebugInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.playCountryOverride.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.playCountryDebugInfo.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.playCountryOverride.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.playCountryDebugInfo.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugSettingsResponse {
        DebugSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "playCountryOverride",
                |m: &DebugSettingsResponse| { &m.playCountryOverride },
                |m: &mut DebugSettingsResponse| { &mut m.playCountryOverride },
                DebugSettingsResponse::get_playCountryOverride,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "playCountryDebugInfo",
                |m: &DebugSettingsResponse| { &m.playCountryDebugInfo },
                |m: &mut DebugSettingsResponse| { &mut m.playCountryDebugInfo },
                DebugSettingsResponse::get_playCountryDebugInfo,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DebugSettingsResponse>(
                "DebugSettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugSettingsResponse {
        static instance: ::protobuf::rt::Lazy<DebugSettingsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(DebugSettingsResponse::new)
    }
}

impl ::protobuf::Clear for DebugSettingsResponse {
    fn clear(&mut self) {
        self.playCountryOverride.clear();
        self.playCountryDebugInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSettingsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DeliveryResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DeliveryResponse {
    pub fn new() -> DeliveryResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;

    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }
}

impl ::protobuf::Message for DeliveryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<AndroidAppDeliveryData, _>(wire_type, is, &mut self.appDeliveryData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.appDeliveryData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeliveryResponse {
        DeliveryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "status",
                |m: &DeliveryResponse| { &m.status },
                |m: &mut DeliveryResponse| { &mut m.status },
                DeliveryResponse::get_status,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>, _>(
                "appDeliveryData",
                |m: &DeliveryResponse| { &m.appDeliveryData },
                |m: &mut DeliveryResponse| { &mut m.appDeliveryData },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DeliveryResponse>(
                "DeliveryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeliveryResponse {
        static instance: ::protobuf::rt::Lazy<DeliveryResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(DeliveryResponse::new)
    }
}

impl ::protobuf::Clear for DeliveryResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.appDeliveryData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeliveryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeliveryResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BulkDetailsEntry {
    // message fields
    pub doc: ::protobuf::SingularPtrField<DocV2>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BulkDetailsEntry {
    pub fn new() -> BulkDetailsEntry {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BulkDetailsEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<DocV2, _>(wire_type, is, &mut self.doc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.doc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.doc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsEntry {
        BulkDetailsEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>, _>(
                "doc",
                |m: &BulkDetailsEntry| { &m.doc },
                |m: &mut BulkDetailsEntry| { &mut m.doc },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BulkDetailsEntry>(
                "BulkDetailsEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsEntry {
        static instance: ::protobuf::rt::Lazy<BulkDetailsEntry> = ::protobuf::rt::Lazy::INIT;
        instance.get(BulkDetailsEntry::new)
    }
}

impl ::protobuf::Clear for BulkDetailsEntry {
    fn clear(&mut self) {
        self.doc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsEntry {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BulkDetailsRequest {
    // message fields
    pub docid: ::protobuf::RepeatedField<::std::string::String>,
    pub includeChildDocs: ::std::option::Option<bool>,
    pub includeDetails: ::std::option::Option<bool>,
    pub sourcePackageName: ::protobuf::SingularField<::std::string::String>,
    pub installedVersionCode: ::std::vec::Vec<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BulkDetailsRequest {
    pub fn new() -> BulkDetailsRequest {
        ::std::default::Default::default()
    }

    // optional bool includeChildDocs = 2;

    pub fn get_includeChildDocs(&self) -> bool {
        self.includeChildDocs.unwrap_or(false)
    }

    // optional bool includeDetails = 3;

    pub fn get_includeDetails(&self) -> bool {
        self.includeDetails.unwrap_or(false)
    }

    // optional string sourcePackageName = 4;

    pub fn get_sourcePackageName(&self) -> &str {
        match self.sourcePackageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BulkDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeChildDocs = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeDetails = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourcePackageName)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.installedVersionCode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.docid {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.includeChildDocs {
            my_size += 2;
        }
        if let Some(v) = self.includeDetails {
            my_size += 2;
        }
        if let Some(v) = self.sourcePackageName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.installedVersionCode {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.docid {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.includeChildDocs {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.includeDetails {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.sourcePackageName.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.installedVersionCode {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsRequest {
        BulkDetailsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docid",
                |m: &BulkDetailsRequest| { &m.docid },
                |m: &mut BulkDetailsRequest| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "includeChildDocs",
                |m: &BulkDetailsRequest| { &m.includeChildDocs },
                |m: &mut BulkDetailsRequest| { &mut m.includeChildDocs },
                BulkDetailsRequest::get_includeChildDocs,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "includeDetails",
                |m: &BulkDetailsRequest| { &m.includeDetails },
                |m: &mut BulkDetailsRequest| { &mut m.includeDetails },
                BulkDetailsRequest::get_includeDetails,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "sourcePackageName",
                |m: &BulkDetailsRequest| { &m.sourcePackageName },
                |m: &mut BulkDetailsRequest| { &mut m.sourcePackageName },
                BulkDetailsRequest::get_sourcePackageName,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "installedVersionCode",
                |m: &BulkDetailsRequest| { &m.installedVersionCode },
                |m: &mut BulkDetailsRequest| { &mut m.installedVersionCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BulkDetailsRequest>(
                "BulkDetailsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsRequest {
        static instance: ::protobuf::rt::Lazy<BulkDetailsRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(BulkDetailsRequest::new)
    }
}

impl ::protobuf::Clear for BulkDetailsRequest {
    fn clear(&mut self) {
        self.docid.clear();
        self.includeChildDocs = ::std::option::Option::None;
        self.includeDetails = ::std::option::Option::None;
        self.sourcePackageName.clear();
        self.installedVersionCode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BulkDetailsResponse {
    // message fields
    pub entry: ::protobuf::RepeatedField<BulkDetailsEntry>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BulkDetailsResponse {
    pub fn new() -> BulkDetailsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BulkDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsResponse {
        BulkDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulkDetailsEntry>>(
                "entry",
                |m: &BulkDetailsResponse| { &m.entry },
                |m: &mut BulkDetailsResponse| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BulkDetailsResponse>(
                "BulkDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsResponse {
        static instance: ::protobuf::rt::Lazy<BulkDetailsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(BulkDetailsResponse::new)
    }
}

impl ::protobuf::Clear for BulkDetailsResponse {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DetailsResponse {
    // message fields
    pub docV1: ::protobuf::SingularPtrField<DocV1>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub userReview: ::protobuf::SingularPtrField<Review>,
    pub docV2: ::protobuf::SingularPtrField<DocV2>,
    pub footerHtml: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub discoveryBadge: ::protobuf::RepeatedField<DiscoveryBadge>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DetailsResponse {
    pub fn new() -> DetailsResponse {
        ::std::default::Default::default()
    }

    // optional string analyticsCookie = 2;

    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string footerHtml = 5;

    pub fn get_footerHtml(&self) -> &str {
        match self.footerHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 6;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for DetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.docV1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userReview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docV2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discoveryBadge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<DocV1, _>(wire_type, is, &mut self.docV1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<Review, _>(wire_type, is, &mut self.userReview)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<DocV2, _>(wire_type, is, &mut self.docV2)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.discoveryBadge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.docV1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.userReview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.docV2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.footerHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        for value in &self.discoveryBadge {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.docV1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.analyticsCookie.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.userReview.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.docV2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.footerHtml.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(6, v)?;
        }
        for v in &self.discoveryBadge {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetailsResponse {
        DetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV1>, _>(
                "docV1",
                |m: &DetailsResponse| { &m.docV1 },
                |m: &mut DetailsResponse| { &mut m.docV1 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "analyticsCookie",
                |m: &DetailsResponse| { &m.analyticsCookie },
                |m: &mut DetailsResponse| { &mut m.analyticsCookie },
                DetailsResponse::get_analyticsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>, _>(
                "userReview",
                |m: &DetailsResponse| { &m.userReview },
                |m: &mut DetailsResponse| { &mut m.userReview },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>, _>(
                "docV2",
                |m: &DetailsResponse| { &m.docV2 },
                |m: &mut DetailsResponse| { &mut m.docV2 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "footerHtml",
                |m: &DetailsResponse| { &m.footerHtml },
                |m: &mut DetailsResponse| { &mut m.footerHtml },
                DetailsResponse::get_footerHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &DetailsResponse| { &m.serverLogsCookie },
                |m: &mut DetailsResponse| { &mut m.serverLogsCookie },
                DetailsResponse::get_serverLogsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveryBadge>>(
                "discoveryBadge",
                |m: &DetailsResponse| { &m.discoveryBadge },
                |m: &mut DetailsResponse| { &mut m.discoveryBadge },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DetailsResponse>(
                "DetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DetailsResponse {
        static instance: ::protobuf::rt::Lazy<DetailsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(DetailsResponse::new)
    }
}

impl ::protobuf::Clear for DetailsResponse {
    fn clear(&mut self) {
        self.docV1.clear();
        self.analyticsCookie.clear();
        self.userReview.clear();
        self.docV2.clear();
        self.footerHtml.clear();
        self.serverLogsCookie.clear();
        self.discoveryBadge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DiscoveryBadge {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    pub backgroundColor: ::std::option::Option<i32>,
    pub discoveryBadgeLink: ::protobuf::SingularPtrField<DiscoveryBadgeLink>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub isPlusOne: ::std::option::Option<bool>,
    pub aggregateRating: ::std::option::Option<f32>,
    pub userStarRating: ::std::option::Option<i32>,
    pub downloadCount: ::protobuf::SingularField<::std::string::String>,
    pub downloadUnits: ::protobuf::SingularField<::std::string::String>,
    pub contentDescription: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DiscoveryBadge {
    pub fn new() -> DiscoveryBadge {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 backgroundColor = 3;

    pub fn get_backgroundColor(&self) -> i32 {
        self.backgroundColor.unwrap_or(0)
    }

    // optional bytes serverLogsCookie = 5;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bool isPlusOne = 6;

    pub fn get_isPlusOne(&self) -> bool {
        self.isPlusOne.unwrap_or(false)
    }

    // optional float aggregateRating = 7;

    pub fn get_aggregateRating(&self) -> f32 {
        self.aggregateRating.unwrap_or(0.)
    }

    // optional int32 userStarRating = 8;

    pub fn get_userStarRating(&self) -> i32 {
        self.userStarRating.unwrap_or(0)
    }

    // optional string downloadCount = 9;

    pub fn get_downloadCount(&self) -> &str {
        match self.downloadCount.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string downloadUnits = 10;

    pub fn get_downloadUnits(&self) -> &str {
        match self.downloadUnits.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string contentDescription = 11;

    pub fn get_contentDescription(&self) -> &str {
        match self.contentDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DiscoveryBadge {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discoveryBadgeLink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Image, _>(wire_type, is, &mut self.image)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backgroundColor = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<DiscoveryBadgeLink, _>(wire_type, is, &mut self.discoveryBadgeLink)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isPlusOne = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.aggregateRating = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.userStarRating = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadCount)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUnits)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentDescription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.backgroundColor {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.discoveryBadgeLink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.isPlusOne {
            my_size += 2;
        }
        if let Some(v) = self.aggregateRating {
            my_size += 5;
        }
        if let Some(v) = self.userStarRating {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.downloadCount.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.downloadUnits.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.contentDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.backgroundColor {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.discoveryBadgeLink.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.isPlusOne {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.aggregateRating {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.userStarRating {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.downloadCount.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.downloadUnits.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.contentDescription.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscoveryBadge {
        DiscoveryBadge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &DiscoveryBadge| { &m.title },
                |m: &mut DiscoveryBadge| { &mut m.title },
                DiscoveryBadge::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>, _>(
                "image",
                |m: &DiscoveryBadge| { &m.image },
                |m: &mut DiscoveryBadge| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "backgroundColor",
                |m: &DiscoveryBadge| { &m.backgroundColor },
                |m: &mut DiscoveryBadge| { &mut m.backgroundColor },
                DiscoveryBadge::get_backgroundColor,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveryBadgeLink>, _>(
                "discoveryBadgeLink",
                |m: &DiscoveryBadge| { &m.discoveryBadgeLink },
                |m: &mut DiscoveryBadge| { &mut m.discoveryBadgeLink },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &DiscoveryBadge| { &m.serverLogsCookie },
                |m: &mut DiscoveryBadge| { &mut m.serverLogsCookie },
                DiscoveryBadge::get_serverLogsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "isPlusOne",
                |m: &DiscoveryBadge| { &m.isPlusOne },
                |m: &mut DiscoveryBadge| { &mut m.isPlusOne },
                DiscoveryBadge::get_isPlusOne,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeFloat, _>(
                "aggregateRating",
                |m: &DiscoveryBadge| { &m.aggregateRating },
                |m: &mut DiscoveryBadge| { &mut m.aggregateRating },
                DiscoveryBadge::get_aggregateRating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "userStarRating",
                |m: &DiscoveryBadge| { &m.userStarRating },
                |m: &mut DiscoveryBadge| { &mut m.userStarRating },
                DiscoveryBadge::get_userStarRating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadCount",
                |m: &DiscoveryBadge| { &m.downloadCount },
                |m: &mut DiscoveryBadge| { &mut m.downloadCount },
                DiscoveryBadge::get_downloadCount,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadUnits",
                |m: &DiscoveryBadge| { &m.downloadUnits },
                |m: &mut DiscoveryBadge| { &mut m.downloadUnits },
                DiscoveryBadge::get_downloadUnits,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contentDescription",
                |m: &DiscoveryBadge| { &m.contentDescription },
                |m: &mut DiscoveryBadge| { &mut m.contentDescription },
                DiscoveryBadge::get_contentDescription,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DiscoveryBadge>(
                "DiscoveryBadge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscoveryBadge {
        static instance: ::protobuf::rt::Lazy<DiscoveryBadge> = ::protobuf::rt::Lazy::INIT;
        instance.get(DiscoveryBadge::new)
    }
}

impl ::protobuf::Clear for DiscoveryBadge {
    fn clear(&mut self) {
        self.title.clear();
        self.image.clear();
        self.backgroundColor = ::std::option::Option::None;
        self.discoveryBadgeLink.clear();
        self.serverLogsCookie.clear();
        self.isPlusOne = ::std::option::Option::None;
        self.aggregateRating = ::std::option::Option::None;
        self.userStarRating = ::std::option::Option::None;
        self.downloadCount.clear();
        self.downloadUnits.clear();
        self.contentDescription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoveryBadge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoveryBadge {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DiscoveryBadgeLink {
    // message fields
    pub link: ::protobuf::SingularPtrField<Link>,
    pub userReviewsUrl: ::protobuf::SingularField<::std::string::String>,
    pub criticReviewsUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DiscoveryBadgeLink {
    pub fn new() -> DiscoveryBadgeLink {
        ::std::default::Default::default()
    }

    // optional string userReviewsUrl = 2;

    pub fn get_userReviewsUrl(&self) -> &str {
        match self.userReviewsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string criticReviewsUrl = 3;

    pub fn get_criticReviewsUrl(&self) -> &str {
        match self.criticReviewsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DiscoveryBadgeLink {
    fn is_initialized(&self) -> bool {
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Link, _>(wire_type, is, &mut self.link)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userReviewsUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.criticReviewsUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.userReviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.criticReviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.link.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.userReviewsUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.criticReviewsUrl.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscoveryBadgeLink {
        DiscoveryBadgeLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Link>, _>(
                "link",
                |m: &DiscoveryBadgeLink| { &m.link },
                |m: &mut DiscoveryBadgeLink| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userReviewsUrl",
                |m: &DiscoveryBadgeLink| { &m.userReviewsUrl },
                |m: &mut DiscoveryBadgeLink| { &mut m.userReviewsUrl },
                DiscoveryBadgeLink::get_userReviewsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "criticReviewsUrl",
                |m: &DiscoveryBadgeLink| { &m.criticReviewsUrl },
                |m: &mut DiscoveryBadgeLink| { &mut m.criticReviewsUrl },
                DiscoveryBadgeLink::get_criticReviewsUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DiscoveryBadgeLink>(
                "DiscoveryBadgeLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscoveryBadgeLink {
        static instance: ::protobuf::rt::Lazy<DiscoveryBadgeLink> = ::protobuf::rt::Lazy::INIT;
        instance.get(DiscoveryBadgeLink::new)
    }
}

impl ::protobuf::Clear for DiscoveryBadgeLink {
    fn clear(&mut self) {
        self.link.clear();
        self.userReviewsUrl.clear();
        self.criticReviewsUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoveryBadgeLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoveryBadgeLink {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DeviceConfigurationProto {
    // message fields
    pub touchScreen: ::std::option::Option<i32>,
    pub keyboard: ::std::option::Option<i32>,
    pub navigation: ::std::option::Option<i32>,
    pub screenLayout: ::std::option::Option<i32>,
    pub hasHardKeyboard: ::std::option::Option<bool>,
    pub hasFiveWayNavigation: ::std::option::Option<bool>,
    pub screenDensity: ::std::option::Option<i32>,
    pub glEsVersion: ::std::option::Option<i32>,
    pub systemSharedLibrary: ::protobuf::RepeatedField<::std::string::String>,
    pub systemAvailableFeature: ::protobuf::RepeatedField<::std::string::String>,
    pub nativePlatform: ::protobuf::RepeatedField<::std::string::String>,
    pub screenWidth: ::std::option::Option<i32>,
    pub screenHeight: ::std::option::Option<i32>,
    pub systemSupportedLocale: ::protobuf::RepeatedField<::std::string::String>,
    pub glExtension: ::protobuf::RepeatedField<::std::string::String>,
    pub deviceClass: ::std::option::Option<i32>,
    pub maxApkDownloadSizeMb: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceConfigurationProto {
    pub fn new() -> DeviceConfigurationProto {
        ::std::default::Default::default()
    }

    // optional int32 touchScreen = 1;

    pub fn get_touchScreen(&self) -> i32 {
        self.touchScreen.unwrap_or(0)
    }

    // optional int32 keyboard = 2;

    pub fn get_keyboard(&self) -> i32 {
        self.keyboard.unwrap_or(0)
    }

    // optional int32 navigation = 3;

    pub fn get_navigation(&self) -> i32 {
        self.navigation.unwrap_or(0)
    }

    // optional int32 screenLayout = 4;

    pub fn get_screenLayout(&self) -> i32 {
        self.screenLayout.unwrap_or(0)
    }

    // optional bool hasHardKeyboard = 5;

    pub fn get_hasHardKeyboard(&self) -> bool {
        self.hasHardKeyboard.unwrap_or(false)
    }

    // optional bool hasFiveWayNavigation = 6;

    pub fn get_hasFiveWayNavigation(&self) -> bool {
        self.hasFiveWayNavigation.unwrap_or(false)
    }

    // optional int32 screenDensity = 7;

    pub fn get_screenDensity(&self) -> i32 {
        self.screenDensity.unwrap_or(0)
    }

    // optional int32 glEsVersion = 8;

    pub fn get_glEsVersion(&self) -> i32 {
        self.glEsVersion.unwrap_or(0)
    }

    // optional int32 screenWidth = 12;

    pub fn get_screenWidth(&self) -> i32 {
        self.screenWidth.unwrap_or(0)
    }

    // optional int32 screenHeight = 13;

    pub fn get_screenHeight(&self) -> i32 {
        self.screenHeight.unwrap_or(0)
    }

    // optional int32 deviceClass = 16;

    pub fn get_deviceClass(&self) -> i32 {
        self.deviceClass.unwrap_or(0)
    }

    // optional int32 maxApkDownloadSizeMb = 17;

    pub fn get_maxApkDownloadSizeMb(&self) -> i32 {
        self.maxApkDownloadSizeMb.unwrap_or(0)
    }
}

impl ::protobuf::Message for DeviceConfigurationProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.touchScreen = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.keyboard = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.navigation = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenLayout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasHardKeyboard = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasFiveWayNavigation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenDensity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.glEsVersion = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemSharedLibrary)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemAvailableFeature)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.nativePlatform)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenWidth = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenHeight = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemSupportedLocale)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.glExtension)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceClass = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxApkDownloadSizeMb = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.touchScreen {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.keyboard {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.navigation {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenLayout {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hasHardKeyboard {
            my_size += 2;
        }
        if let Some(v) = self.hasFiveWayNavigation {
            my_size += 2;
        }
        if let Some(v) = self.screenDensity {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.glEsVersion {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.systemSharedLibrary {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.systemAvailableFeature {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.nativePlatform {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(v) = self.screenWidth {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenHeight {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.systemSupportedLocale {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.glExtension {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.deviceClass {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxApkDownloadSizeMb {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.touchScreen {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.keyboard {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.navigation {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.screenLayout {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hasHardKeyboard {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.hasFiveWayNavigation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.screenDensity {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.glEsVersion {
            os.write_int32(8, v)?;
        }
        for v in &self.systemSharedLibrary {
            os.write_string(9, &v)?;
        };
        for v in &self.systemAvailableFeature {
            os.write_string(10, &v)?;
        };
        for v in &self.nativePlatform {
            os.write_string(11, &v)?;
        };
        if let Some(v) = self.screenWidth {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.screenHeight {
            os.write_int32(13, v)?;
        }
        for v in &self.systemSupportedLocale {
            os.write_string(14, &v)?;
        };
        for v in &self.glExtension {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.deviceClass {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.maxApkDownloadSizeMb {
            os.write_int32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceConfigurationProto {
        DeviceConfigurationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "touchScreen",
                |m: &DeviceConfigurationProto| { &m.touchScreen },
                |m: &mut DeviceConfigurationProto| { &mut m.touchScreen },
                DeviceConfigurationProto::get_touchScreen,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "keyboard",
                |m: &DeviceConfigurationProto| { &m.keyboard },
                |m: &mut DeviceConfigurationProto| { &mut m.keyboard },
                DeviceConfigurationProto::get_keyboard,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "navigation",
                |m: &DeviceConfigurationProto| { &m.navigation },
                |m: &mut DeviceConfigurationProto| { &mut m.navigation },
                DeviceConfigurationProto::get_navigation,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "screenLayout",
                |m: &DeviceConfigurationProto| { &m.screenLayout },
                |m: &mut DeviceConfigurationProto| { &mut m.screenLayout },
                DeviceConfigurationProto::get_screenLayout,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "hasHardKeyboard",
                |m: &DeviceConfigurationProto| { &m.hasHardKeyboard },
                |m: &mut DeviceConfigurationProto| { &mut m.hasHardKeyboard },
                DeviceConfigurationProto::get_hasHardKeyboard,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "hasFiveWayNavigation",
                |m: &DeviceConfigurationProto| { &m.hasFiveWayNavigation },
                |m: &mut DeviceConfigurationProto| { &mut m.hasFiveWayNavigation },
                DeviceConfigurationProto::get_hasFiveWayNavigation,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "screenDensity",
                |m: &DeviceConfigurationProto| { &m.screenDensity },
                |m: &mut DeviceConfigurationProto| { &mut m.screenDensity },
                DeviceConfigurationProto::get_screenDensity,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "glEsVersion",
                |m: &DeviceConfigurationProto| { &m.glEsVersion },
                |m: &mut DeviceConfigurationProto| { &mut m.glEsVersion },
                DeviceConfigurationProto::get_glEsVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemSharedLibrary",
                |m: &DeviceConfigurationProto| { &m.systemSharedLibrary },
                |m: &mut DeviceConfigurationProto| { &mut m.systemSharedLibrary },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemAvailableFeature",
                |m: &DeviceConfigurationProto| { &m.systemAvailableFeature },
                |m: &mut DeviceConfigurationProto| { &mut m.systemAvailableFeature },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nativePlatform",
                |m: &DeviceConfigurationProto| { &m.nativePlatform },
                |m: &mut DeviceConfigurationProto| { &mut m.nativePlatform },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "screenWidth",
                |m: &DeviceConfigurationProto| { &m.screenWidth },
                |m: &mut DeviceConfigurationProto| { &mut m.screenWidth },
                DeviceConfigurationProto::get_screenWidth,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "screenHeight",
                |m: &DeviceConfigurationProto| { &m.screenHeight },
                |m: &mut DeviceConfigurationProto| { &mut m.screenHeight },
                DeviceConfigurationProto::get_screenHeight,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemSupportedLocale",
                |m: &DeviceConfigurationProto| { &m.systemSupportedLocale },
                |m: &mut DeviceConfigurationProto| { &mut m.systemSupportedLocale },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "glExtension",
                |m: &DeviceConfigurationProto| { &m.glExtension },
                |m: &mut DeviceConfigurationProto| { &mut m.glExtension },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "deviceClass",
                |m: &DeviceConfigurationProto| { &m.deviceClass },
                |m: &mut DeviceConfigurationProto| { &mut m.deviceClass },
                DeviceConfigurationProto::get_deviceClass,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "maxApkDownloadSizeMb",
                |m: &DeviceConfigurationProto| { &m.maxApkDownloadSizeMb },
                |m: &mut DeviceConfigurationProto| { &mut m.maxApkDownloadSizeMb },
                DeviceConfigurationProto::get_maxApkDownloadSizeMb,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DeviceConfigurationProto>(
                "DeviceConfigurationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceConfigurationProto {
        static instance: ::protobuf::rt::Lazy<DeviceConfigurationProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(DeviceConfigurationProto::new)
    }
}

impl ::protobuf::Clear for DeviceConfigurationProto {
    fn clear(&mut self) {
        self.touchScreen = ::std::option::Option::None;
        self.keyboard = ::std::option::Option::None;
        self.navigation = ::std::option::Option::None;
        self.screenLayout = ::std::option::Option::None;
        self.hasHardKeyboard = ::std::option::Option::None;
        self.hasFiveWayNavigation = ::std::option::Option::None;
        self.screenDensity = ::std::option::Option::None;
        self.glEsVersion = ::std::option::Option::None;
        self.systemSharedLibrary.clear();
        self.systemAvailableFeature.clear();
        self.nativePlatform.clear();
        self.screenWidth = ::std::option::Option::None;
        self.screenHeight = ::std::option::Option::None;
        self.systemSupportedLocale.clear();
        self.glExtension.clear();
        self.deviceClass = ::std::option::Option::None;
        self.maxApkDownloadSizeMb = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceConfigurationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceConfigurationProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Document {
    // message fields
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub fetchDocid: ::protobuf::SingularPtrField<Docid>,
    pub sampleDocid: ::protobuf::SingularPtrField<Docid>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub snippet: ::protobuf::RepeatedField<::std::string::String>,
    pub priceDeprecated: ::protobuf::SingularPtrField<Offer>,
    pub availability: ::protobuf::SingularPtrField<Availability>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub child: ::protobuf::RepeatedField<Document>,
    pub aggregateRating: ::protobuf::SingularPtrField<AggregateRating>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub translatedSnippet: ::protobuf::RepeatedField<TranslatedText>,
    pub documentVariant: ::protobuf::RepeatedField<DocumentVariant>,
    pub categoryId: ::protobuf::RepeatedField<::std::string::String>,
    pub decoration: ::protobuf::RepeatedField<Document>,
    pub parent: ::protobuf::RepeatedField<Document>,
    pub privacyPolicyUrl: ::protobuf::SingularField<::std::string::String>,
    pub consumptionUrl: ::protobuf::SingularField<::std::string::String>,
    pub estimatedNumChildren: ::std::option::Option<i32>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // optional string title = 4;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string url = 5;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string privacyPolicyUrl = 20;

    pub fn get_privacyPolicyUrl(&self) -> &str {
        match self.privacyPolicyUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string consumptionUrl = 21;

    pub fn get_consumptionUrl(&self) -> &str {
        match self.consumptionUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 estimatedNumChildren = 22;

    pub fn get_estimatedNumChildren(&self) -> i32 {
        self.estimatedNumChildren.unwrap_or(0)
    }

    // optional string subtitle = 23;

    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fetchDocid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sampleDocid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.priceDeprecated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregateRating {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translatedSnippet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.documentVariant {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decoration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.fetchDocid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.sampleDocid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.snippet)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<Offer, _>(wire_type, is, &mut self.priceDeprecated)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<Availability, _>(wire_type, is, &mut self.availability)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.image)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.child)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<AggregateRating, _>(wire_type, is, &mut self.aggregateRating)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.offer)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.translatedSnippet)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.documentVariant)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.categoryId)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.decoration)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.parent)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.privacyPolicyUrl)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.consumptionUrl)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimatedNumChildren = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fetchDocid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sampleDocid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.snippet {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.priceDeprecated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.availability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.aggregateRating.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.translatedSnippet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.documentVariant {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.categoryId {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.decoration {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.parent {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.privacyPolicyUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.consumptionUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.estimatedNumChildren {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.docid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.fetchDocid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.sampleDocid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.snippet {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.priceDeprecated.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.availability.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.image {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.child {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.aggregateRating.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        for v in &self.offer {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.translatedSnippet {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.documentVariant {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.categoryId {
            os.write_string(17, &v)?;
        };
        for v in &self.decoration {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        for v in &self.parent {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        if let Some(v) = self.privacyPolicyUrl.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.consumptionUrl.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.estimatedNumChildren {
            os.write_int32(22, v)?;
        }
        if let Some(v) = self.subtitle.as_ref() {
            os.write_string(23, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "docid",
                |m: &Document| { &m.docid },
                |m: &mut Document| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "fetchDocid",
                |m: &Document| { &m.fetchDocid },
                |m: &mut Document| { &mut m.fetchDocid },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "sampleDocid",
                |m: &Document| { &m.sampleDocid },
                |m: &mut Document| { &mut m.sampleDocid },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &Document| { &m.title },
                |m: &mut Document| { &mut m.title },
                Document::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &Document| { &m.url },
                |m: &mut Document| { &mut m.url },
                Document::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snippet",
                |m: &Document| { &m.snippet },
                |m: &mut Document| { &mut m.snippet },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>, _>(
                "priceDeprecated",
                |m: &Document| { &m.priceDeprecated },
                |m: &mut Document| { &mut m.priceDeprecated },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Availability>, _>(
                "availability",
                |m: &Document| { &m.availability },
                |m: &mut Document| { &mut m.availability },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Document| { &m.image },
                |m: &mut Document| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "child",
                |m: &Document| { &m.child },
                |m: &mut Document| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AggregateRating>, _>(
                "aggregateRating",
                |m: &Document| { &m.aggregateRating },
                |m: &mut Document| { &mut m.aggregateRating },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &Document| { &m.offer },
                |m: &mut Document| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TranslatedText>>(
                "translatedSnippet",
                |m: &Document| { &m.translatedSnippet },
                |m: &mut Document| { &mut m.translatedSnippet },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentVariant>>(
                "documentVariant",
                |m: &Document| { &m.documentVariant },
                |m: &mut Document| { &mut m.documentVariant },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryId",
                |m: &Document| { &m.categoryId },
                |m: &mut Document| { &mut m.categoryId },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "decoration",
                |m: &Document| { &m.decoration },
                |m: &mut Document| { &mut m.decoration },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "parent",
                |m: &Document| { &m.parent },
                |m: &mut Document| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "privacyPolicyUrl",
                |m: &Document| { &m.privacyPolicyUrl },
                |m: &mut Document| { &mut m.privacyPolicyUrl },
                Document::get_privacyPolicyUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "consumptionUrl",
                |m: &Document| { &m.consumptionUrl },
                |m: &mut Document| { &mut m.consumptionUrl },
                Document::get_consumptionUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "estimatedNumChildren",
                |m: &Document| { &m.estimatedNumChildren },
                |m: &mut Document| { &mut m.estimatedNumChildren },
                Document::get_estimatedNumChildren,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subtitle",
                |m: &Document| { &m.subtitle },
                |m: &mut Document| { &mut m.subtitle },
                Document::get_subtitle,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Document>(
                "Document",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Document {
        static instance: ::protobuf::rt::Lazy<Document> = ::protobuf::rt::Lazy::INIT;
        instance.get(Document::new)
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.docid.clear();
        self.fetchDocid.clear();
        self.sampleDocid.clear();
        self.title.clear();
        self.url.clear();
        self.snippet.clear();
        self.priceDeprecated.clear();
        self.availability.clear();
        self.image.clear();
        self.child.clear();
        self.aggregateRating.clear();
        self.offer.clear();
        self.translatedSnippet.clear();
        self.documentVariant.clear();
        self.categoryId.clear();
        self.decoration.clear();
        self.parent.clear();
        self.privacyPolicyUrl.clear();
        self.consumptionUrl.clear();
        self.estimatedNumChildren = ::std::option::Option::None;
        self.subtitle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DocumentVariant {
    // message fields
    pub variationType: ::std::option::Option<i32>,
    pub rule: ::protobuf::SingularPtrField<Rule>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub snippet: ::protobuf::RepeatedField<::std::string::String>,
    pub recentChanges: ::protobuf::SingularField<::std::string::String>,
    pub autoTranslation: ::protobuf::RepeatedField<TranslatedText>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub channelId: ::std::option::Option<i64>,
    pub child: ::protobuf::RepeatedField<Document>,
    pub decoration: ::protobuf::RepeatedField<Document>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub categoryId: ::protobuf::RepeatedField<::std::string::String>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DocumentVariant {
    pub fn new() -> DocumentVariant {
        ::std::default::Default::default()
    }

    // optional int32 variationType = 1;

    pub fn get_variationType(&self) -> i32 {
        self.variationType.unwrap_or(0)
    }

    // optional string title = 3;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string recentChanges = 5;

    pub fn get_recentChanges(&self) -> &str {
        match self.recentChanges.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 channelId = 9;

    pub fn get_channelId(&self) -> i64 {
        self.channelId.unwrap_or(0)
    }

    // optional string subtitle = 14;

    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DocumentVariant {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.autoTranslation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decoration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.variationType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Rule, _>(wire_type, is, &mut self.rule)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.snippet)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recentChanges)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.autoTranslation)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.offer)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.channelId = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.child)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.decoration)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.image)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.categoryId)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.variationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.snippet {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.recentChanges.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.autoTranslation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.channelId {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.decoration {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.categoryId {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.variationType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rule.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.snippet {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.recentChanges.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.autoTranslation {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.offer {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.channelId {
            os.write_int64(9, v)?;
        }
        for v in &self.child {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.decoration {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.image {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.categoryId {
            os.write_string(13, &v)?;
        };
        if let Some(v) = self.subtitle.as_ref() {
            os.write_string(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentVariant {
        DocumentVariant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "variationType",
                |m: &DocumentVariant| { &m.variationType },
                |m: &mut DocumentVariant| { &mut m.variationType },
                DocumentVariant::get_variationType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>, _>(
                "rule",
                |m: &DocumentVariant| { &m.rule },
                |m: &mut DocumentVariant| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &DocumentVariant| { &m.title },
                |m: &mut DocumentVariant| { &mut m.title },
                DocumentVariant::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snippet",
                |m: &DocumentVariant| { &m.snippet },
                |m: &mut DocumentVariant| { &mut m.snippet },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "recentChanges",
                |m: &DocumentVariant| { &m.recentChanges },
                |m: &mut DocumentVariant| { &mut m.recentChanges },
                DocumentVariant::get_recentChanges,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TranslatedText>>(
                "autoTranslation",
                |m: &DocumentVariant| { &m.autoTranslation },
                |m: &mut DocumentVariant| { &mut m.autoTranslation },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &DocumentVariant| { &m.offer },
                |m: &mut DocumentVariant| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "channelId",
                |m: &DocumentVariant| { &m.channelId },
                |m: &mut DocumentVariant| { &mut m.channelId },
                DocumentVariant::get_channelId,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "child",
                |m: &DocumentVariant| { &m.child },
                |m: &mut DocumentVariant| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "decoration",
                |m: &DocumentVariant| { &m.decoration },
                |m: &mut DocumentVariant| { &mut m.decoration },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &DocumentVariant| { &m.image },
                |m: &mut DocumentVariant| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryId",
                |m: &DocumentVariant| { &m.categoryId },
                |m: &mut DocumentVariant| { &mut m.categoryId },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subtitle",
                |m: &DocumentVariant| { &m.subtitle },
                |m: &mut DocumentVariant| { &mut m.subtitle },
                DocumentVariant::get_subtitle,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DocumentVariant>(
                "DocumentVariant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentVariant {
        static instance: ::protobuf::rt::Lazy<DocumentVariant> = ::protobuf::rt::Lazy::INIT;
        instance.get(DocumentVariant::new)
    }
}

impl ::protobuf::Clear for DocumentVariant {
    fn clear(&mut self) {
        self.variationType = ::std::option::Option::None;
        self.rule.clear();
        self.title.clear();
        self.snippet.clear();
        self.recentChanges.clear();
        self.autoTranslation.clear();
        self.offer.clear();
        self.channelId = ::std::option::Option::None;
        self.child.clear();
        self.decoration.clear();
        self.image.clear();
        self.categoryId.clear();
        self.subtitle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentVariant {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Image {
    // message fields
    pub imageType: ::std::option::Option<i32>,
    // dimension: <group>
    pub imageUrl: ::protobuf::SingularField<::std::string::String>,
    pub altTextLocalized: ::protobuf::SingularField<::std::string::String>,
    pub secureUrl: ::protobuf::SingularField<::std::string::String>,
    pub positionInSequence: ::std::option::Option<i32>,
    pub supportsFifeUrlOptions: ::std::option::Option<bool>,
    // citation: <group>
    pub durationSeconds: ::std::option::Option<i32>,
    pub fillColorRgb: ::protobuf::SingularField<::std::string::String>,
    pub autogen: ::std::option::Option<bool>,
    pub attribution: ::protobuf::SingularPtrField<Attribution>,
    pub backgroundColorRgb: ::protobuf::SingularField<::std::string::String>,
    pub palette: ::protobuf::SingularPtrField<ImagePalette>,
    pub deviceClass: ::std::option::Option<i32>,
    pub supportsFifeMonogramOption: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // optional int32 imageType = 1;

    pub fn get_imageType(&self) -> i32 {
        self.imageType.unwrap_or(0)
    }

    // optional string imageUrl = 5;

    pub fn get_imageUrl(&self) -> &str {
        match self.imageUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string altTextLocalized = 6;

    pub fn get_altTextLocalized(&self) -> &str {
        match self.altTextLocalized.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string secureUrl = 7;

    pub fn get_secureUrl(&self) -> &str {
        match self.secureUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 positionInSequence = 8;

    pub fn get_positionInSequence(&self) -> i32 {
        self.positionInSequence.unwrap_or(0)
    }

    // optional bool supportsFifeUrlOptions = 9;

    pub fn get_supportsFifeUrlOptions(&self) -> bool {
        self.supportsFifeUrlOptions.unwrap_or(false)
    }

    // optional int32 durationSeconds = 14;

    pub fn get_durationSeconds(&self) -> i32 {
        self.durationSeconds.unwrap_or(0)
    }

    // optional string fillColorRgb = 15;

    pub fn get_fillColorRgb(&self) -> &str {
        match self.fillColorRgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool autogen = 16;

    pub fn get_autogen(&self) -> bool {
        self.autogen.unwrap_or(false)
    }

    // optional string backgroundColorRgb = 19;

    pub fn get_backgroundColorRgb(&self) -> &str {
        match self.backgroundColorRgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 deviceClass = 21;

    pub fn get_deviceClass(&self) -> i32 {
        self.deviceClass.unwrap_or(0)
    }

    // optional bool supportsFifeMonogramOption = 22;

    pub fn get_supportsFifeMonogramOption(&self) -> bool {
        self.supportsFifeMonogramOption.unwrap_or(false)
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        for v in &self.attribution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.palette {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.imageType = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imageUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.altTextLocalized)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secureUrl)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.positionInSequence = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportsFifeUrlOptions = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.durationSeconds = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fillColorRgb)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autogen = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<Attribution, _>(wire_type, is, &mut self.attribution)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backgroundColorRgb)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into::<ImagePalette, _>(wire_type, is, &mut self.palette)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceClass = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportsFifeMonogramOption = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.imageType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.imageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.altTextLocalized.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.secureUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.positionInSequence {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supportsFifeUrlOptions {
            my_size += 2;
        }
        if let Some(v) = self.durationSeconds {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fillColorRgb.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.autogen {
            my_size += 3;
        }
        if let Some(v) = self.attribution.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.backgroundColorRgb.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.palette.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deviceClass {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supportsFifeMonogramOption {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.imageType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.imageUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.altTextLocalized.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.secureUrl.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.positionInSequence {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.supportsFifeUrlOptions {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.durationSeconds {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.fillColorRgb.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.autogen {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.attribution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.backgroundColorRgb.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.palette.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.deviceClass {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.supportsFifeMonogramOption {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "imageType",
                |m: &Image| { &m.imageType },
                |m: &mut Image| { &mut m.imageType },
                Image::get_imageType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "imageUrl",
                |m: &Image| { &m.imageUrl },
                |m: &mut Image| { &mut m.imageUrl },
                Image::get_imageUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "altTextLocalized",
                |m: &Image| { &m.altTextLocalized },
                |m: &mut Image| { &mut m.altTextLocalized },
                Image::get_altTextLocalized,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "secureUrl",
                |m: &Image| { &m.secureUrl },
                |m: &mut Image| { &mut m.secureUrl },
                Image::get_secureUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "positionInSequence",
                |m: &Image| { &m.positionInSequence },
                |m: &mut Image| { &mut m.positionInSequence },
                Image::get_positionInSequence,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "supportsFifeUrlOptions",
                |m: &Image| { &m.supportsFifeUrlOptions },
                |m: &mut Image| { &mut m.supportsFifeUrlOptions },
                Image::get_supportsFifeUrlOptions,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "durationSeconds",
                |m: &Image| { &m.durationSeconds },
                |m: &mut Image| { &mut m.durationSeconds },
                Image::get_durationSeconds,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "fillColorRgb",
                |m: &Image| { &m.fillColorRgb },
                |m: &mut Image| { &mut m.fillColorRgb },
                Image::get_fillColorRgb,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "autogen",
                |m: &Image| { &m.autogen },
                |m: &mut Image| { &mut m.autogen },
                Image::get_autogen,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attribution>, _>(
                "attribution",
                |m: &Image| { &m.attribution },
                |m: &mut Image| { &mut m.attribution },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "backgroundColorRgb",
                |m: &Image| { &m.backgroundColorRgb },
                |m: &mut Image| { &mut m.backgroundColorRgb },
                Image::get_backgroundColorRgb,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImagePalette>, _>(
                "palette",
                |m: &Image| { &m.palette },
                |m: &mut Image| { &mut m.palette },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "deviceClass",
                |m: &Image| { &m.deviceClass },
                |m: &mut Image| { &mut m.deviceClass },
                Image::get_deviceClass,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "supportsFifeMonogramOption",
                |m: &Image| { &m.supportsFifeMonogramOption },
                |m: &mut Image| { &mut m.supportsFifeMonogramOption },
                Image::get_supportsFifeMonogramOption,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Image>(
                "Image",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image {
        static instance: ::protobuf::rt::Lazy<Image> = ::protobuf::rt::Lazy::INIT;
        instance.get(Image::new)
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.imageType = ::std::option::Option::None;
        self.imageUrl.clear();
        self.altTextLocalized.clear();
        self.secureUrl.clear();
        self.positionInSequence = ::std::option::Option::None;
        self.supportsFifeUrlOptions = ::std::option::Option::None;
        self.durationSeconds = ::std::option::Option::None;
        self.fillColorRgb.clear();
        self.autogen = ::std::option::Option::None;
        self.attribution.clear();
        self.backgroundColorRgb.clear();
        self.palette.clear();
        self.deviceClass = ::std::option::Option::None;
        self.supportsFifeMonogramOption = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Image_Dimension {
    // message fields
    pub width: ::std::option::Option<i32>,
    pub height: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Image_Dimension {
    pub fn new() -> Image_Dimension {
        ::std::default::Default::default()
    }

    // optional int32 width = 3;

    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    // optional int32 height = 4;

    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
}

impl ::protobuf::Message for Image_Dimension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image_Dimension {
        Image_Dimension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "width",
                |m: &Image_Dimension| { &m.width },
                |m: &mut Image_Dimension| { &mut m.width },
                Image_Dimension::get_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "height",
                |m: &Image_Dimension| { &m.height },
                |m: &mut Image_Dimension| { &mut m.height },
                Image_Dimension::get_height,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Image_Dimension>(
                "Image_Dimension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image_Dimension {
        static instance: ::protobuf::rt::Lazy<Image_Dimension> = ::protobuf::rt::Lazy::INIT;
        instance.get(Image_Dimension::new)
    }
}

impl ::protobuf::Clear for Image_Dimension {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image_Dimension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Dimension {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Image_Citation {
    // message fields
    pub titleLocalized: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Image_Citation {
    pub fn new() -> Image_Citation {
        ::std::default::Default::default()
    }

    // optional string titleLocalized = 11;

    pub fn get_titleLocalized(&self) -> &str {
        match self.titleLocalized.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string url = 12;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Image_Citation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.titleLocalized)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.titleLocalized.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.titleLocalized.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image_Citation {
        Image_Citation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "titleLocalized",
                |m: &Image_Citation| { &m.titleLocalized },
                |m: &mut Image_Citation| { &mut m.titleLocalized },
                Image_Citation::get_titleLocalized,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &Image_Citation| { &m.url },
                |m: &mut Image_Citation| { &mut m.url },
                Image_Citation::get_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Image_Citation>(
                "Image_Citation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image_Citation {
        static instance: ::protobuf::rt::Lazy<Image_Citation> = ::protobuf::rt::Lazy::INIT;
        instance.get(Image_Citation::new)
    }
}

impl ::protobuf::Clear for Image_Citation {
    fn clear(&mut self) {
        self.titleLocalized.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image_Citation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Citation {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ImagePalette {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ImagePalette {
    pub fn new() -> ImagePalette {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ImagePalette {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImagePalette {
        ImagePalette::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<ImagePalette>(
                "ImagePalette",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImagePalette {
        static instance: ::protobuf::rt::Lazy<ImagePalette> = ::protobuf::rt::Lazy::INIT;
        instance.get(ImagePalette::new)
    }
}

impl ::protobuf::Clear for ImagePalette {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImagePalette {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImagePalette {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Attribution {
    // message fields
    pub sourceTitle: ::protobuf::SingularField<::std::string::String>,
    pub sourceUrl: ::protobuf::SingularField<::std::string::String>,
    pub licenseTitle: ::protobuf::SingularField<::std::string::String>,
    pub licenseUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Attribution {
    pub fn new() -> Attribution {
        ::std::default::Default::default()
    }

    // optional string sourceTitle = 1;

    pub fn get_sourceTitle(&self) -> &str {
        match self.sourceTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string sourceUrl = 2;

    pub fn get_sourceUrl(&self) -> &str {
        match self.sourceUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string licenseTitle = 3;

    pub fn get_licenseTitle(&self) -> &str {
        match self.licenseTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string licenseUrl = 4;

    pub fn get_licenseUrl(&self) -> &str {
        match self.licenseUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Attribution {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.licenseTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.licenseUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sourceTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sourceUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.licenseTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.licenseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sourceTitle.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sourceUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.licenseTitle.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.licenseUrl.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribution {
        Attribution::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "sourceTitle",
                |m: &Attribution| { &m.sourceTitle },
                |m: &mut Attribution| { &mut m.sourceTitle },
                Attribution::get_sourceTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "sourceUrl",
                |m: &Attribution| { &m.sourceUrl },
                |m: &mut Attribution| { &mut m.sourceUrl },
                Attribution::get_sourceUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "licenseTitle",
                |m: &Attribution| { &m.licenseTitle },
                |m: &mut Attribution| { &mut m.licenseTitle },
                Attribution::get_licenseTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "licenseUrl",
                |m: &Attribution| { &m.licenseUrl },
                |m: &mut Attribution| { &mut m.licenseUrl },
                Attribution::get_licenseUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Attribution>(
                "Attribution",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Attribution {
        static instance: ::protobuf::rt::Lazy<Attribution> = ::protobuf::rt::Lazy::INIT;
        instance.get(Attribution::new)
    }
}

impl ::protobuf::Clear for Attribution {
    fn clear(&mut self) {
        self.sourceTitle.clear();
        self.sourceUrl.clear();
        self.licenseTitle.clear();
        self.licenseUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribution {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct TranslatedText {
    // message fields
    pub text: ::protobuf::SingularField<::std::string::String>,
    pub sourceLocale: ::protobuf::SingularField<::std::string::String>,
    pub targetLocale: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl TranslatedText {
    pub fn new() -> TranslatedText {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string sourceLocale = 2;

    pub fn get_sourceLocale(&self) -> &str {
        match self.sourceLocale.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string targetLocale = 3;

    pub fn get_targetLocale(&self) -> &str {
        match self.targetLocale.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TranslatedText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceLocale)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetLocale)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sourceLocale.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.targetLocale.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sourceLocale.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.targetLocale.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TranslatedText {
        TranslatedText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "text",
                |m: &TranslatedText| { &m.text },
                |m: &mut TranslatedText| { &mut m.text },
                TranslatedText::get_text,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "sourceLocale",
                |m: &TranslatedText| { &m.sourceLocale },
                |m: &mut TranslatedText| { &mut m.sourceLocale },
                TranslatedText::get_sourceLocale,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "targetLocale",
                |m: &TranslatedText| { &m.targetLocale },
                |m: &mut TranslatedText| { &mut m.targetLocale },
                TranslatedText::get_targetLocale,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<TranslatedText>(
                "TranslatedText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TranslatedText {
        static instance: ::protobuf::rt::Lazy<TranslatedText> = ::protobuf::rt::Lazy::INIT;
        instance.get(TranslatedText::new)
    }
}

impl ::protobuf::Clear for TranslatedText {
    fn clear(&mut self) {
        self.text.clear();
        self.sourceLocale.clear();
        self.targetLocale.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TranslatedText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslatedText {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Badge {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Badge {
    pub fn new() -> Badge {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string browseUrl = 3;

    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string description = 4;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Badge {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.image {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.browseUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Badge {
        Badge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &Badge| { &m.title },
                |m: &mut Badge| { &mut m.title },
                Badge::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Badge| { &m.image },
                |m: &mut Badge| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "browseUrl",
                |m: &Badge| { &m.browseUrl },
                |m: &mut Badge| { &mut m.browseUrl },
                Badge::get_browseUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "description",
                |m: &Badge| { &m.description },
                |m: &mut Badge| { &mut m.description },
                Badge::get_description,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Badge>(
                "Badge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Badge {
        static instance: ::protobuf::rt::Lazy<Badge> = ::protobuf::rt::Lazy::INIT;
        instance.get(Badge::new)
    }
}

impl ::protobuf::Clear for Badge {
    fn clear(&mut self) {
        self.title.clear();
        self.image.clear();
        self.browseUrl.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Badge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Badge {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BadgeContainer {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub badge: ::protobuf::RepeatedField<Badge>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BadgeContainer {
    pub fn new() -> BadgeContainer {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BadgeContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.badge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.badge {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.image {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.badge {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BadgeContainer {
        BadgeContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &BadgeContainer| { &m.title },
                |m: &mut BadgeContainer| { &mut m.title },
                BadgeContainer::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &BadgeContainer| { &m.image },
                |m: &mut BadgeContainer| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>>(
                "badge",
                |m: &BadgeContainer| { &m.badge },
                |m: &mut BadgeContainer| { &mut m.badge },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BadgeContainer>(
                "BadgeContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BadgeContainer {
        static instance: ::protobuf::rt::Lazy<BadgeContainer> = ::protobuf::rt::Lazy::INIT;
        instance.get(BadgeContainer::new)
    }
}

impl ::protobuf::Clear for BadgeContainer {
    fn clear(&mut self) {
        self.title.clear();
        self.image.clear();
        self.badge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BadgeContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BadgeContainer {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ContainerWithBanner {
    // message fields
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ContainerWithBanner {
    pub fn new() -> ContainerWithBanner {
        ::std::default::Default::default()
    }

    // optional string colorThemeArgb = 1;

    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContainerWithBanner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.colorThemeArgb.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerWithBanner {
        ContainerWithBanner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "colorThemeArgb",
                |m: &ContainerWithBanner| { &m.colorThemeArgb },
                |m: &mut ContainerWithBanner| { &mut m.colorThemeArgb },
                ContainerWithBanner::get_colorThemeArgb,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ContainerWithBanner>(
                "ContainerWithBanner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerWithBanner {
        static instance: ::protobuf::rt::Lazy<ContainerWithBanner> = ::protobuf::rt::Lazy::INIT;
        instance.get(ContainerWithBanner::new)
    }
}

impl ::protobuf::Clear for ContainerWithBanner {
    fn clear(&mut self) {
        self.colorThemeArgb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerWithBanner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerWithBanner {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DealOfTheDay {
    // message fields
    pub featuredHeader: ::protobuf::SingularField<::std::string::String>,
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DealOfTheDay {
    pub fn new() -> DealOfTheDay {
        ::std::default::Default::default()
    }

    // optional string featuredHeader = 1;

    pub fn get_featuredHeader(&self) -> &str {
        match self.featuredHeader.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string colorThemeArgb = 2;

    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DealOfTheDay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.featuredHeader)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.featuredHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.featuredHeader.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.colorThemeArgb.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DealOfTheDay {
        DealOfTheDay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "featuredHeader",
                |m: &DealOfTheDay| { &m.featuredHeader },
                |m: &mut DealOfTheDay| { &mut m.featuredHeader },
                DealOfTheDay::get_featuredHeader,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "colorThemeArgb",
                |m: &DealOfTheDay| { &m.colorThemeArgb },
                |m: &mut DealOfTheDay| { &mut m.colorThemeArgb },
                DealOfTheDay::get_colorThemeArgb,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DealOfTheDay>(
                "DealOfTheDay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DealOfTheDay {
        static instance: ::protobuf::rt::Lazy<DealOfTheDay> = ::protobuf::rt::Lazy::INIT;
        instance.get(DealOfTheDay::new)
    }
}

impl ::protobuf::Clear for DealOfTheDay {
    fn clear(&mut self) {
        self.featuredHeader.clear();
        self.colorThemeArgb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DealOfTheDay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DealOfTheDay {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Dismissal {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Dismissal {
    pub fn new() -> Dismissal {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string descriptionHtml = 2;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Dismissal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dismissal {
        Dismissal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &Dismissal| { &m.url },
                |m: &mut Dismissal| { &mut m.url },
                Dismissal::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &Dismissal| { &m.descriptionHtml },
                |m: &mut Dismissal| { &mut m.descriptionHtml },
                Dismissal::get_descriptionHtml,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Dismissal>(
                "Dismissal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dismissal {
        static instance: ::protobuf::rt::Lazy<Dismissal> = ::protobuf::rt::Lazy::INIT;
        instance.get(Dismissal::new)
    }
}

impl ::protobuf::Clear for Dismissal {
    fn clear(&mut self) {
        self.url.clear();
        self.descriptionHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dismissal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dismissal {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct EditorialSeriesContainer {
    // message fields
    pub seriesTitle: ::protobuf::SingularField<::std::string::String>,
    pub seriesSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub episodeTitle: ::protobuf::SingularField<::std::string::String>,
    pub episodeSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    pub videoSnippet: ::protobuf::RepeatedField<VideoSnippet>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl EditorialSeriesContainer {
    pub fn new() -> EditorialSeriesContainer {
        ::std::default::Default::default()
    }

    // optional string seriesTitle = 1;

    pub fn get_seriesTitle(&self) -> &str {
        match self.seriesTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string seriesSubtitle = 2;

    pub fn get_seriesSubtitle(&self) -> &str {
        match self.seriesSubtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string episodeTitle = 3;

    pub fn get_episodeTitle(&self) -> &str {
        match self.episodeTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string episodeSubtitle = 4;

    pub fn get_episodeSubtitle(&self) -> &str {
        match self.episodeSubtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string colorThemeArgb = 5;

    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for EditorialSeriesContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.videoSnippet {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seriesTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seriesSubtitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.episodeTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.episodeSubtitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.videoSnippet)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seriesTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seriesSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.episodeTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.episodeSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.videoSnippet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seriesTitle.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.seriesSubtitle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.episodeTitle.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.episodeSubtitle.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.colorThemeArgb.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.videoSnippet {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EditorialSeriesContainer {
        EditorialSeriesContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "seriesTitle",
                |m: &EditorialSeriesContainer| { &m.seriesTitle },
                |m: &mut EditorialSeriesContainer| { &mut m.seriesTitle },
                EditorialSeriesContainer::get_seriesTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "seriesSubtitle",
                |m: &EditorialSeriesContainer| { &m.seriesSubtitle },
                |m: &mut EditorialSeriesContainer| { &mut m.seriesSubtitle },
                EditorialSeriesContainer::get_seriesSubtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "episodeTitle",
                |m: &EditorialSeriesContainer| { &m.episodeTitle },
                |m: &mut EditorialSeriesContainer| { &mut m.episodeTitle },
                EditorialSeriesContainer::get_episodeTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "episodeSubtitle",
                |m: &EditorialSeriesContainer| { &m.episodeSubtitle },
                |m: &mut EditorialSeriesContainer| { &mut m.episodeSubtitle },
                EditorialSeriesContainer::get_episodeSubtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "colorThemeArgb",
                |m: &EditorialSeriesContainer| { &m.colorThemeArgb },
                |m: &mut EditorialSeriesContainer| { &mut m.colorThemeArgb },
                EditorialSeriesContainer::get_colorThemeArgb,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoSnippet>>(
                "videoSnippet",
                |m: &EditorialSeriesContainer| { &m.videoSnippet },
                |m: &mut EditorialSeriesContainer| { &mut m.videoSnippet },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<EditorialSeriesContainer>(
                "EditorialSeriesContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EditorialSeriesContainer {
        static instance: ::protobuf::rt::Lazy<EditorialSeriesContainer> = ::protobuf::rt::Lazy::INIT;
        instance.get(EditorialSeriesContainer::new)
    }
}

impl ::protobuf::Clear for EditorialSeriesContainer {
    fn clear(&mut self) {
        self.seriesTitle.clear();
        self.seriesSubtitle.clear();
        self.episodeTitle.clear();
        self.episodeSubtitle.clear();
        self.colorThemeArgb.clear();
        self.videoSnippet.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EditorialSeriesContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EditorialSeriesContainer {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Link {
    // message fields
    pub uri: ::protobuf::SingularField<::std::string::String>,
    pub resolvedLink: ::protobuf::SingularPtrField<ResolvedLink>,
    pub uriBackend: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Link {
    pub fn new() -> Link {
        ::std::default::Default::default()
    }

    // optional string uri = 1;

    pub fn get_uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 uriBackend = 3;

    pub fn get_uriBackend(&self) -> i32 {
        self.uriBackend.unwrap_or(0)
    }
}

impl ::protobuf::Message for Link {
    fn is_initialized(&self) -> bool {
        for v in &self.resolvedLink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ResolvedLink, _>(wire_type, is, &mut self.resolvedLink)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.uriBackend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resolvedLink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.uriBackend {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.uri.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resolvedLink.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.uriBackend {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Link {
        Link::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "uri",
                |m: &Link| { &m.uri },
                |m: &mut Link| { &mut m.uri },
                Link::get_uri,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedLink>, _>(
                "resolvedLink",
                |m: &Link| { &m.resolvedLink },
                |m: &mut Link| { &mut m.resolvedLink },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "uriBackend",
                |m: &Link| { &m.uriBackend },
                |m: &mut Link| { &mut m.uriBackend },
                Link::get_uriBackend,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Link>(
                "Link",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Link {
        static instance: ::protobuf::rt::Lazy<Link> = ::protobuf::rt::Lazy::INIT;
        instance.get(Link::new)
    }
}

impl ::protobuf::Clear for Link {
    fn clear(&mut self) {
        self.uri.clear();
        self.resolvedLink.clear();
        self.uriBackend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Link {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Link {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct NextBanner {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub colorTextArgb: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl NextBanner {
    pub fn new() -> NextBanner {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string subtitle = 2;

    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string colorTextArgb = 3;

    pub fn get_colorTextArgb(&self) -> &str {
        match self.colorTextArgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for NextBanner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorTextArgb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.colorTextArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.subtitle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.colorTextArgb.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextBanner {
        NextBanner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &NextBanner| { &m.title },
                |m: &mut NextBanner| { &mut m.title },
                NextBanner::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subtitle",
                |m: &NextBanner| { &m.subtitle },
                |m: &mut NextBanner| { &mut m.subtitle },
                NextBanner::get_subtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "colorTextArgb",
                |m: &NextBanner| { &m.colorTextArgb },
                |m: &mut NextBanner| { &mut m.colorTextArgb },
                NextBanner::get_colorTextArgb,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<NextBanner>(
                "NextBanner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NextBanner {
        static instance: ::protobuf::rt::Lazy<NextBanner> = ::protobuf::rt::Lazy::INIT;
        instance.get(NextBanner::new)
    }
}

impl ::protobuf::Clear for NextBanner {
    fn clear(&mut self) {
        self.title.clear();
        self.subtitle.clear();
        self.colorTextArgb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NextBanner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextBanner {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct OBSOLETE_Reason {
    // message fields
    pub briefReason: ::protobuf::SingularField<::std::string::String>,
    pub oBSOLETEDetailedReason: ::protobuf::SingularField<::std::string::String>,
    pub uniqueId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl OBSOLETE_Reason {
    pub fn new() -> OBSOLETE_Reason {
        ::std::default::Default::default()
    }

    // optional string briefReason = 1;

    pub fn get_briefReason(&self) -> &str {
        match self.briefReason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string oBSOLETEDetailedReason = 2;

    pub fn get_oBSOLETEDetailedReason(&self) -> &str {
        match self.oBSOLETEDetailedReason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string uniqueId = 3;

    pub fn get_uniqueId(&self) -> &str {
        match self.uniqueId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for OBSOLETE_Reason {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.briefReason)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.oBSOLETEDetailedReason)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uniqueId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.briefReason.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.oBSOLETEDetailedReason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.uniqueId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.briefReason.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.oBSOLETEDetailedReason.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.uniqueId.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OBSOLETE_Reason {
        OBSOLETE_Reason::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "briefReason",
                |m: &OBSOLETE_Reason| { &m.briefReason },
                |m: &mut OBSOLETE_Reason| { &mut m.briefReason },
                OBSOLETE_Reason::get_briefReason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "oBSOLETEDetailedReason",
                |m: &OBSOLETE_Reason| { &m.oBSOLETEDetailedReason },
                |m: &mut OBSOLETE_Reason| { &mut m.oBSOLETEDetailedReason },
                OBSOLETE_Reason::get_oBSOLETEDetailedReason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "uniqueId",
                |m: &OBSOLETE_Reason| { &m.uniqueId },
                |m: &mut OBSOLETE_Reason| { &mut m.uniqueId },
                OBSOLETE_Reason::get_uniqueId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<OBSOLETE_Reason>(
                "OBSOLETE_Reason",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OBSOLETE_Reason {
        static instance: ::protobuf::rt::Lazy<OBSOLETE_Reason> = ::protobuf::rt::Lazy::INIT;
        instance.get(OBSOLETE_Reason::new)
    }
}

impl ::protobuf::Clear for OBSOLETE_Reason {
    fn clear(&mut self) {
        self.briefReason.clear();
        self.oBSOLETEDetailedReason.clear();
        self.uniqueId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OBSOLETE_Reason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OBSOLETE_Reason {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlusOneData {
    // message fields
    pub setByUser: ::std::option::Option<bool>,
    pub total: ::std::option::Option<i64>,
    pub circlesTotal: ::std::option::Option<i64>,
    pub circlesProfiles: ::protobuf::RepeatedField<PlusProfile>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlusOneData {
    pub fn new() -> PlusOneData {
        ::std::default::Default::default()
    }

    // optional bool setByUser = 1;

    pub fn get_setByUser(&self) -> bool {
        self.setByUser.unwrap_or(false)
    }

    // optional int64 total = 2;

    pub fn get_total(&self) -> i64 {
        self.total.unwrap_or(0)
    }

    // optional int64 circlesTotal = 3;

    pub fn get_circlesTotal(&self) -> i64 {
        self.circlesTotal.unwrap_or(0)
    }
}

impl ::protobuf::Message for PlusOneData {
    fn is_initialized(&self) -> bool {
        for v in &self.circlesProfiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.setByUser = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.circlesTotal = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.circlesProfiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.setByUser {
            my_size += 2;
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.circlesTotal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.circlesProfiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.setByUser {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.circlesTotal {
            os.write_int64(3, v)?;
        }
        for v in &self.circlesProfiles {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusOneData {
        PlusOneData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "setByUser",
                |m: &PlusOneData| { &m.setByUser },
                |m: &mut PlusOneData| { &mut m.setByUser },
                PlusOneData::get_setByUser,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "total",
                |m: &PlusOneData| { &m.total },
                |m: &mut PlusOneData| { &mut m.total },
                PlusOneData::get_total,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "circlesTotal",
                |m: &PlusOneData| { &m.circlesTotal },
                |m: &mut PlusOneData| { &mut m.circlesTotal },
                PlusOneData::get_circlesTotal,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfile>>(
                "circlesProfiles",
                |m: &PlusOneData| { &m.circlesProfiles },
                |m: &mut PlusOneData| { &mut m.circlesProfiles },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlusOneData>(
                "PlusOneData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusOneData {
        static instance: ::protobuf::rt::Lazy<PlusOneData> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlusOneData::new)
    }
}

impl ::protobuf::Clear for PlusOneData {
    fn clear(&mut self) {
        self.setByUser = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.circlesTotal = ::std::option::Option::None;
        self.circlesProfiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusOneData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusOneData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PromotedDoc {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PromotedDoc {
    pub fn new() -> PromotedDoc {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string subtitle = 2;

    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string descriptionHtml = 4;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string detailsUrl = 5;

    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PromotedDoc {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.image)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.subtitle.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.image {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.detailsUrl.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PromotedDoc {
        PromotedDoc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &PromotedDoc| { &m.title },
                |m: &mut PromotedDoc| { &mut m.title },
                PromotedDoc::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subtitle",
                |m: &PromotedDoc| { &m.subtitle },
                |m: &mut PromotedDoc| { &mut m.subtitle },
                PromotedDoc::get_subtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &PromotedDoc| { &m.image },
                |m: &mut PromotedDoc| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &PromotedDoc| { &m.descriptionHtml },
                |m: &mut PromotedDoc| { &mut m.descriptionHtml },
                PromotedDoc::get_descriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "detailsUrl",
                |m: &PromotedDoc| { &m.detailsUrl },
                |m: &mut PromotedDoc| { &mut m.detailsUrl },
                PromotedDoc::get_detailsUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PromotedDoc>(
                "PromotedDoc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PromotedDoc {
        static instance: ::protobuf::rt::Lazy<PromotedDoc> = ::protobuf::rt::Lazy::INIT;
        instance.get(PromotedDoc::new)
    }
}

impl ::protobuf::Clear for PromotedDoc {
    fn clear(&mut self) {
        self.title.clear();
        self.subtitle.clear();
        self.image.clear();
        self.descriptionHtml.clear();
        self.detailsUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PromotedDoc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromotedDoc {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Reason {
    // message fields
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub reasonPlusProfiles: ::protobuf::SingularPtrField<ReasonPlusProfiles>,
    pub reasonReview: ::protobuf::SingularPtrField<ReasonReview>,
    pub dismissal: ::protobuf::SingularPtrField<Dismissal>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Reason {
    pub fn new() -> Reason {
        ::std::default::Default::default()
    }

    // optional string descriptionHtml = 3;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Reason {
    fn is_initialized(&self) -> bool {
        for v in &self.reasonPlusProfiles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reasonReview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dismissal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<ReasonPlusProfiles, _>(wire_type, is, &mut self.reasonPlusProfiles)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<ReasonReview, _>(wire_type, is, &mut self.reasonReview)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<Dismissal, _>(wire_type, is, &mut self.dismissal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.reasonPlusProfiles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reasonReview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.dismissal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.reasonPlusProfiles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.reasonReview.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.dismissal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reason {
        Reason::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &Reason| { &m.descriptionHtml },
                |m: &mut Reason| { &mut m.descriptionHtml },
                Reason::get_descriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReasonPlusProfiles>, _>(
                "reasonPlusProfiles",
                |m: &Reason| { &m.reasonPlusProfiles },
                |m: &mut Reason| { &mut m.reasonPlusProfiles },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReasonReview>, _>(
                "reasonReview",
                |m: &Reason| { &m.reasonReview },
                |m: &mut Reason| { &mut m.reasonReview },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dismissal>, _>(
                "dismissal",
                |m: &Reason| { &m.dismissal },
                |m: &mut Reason| { &mut m.dismissal },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Reason>(
                "Reason",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Reason {
        static instance: ::protobuf::rt::Lazy<Reason> = ::protobuf::rt::Lazy::INIT;
        instance.get(Reason::new)
    }
}

impl ::protobuf::Clear for Reason {
    fn clear(&mut self) {
        self.descriptionHtml.clear();
        self.reasonPlusProfiles.clear();
        self.reasonReview.clear();
        self.dismissal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Reason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reason {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ReasonPlusProfiles {
    // message fields
    pub localizedDescriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub plusProfile: ::protobuf::RepeatedField<PlusProfile>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ReasonPlusProfiles {
    pub fn new() -> ReasonPlusProfiles {
        ::std::default::Default::default()
    }

    // optional string localizedDescriptionHtml = 1;

    pub fn get_localizedDescriptionHtml(&self) -> &str {
        match self.localizedDescriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ReasonPlusProfiles {
    fn is_initialized(&self) -> bool {
        for v in &self.plusProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedDescriptionHtml)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.plusProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.localizedDescriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.plusProfile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.localizedDescriptionHtml.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.plusProfile {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReasonPlusProfiles {
        ReasonPlusProfiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "localizedDescriptionHtml",
                |m: &ReasonPlusProfiles| { &m.localizedDescriptionHtml },
                |m: &mut ReasonPlusProfiles| { &mut m.localizedDescriptionHtml },
                ReasonPlusProfiles::get_localizedDescriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfile>>(
                "plusProfile",
                |m: &ReasonPlusProfiles| { &m.plusProfile },
                |m: &mut ReasonPlusProfiles| { &mut m.plusProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ReasonPlusProfiles>(
                "ReasonPlusProfiles",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReasonPlusProfiles {
        static instance: ::protobuf::rt::Lazy<ReasonPlusProfiles> = ::protobuf::rt::Lazy::INIT;
        instance.get(ReasonPlusProfiles::new)
    }
}

impl ::protobuf::Clear for ReasonPlusProfiles {
    fn clear(&mut self) {
        self.localizedDescriptionHtml.clear();
        self.plusProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReasonPlusProfiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReasonPlusProfiles {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ReasonReview {
    // message fields
    pub review: ::protobuf::SingularPtrField<Review>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ReasonReview {
    pub fn new() -> ReasonReview {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReasonReview {
    fn is_initialized(&self) -> bool {
        for v in &self.review {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Review, _>(wire_type, is, &mut self.review)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.review.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.review.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReasonReview {
        ReasonReview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>, _>(
                "review",
                |m: &ReasonReview| { &m.review },
                |m: &mut ReasonReview| { &mut m.review },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ReasonReview>(
                "ReasonReview",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReasonReview {
        static instance: ::protobuf::rt::Lazy<ReasonReview> = ::protobuf::rt::Lazy::INIT;
        instance.get(ReasonReview::new)
    }
}

impl ::protobuf::Clear for ReasonReview {
    fn clear(&mut self) {
        self.review.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReasonReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReasonReview {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RecommendationsContainer {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RecommendationsContainer {
    pub fn new() -> RecommendationsContainer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RecommendationsContainer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecommendationsContainer {
        RecommendationsContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<RecommendationsContainer>(
                "RecommendationsContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecommendationsContainer {
        static instance: ::protobuf::rt::Lazy<RecommendationsContainer> = ::protobuf::rt::Lazy::INIT;
        instance.get(RecommendationsContainer::new)
    }
}

impl ::protobuf::Clear for RecommendationsContainer {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecommendationsContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecommendationsContainer {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SectionMetadata {
    // message fields
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub listUrl: ::protobuf::SingularField<::std::string::String>,
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SectionMetadata {
    pub fn new() -> SectionMetadata {
        ::std::default::Default::default()
    }

    // optional string header = 1;

    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string listUrl = 2;

    pub fn get_listUrl(&self) -> &str {
        match self.listUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string browseUrl = 3;

    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string descriptionHtml = 4;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SectionMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.listUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.listUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.header.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.listUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.browseUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SectionMetadata {
        SectionMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "header",
                |m: &SectionMetadata| { &m.header },
                |m: &mut SectionMetadata| { &mut m.header },
                SectionMetadata::get_header,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "listUrl",
                |m: &SectionMetadata| { &m.listUrl },
                |m: &mut SectionMetadata| { &mut m.listUrl },
                SectionMetadata::get_listUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "browseUrl",
                |m: &SectionMetadata| { &m.browseUrl },
                |m: &mut SectionMetadata| { &mut m.browseUrl },
                SectionMetadata::get_browseUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &SectionMetadata| { &m.descriptionHtml },
                |m: &mut SectionMetadata| { &mut m.descriptionHtml },
                SectionMetadata::get_descriptionHtml,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SectionMetadata>(
                "SectionMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SectionMetadata {
        static instance: ::protobuf::rt::Lazy<SectionMetadata> = ::protobuf::rt::Lazy::INIT;
        instance.get(SectionMetadata::new)
    }
}

impl ::protobuf::Clear for SectionMetadata {
    fn clear(&mut self) {
        self.header.clear();
        self.listUrl.clear();
        self.browseUrl.clear();
        self.descriptionHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SectionMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SectionMetadata {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SeriesAntenna {
    // message fields
    pub seriesTitle: ::protobuf::SingularField<::std::string::String>,
    pub seriesSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub episodeTitle: ::protobuf::SingularField<::std::string::String>,
    pub episodeSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    pub sectionTracks: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionAlbums: ::protobuf::SingularPtrField<SectionMetadata>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SeriesAntenna {
    pub fn new() -> SeriesAntenna {
        ::std::default::Default::default()
    }

    // optional string seriesTitle = 1;

    pub fn get_seriesTitle(&self) -> &str {
        match self.seriesTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string seriesSubtitle = 2;

    pub fn get_seriesSubtitle(&self) -> &str {
        match self.seriesSubtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string episodeTitle = 3;

    pub fn get_episodeTitle(&self) -> &str {
        match self.episodeTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string episodeSubtitle = 4;

    pub fn get_episodeSubtitle(&self) -> &str {
        match self.episodeSubtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string colorThemeArgb = 5;

    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SeriesAntenna {
    fn is_initialized(&self) -> bool {
        for v in &self.sectionTracks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionAlbums {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seriesTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seriesSubtitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.episodeTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.episodeSubtitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionTracks)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionAlbums)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seriesTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seriesSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.episodeTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.episodeSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.sectionTracks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sectionAlbums.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seriesTitle.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.seriesSubtitle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.episodeTitle.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.episodeSubtitle.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.colorThemeArgb.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.sectionTracks.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.sectionAlbums.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeriesAntenna {
        SeriesAntenna::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "seriesTitle",
                |m: &SeriesAntenna| { &m.seriesTitle },
                |m: &mut SeriesAntenna| { &mut m.seriesTitle },
                SeriesAntenna::get_seriesTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "seriesSubtitle",
                |m: &SeriesAntenna| { &m.seriesSubtitle },
                |m: &mut SeriesAntenna| { &mut m.seriesSubtitle },
                SeriesAntenna::get_seriesSubtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "episodeTitle",
                |m: &SeriesAntenna| { &m.episodeTitle },
                |m: &mut SeriesAntenna| { &mut m.episodeTitle },
                SeriesAntenna::get_episodeTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "episodeSubtitle",
                |m: &SeriesAntenna| { &m.episodeSubtitle },
                |m: &mut SeriesAntenna| { &mut m.episodeSubtitle },
                SeriesAntenna::get_episodeSubtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "colorThemeArgb",
                |m: &SeriesAntenna| { &m.colorThemeArgb },
                |m: &mut SeriesAntenna| { &mut m.colorThemeArgb },
                SeriesAntenna::get_colorThemeArgb,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionTracks",
                |m: &SeriesAntenna| { &m.sectionTracks },
                |m: &mut SeriesAntenna| { &mut m.sectionTracks },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionAlbums",
                |m: &SeriesAntenna| { &m.sectionAlbums },
                |m: &mut SeriesAntenna| { &mut m.sectionAlbums },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SeriesAntenna>(
                "SeriesAntenna",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeriesAntenna {
        static instance: ::protobuf::rt::Lazy<SeriesAntenna> = ::protobuf::rt::Lazy::INIT;
        instance.get(SeriesAntenna::new)
    }
}

impl ::protobuf::Clear for SeriesAntenna {
    fn clear(&mut self) {
        self.seriesTitle.clear();
        self.seriesSubtitle.clear();
        self.episodeTitle.clear();
        self.episodeSubtitle.clear();
        self.colorThemeArgb.clear();
        self.sectionTracks.clear();
        self.sectionAlbums.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeriesAntenna {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeriesAntenna {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SuggestionReasons {
    // message fields
    pub reason: ::protobuf::RepeatedField<Reason>,
    pub neutralDismissal: ::protobuf::SingularPtrField<Dismissal>,
    pub positiveDismissal: ::protobuf::SingularPtrField<Dismissal>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SuggestionReasons {
    pub fn new() -> SuggestionReasons {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SuggestionReasons {
    fn is_initialized(&self) -> bool {
        for v in &self.reason {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.neutralDismissal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.positiveDismissal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<Dismissal, _>(wire_type, is, &mut self.neutralDismissal)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<Dismissal, _>(wire_type, is, &mut self.positiveDismissal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reason {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.neutralDismissal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.positiveDismissal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reason {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.neutralDismissal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.positiveDismissal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SuggestionReasons {
        SuggestionReasons::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Reason>>(
                "reason",
                |m: &SuggestionReasons| { &m.reason },
                |m: &mut SuggestionReasons| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dismissal>, _>(
                "neutralDismissal",
                |m: &SuggestionReasons| { &m.neutralDismissal },
                |m: &mut SuggestionReasons| { &mut m.neutralDismissal },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dismissal>, _>(
                "positiveDismissal",
                |m: &SuggestionReasons| { &m.positiveDismissal },
                |m: &mut SuggestionReasons| { &mut m.positiveDismissal },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SuggestionReasons>(
                "SuggestionReasons",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SuggestionReasons {
        static instance: ::protobuf::rt::Lazy<SuggestionReasons> = ::protobuf::rt::Lazy::INIT;
        instance.get(SuggestionReasons::new)
    }
}

impl ::protobuf::Clear for SuggestionReasons {
    fn clear(&mut self) {
        self.reason.clear();
        self.neutralDismissal.clear();
        self.positiveDismissal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SuggestionReasons {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SuggestionReasons {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Template {
    // message fields
    pub seriesAntenna: ::protobuf::SingularPtrField<SeriesAntenna>,
    pub tileGraphic2X1: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileGraphic4X2: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileGraphicColoredTitle2X1: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileGraphicUpperLeftTitle2X1: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileDetailsReflectedGraphic2X2: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileFourBlock4X2: ::protobuf::SingularPtrField<TileTemplate>,
    pub containerWithBanner: ::protobuf::SingularPtrField<ContainerWithBanner>,
    pub dealOfTheDay: ::protobuf::SingularPtrField<DealOfTheDay>,
    pub tileGraphicColoredTitle4X2: ::protobuf::SingularPtrField<TileTemplate>,
    pub editorialSeriesContainer: ::protobuf::SingularPtrField<EditorialSeriesContainer>,
    pub recommendationsContainer: ::protobuf::SingularPtrField<RecommendationsContainer>,
    pub nextBanner: ::protobuf::SingularPtrField<NextBanner>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Template {
    pub fn new() -> Template {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Template {
    fn is_initialized(&self) -> bool {
        for v in &self.seriesAntenna {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphic2X1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphic4X2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphicColoredTitle2X1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphicUpperLeftTitle2X1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileDetailsReflectedGraphic2X2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileFourBlock4X2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containerWithBanner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dealOfTheDay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphicColoredTitle4X2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.editorialSeriesContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recommendationsContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nextBanner {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<SeriesAntenna, _>(wire_type, is, &mut self.seriesAntenna)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<TileTemplate, _>(wire_type, is, &mut self.tileGraphic2X1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<TileTemplate, _>(wire_type, is, &mut self.tileGraphic4X2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<TileTemplate, _>(wire_type, is, &mut self.tileGraphicColoredTitle2X1)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<TileTemplate, _>(wire_type, is, &mut self.tileGraphicUpperLeftTitle2X1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<TileTemplate, _>(wire_type, is, &mut self.tileDetailsReflectedGraphic2X2)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<TileTemplate, _>(wire_type, is, &mut self.tileFourBlock4X2)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<ContainerWithBanner, _>(wire_type, is, &mut self.containerWithBanner)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<DealOfTheDay, _>(wire_type, is, &mut self.dealOfTheDay)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<TileTemplate, _>(wire_type, is, &mut self.tileGraphicColoredTitle4X2)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<EditorialSeriesContainer, _>(wire_type, is, &mut self.editorialSeriesContainer)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<RecommendationsContainer, _>(wire_type, is, &mut self.recommendationsContainer)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<NextBanner, _>(wire_type, is, &mut self.nextBanner)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seriesAntenna.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tileGraphic2X1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tileGraphic4X2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tileGraphicColoredTitle2X1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tileGraphicUpperLeftTitle2X1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tileDetailsReflectedGraphic2X2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tileFourBlock4X2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.containerWithBanner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.dealOfTheDay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tileGraphicColoredTitle4X2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.editorialSeriesContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.recommendationsContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nextBanner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seriesAntenna.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tileGraphic2X1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.tileGraphic4X2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.tileGraphicColoredTitle2X1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.tileGraphicUpperLeftTitle2X1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.tileDetailsReflectedGraphic2X2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.tileFourBlock4X2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.containerWithBanner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.dealOfTheDay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.tileGraphicColoredTitle4X2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.editorialSeriesContainer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.recommendationsContainer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.nextBanner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Template {
        Template::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SeriesAntenna>, _>(
                "seriesAntenna",
                |m: &Template| { &m.seriesAntenna },
                |m: &mut Template| { &mut m.seriesAntenna },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>, _>(
                "tileGraphic2X1",
                |m: &Template| { &m.tileGraphic2X1 },
                |m: &mut Template| { &mut m.tileGraphic2X1 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>, _>(
                "tileGraphic4X2",
                |m: &Template| { &m.tileGraphic4X2 },
                |m: &mut Template| { &mut m.tileGraphic4X2 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>, _>(
                "tileGraphicColoredTitle2X1",
                |m: &Template| { &m.tileGraphicColoredTitle2X1 },
                |m: &mut Template| { &mut m.tileGraphicColoredTitle2X1 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>, _>(
                "tileGraphicUpperLeftTitle2X1",
                |m: &Template| { &m.tileGraphicUpperLeftTitle2X1 },
                |m: &mut Template| { &mut m.tileGraphicUpperLeftTitle2X1 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>, _>(
                "tileDetailsReflectedGraphic2X2",
                |m: &Template| { &m.tileDetailsReflectedGraphic2X2 },
                |m: &mut Template| { &mut m.tileDetailsReflectedGraphic2X2 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>, _>(
                "tileFourBlock4X2",
                |m: &Template| { &m.tileFourBlock4X2 },
                |m: &mut Template| { &mut m.tileFourBlock4X2 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerWithBanner>, _>(
                "containerWithBanner",
                |m: &Template| { &m.containerWithBanner },
                |m: &mut Template| { &mut m.containerWithBanner },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DealOfTheDay>, _>(
                "dealOfTheDay",
                |m: &Template| { &m.dealOfTheDay },
                |m: &mut Template| { &mut m.dealOfTheDay },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>, _>(
                "tileGraphicColoredTitle4X2",
                |m: &Template| { &m.tileGraphicColoredTitle4X2 },
                |m: &mut Template| { &mut m.tileGraphicColoredTitle4X2 },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EditorialSeriesContainer>, _>(
                "editorialSeriesContainer",
                |m: &Template| { &m.editorialSeriesContainer },
                |m: &mut Template| { &mut m.editorialSeriesContainer },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecommendationsContainer>, _>(
                "recommendationsContainer",
                |m: &Template| { &m.recommendationsContainer },
                |m: &mut Template| { &mut m.recommendationsContainer },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NextBanner>, _>(
                "nextBanner",
                |m: &Template| { &m.nextBanner },
                |m: &mut Template| { &mut m.nextBanner },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Template>(
                "Template",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Template {
        static instance: ::protobuf::rt::Lazy<Template> = ::protobuf::rt::Lazy::INIT;
        instance.get(Template::new)
    }
}

impl ::protobuf::Clear for Template {
    fn clear(&mut self) {
        self.seriesAntenna.clear();
        self.tileGraphic2X1.clear();
        self.tileGraphic4X2.clear();
        self.tileGraphicColoredTitle2X1.clear();
        self.tileGraphicUpperLeftTitle2X1.clear();
        self.tileDetailsReflectedGraphic2X2.clear();
        self.tileFourBlock4X2.clear();
        self.containerWithBanner.clear();
        self.dealOfTheDay.clear();
        self.tileGraphicColoredTitle4X2.clear();
        self.editorialSeriesContainer.clear();
        self.recommendationsContainer.clear();
        self.nextBanner.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Template {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Template {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct TileTemplate {
    // message fields
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    pub colorTextArgb: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl TileTemplate {
    pub fn new() -> TileTemplate {
        ::std::default::Default::default()
    }

    // optional string colorThemeArgb = 1;

    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string colorTextArgb = 2;

    pub fn get_colorTextArgb(&self) -> &str {
        match self.colorTextArgb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TileTemplate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorTextArgb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.colorTextArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.colorThemeArgb.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.colorTextArgb.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TileTemplate {
        TileTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "colorThemeArgb",
                |m: &TileTemplate| { &m.colorThemeArgb },
                |m: &mut TileTemplate| { &mut m.colorThemeArgb },
                TileTemplate::get_colorThemeArgb,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "colorTextArgb",
                |m: &TileTemplate| { &m.colorTextArgb },
                |m: &mut TileTemplate| { &mut m.colorTextArgb },
                TileTemplate::get_colorTextArgb,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<TileTemplate>(
                "TileTemplate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TileTemplate {
        static instance: ::protobuf::rt::Lazy<TileTemplate> = ::protobuf::rt::Lazy::INIT;
        instance.get(TileTemplate::new)
    }
}

impl ::protobuf::Clear for TileTemplate {
    fn clear(&mut self) {
        self.colorThemeArgb.clear();
        self.colorTextArgb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TileTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TileTemplate {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct VideoSnippet {
    // message fields
    pub image: ::protobuf::RepeatedField<Image>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl VideoSnippet {
    pub fn new() -> VideoSnippet {
        ::std::default::Default::default()
    }

    // optional string title = 2;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string description = 3;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoSnippet {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.image {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoSnippet {
        VideoSnippet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &VideoSnippet| { &m.image },
                |m: &mut VideoSnippet| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &VideoSnippet| { &m.title },
                |m: &mut VideoSnippet| { &mut m.title },
                VideoSnippet::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "description",
                |m: &VideoSnippet| { &m.description },
                |m: &mut VideoSnippet| { &mut m.description },
                VideoSnippet::get_description,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<VideoSnippet>(
                "VideoSnippet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoSnippet {
        static instance: ::protobuf::rt::Lazy<VideoSnippet> = ::protobuf::rt::Lazy::INIT;
        instance.get(VideoSnippet::new)
    }
}

impl ::protobuf::Clear for VideoSnippet {
    fn clear(&mut self) {
        self.image.clear();
        self.title.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoSnippet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoSnippet {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Warning {
    // message fields
    pub localizedMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Warning {
    pub fn new() -> Warning {
        ::std::default::Default::default()
    }

    // optional string localizedMessage = 1;

    pub fn get_localizedMessage(&self) -> &str {
        match self.localizedMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Warning {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.localizedMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.localizedMessage.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Warning {
        Warning::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "localizedMessage",
                |m: &Warning| { &m.localizedMessage },
                |m: &mut Warning| { &mut m.localizedMessage },
                Warning::get_localizedMessage,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Warning>(
                "Warning",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Warning {
        static instance: ::protobuf::rt::Lazy<Warning> = ::protobuf::rt::Lazy::INIT;
        instance.get(Warning::new)
    }
}

impl ::protobuf::Clear for Warning {
    fn clear(&mut self) {
        self.localizedMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Warning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Warning {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AlbumDetails {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<MusicDetails>,
    pub displayArtist: ::protobuf::SingularPtrField<ArtistDetails>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AlbumDetails {
    pub fn new() -> AlbumDetails {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AlbumDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.displayArtist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<MusicDetails, _>(wire_type, is, &mut self.details)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<ArtistDetails, _>(wire_type, is, &mut self.displayArtist)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.displayArtist.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.displayArtist.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlbumDetails {
        AlbumDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &AlbumDetails| { &m.name },
                |m: &mut AlbumDetails| { &mut m.name },
                AlbumDetails::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MusicDetails>, _>(
                "details",
                |m: &AlbumDetails| { &m.details },
                |m: &mut AlbumDetails| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>, _>(
                "displayArtist",
                |m: &AlbumDetails| { &m.displayArtist },
                |m: &mut AlbumDetails| { &mut m.displayArtist },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AlbumDetails>(
                "AlbumDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlbumDetails {
        static instance: ::protobuf::rt::Lazy<AlbumDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(AlbumDetails::new)
    }
}

impl ::protobuf::Clear for AlbumDetails {
    fn clear(&mut self) {
        self.name.clear();
        self.details.clear();
        self.displayArtist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlbumDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlbumDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Dependency {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub minVersionCode: ::std::option::Option<i32>,
    pub versionCodeMask: ::std::option::Option<i32>,
    pub skipPermissions: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Dependency {
    pub fn new() -> Dependency {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 minVersionCode = 2;

    pub fn get_minVersionCode(&self) -> i32 {
        self.minVersionCode.unwrap_or(0)
    }

    // optional int32 versionCodeMask = 3;

    pub fn get_versionCodeMask(&self) -> i32 {
        self.versionCodeMask.unwrap_or(0)
    }

    // optional bool skipPermissions = 4;

    pub fn get_skipPermissions(&self) -> bool {
        self.skipPermissions.unwrap_or(false)
    }
}

impl ::protobuf::Message for Dependency {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minVersionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCodeMask = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skipPermissions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.minVersionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCodeMask {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skipPermissions {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.minVersionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.versionCodeMask {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.skipPermissions {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dependency {
        Dependency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &Dependency| { &m.packageName },
                |m: &mut Dependency| { &mut m.packageName },
                Dependency::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "minVersionCode",
                |m: &Dependency| { &m.minVersionCode },
                |m: &mut Dependency| { &mut m.minVersionCode },
                Dependency::get_minVersionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCodeMask",
                |m: &Dependency| { &m.versionCodeMask },
                |m: &mut Dependency| { &mut m.versionCodeMask },
                Dependency::get_versionCodeMask,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "skipPermissions",
                |m: &Dependency| { &m.skipPermissions },
                |m: &mut Dependency| { &mut m.skipPermissions },
                Dependency::get_skipPermissions,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Dependency>(
                "Dependency",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dependency {
        static instance: ::protobuf::rt::Lazy<Dependency> = ::protobuf::rt::Lazy::INIT;
        instance.get(Dependency::new)
    }
}

impl ::protobuf::Clear for Dependency {
    fn clear(&mut self) {
        self.packageName.clear();
        self.minVersionCode = ::std::option::Option::None;
        self.versionCodeMask = ::std::option::Option::None;
        self.skipPermissions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dependency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dependency {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InstallDetails {
    // message fields
    pub installLocation: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub dependency: ::protobuf::SingularPtrField<Dependency>,
    pub targetSdkVersion: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InstallDetails {
    pub fn new() -> InstallDetails {
        ::std::default::Default::default()
    }

    // optional int32 installLocation = 1;

    pub fn get_installLocation(&self) -> i32 {
        self.installLocation.unwrap_or(0)
    }

    // optional int64 size = 2;

    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional int32 targetSdkVersion = 4;

    pub fn get_targetSdkVersion(&self) -> i32 {
        self.targetSdkVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for InstallDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.dependency {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.installLocation = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<Dependency, _>(wire_type, is, &mut self.dependency)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.targetSdkVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.installLocation {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dependency.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.targetSdkVersion {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.installLocation {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.dependency.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.targetSdkVersion {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallDetails {
        InstallDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "installLocation",
                |m: &InstallDetails| { &m.installLocation },
                |m: &mut InstallDetails| { &mut m.installLocation },
                InstallDetails::get_installLocation,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "size",
                |m: &InstallDetails| { &m.size },
                |m: &mut InstallDetails| { &mut m.size },
                InstallDetails::get_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dependency>, _>(
                "dependency",
                |m: &InstallDetails| { &m.dependency },
                |m: &mut InstallDetails| { &mut m.dependency },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "targetSdkVersion",
                |m: &InstallDetails| { &m.targetSdkVersion },
                |m: &mut InstallDetails| { &mut m.targetSdkVersion },
                InstallDetails::get_targetSdkVersion,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InstallDetails>(
                "InstallDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstallDetails {
        static instance: ::protobuf::rt::Lazy<InstallDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(InstallDetails::new)
    }
}

impl ::protobuf::Clear for InstallDetails {
    fn clear(&mut self) {
        self.installLocation = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.dependency.clear();
        self.targetSdkVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstallDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AppDetails {
    // message fields
    pub developerName: ::protobuf::SingularField<::std::string::String>,
    pub majorVersionNumber: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub versionString: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub appCategory: ::protobuf::RepeatedField<::std::string::String>,
    pub contentRating: ::std::option::Option<i32>,
    pub installationSize: ::std::option::Option<i64>,
    pub permission: ::protobuf::RepeatedField<::std::string::String>,
    pub developerEmail: ::protobuf::SingularField<::std::string::String>,
    pub developerWebsite: ::protobuf::SingularField<::std::string::String>,
    pub numDownloads: ::protobuf::SingularField<::std::string::String>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub recentChangesHtml: ::protobuf::SingularField<::std::string::String>,
    pub uploadDate: ::protobuf::SingularField<::std::string::String>,
    pub file: ::protobuf::RepeatedField<FileMetadata>,
    pub appType: ::protobuf::SingularField<::std::string::String>,
    pub certificateHash: ::protobuf::RepeatedField<::std::string::String>,
    pub variesByAccount: ::std::option::Option<bool>,
    pub certificateSet: ::protobuf::RepeatedField<CertificateSet>,
    pub autoAcquireFreeAppIfHigherVersionAvailableTag: ::protobuf::RepeatedField<::std::string::String>,
    pub declaresIab: ::std::option::Option<bool>,
    pub splitId: ::protobuf::RepeatedField<::std::string::String>,
    pub gamepadRequired: ::std::option::Option<bool>,
    pub externallyHosted: ::std::option::Option<bool>,
    pub everExternallyHosted: ::std::option::Option<bool>,
    pub installNotes: ::protobuf::SingularField<::std::string::String>,
    pub installLocation: ::std::option::Option<i32>,
    pub targetSdkVersion: ::std::option::Option<i32>,
    pub hasPreregistrationPromoCode: ::protobuf::SingularField<::std::string::String>,
    pub installDetails: ::protobuf::SingularPtrField<InstallDetails>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AppDetails {
    pub fn new() -> AppDetails {
        ::std::default::Default::default()
    }

    // optional string developerName = 1;

    pub fn get_developerName(&self) -> &str {
        match self.developerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 majorVersionNumber = 2;

    pub fn get_majorVersionNumber(&self) -> i32 {
        self.majorVersionNumber.unwrap_or(0)
    }

    // optional int32 versionCode = 3;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string versionString = 4;

    pub fn get_versionString(&self) -> &str {
        match self.versionString.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string title = 5;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 contentRating = 8;

    pub fn get_contentRating(&self) -> i32 {
        self.contentRating.unwrap_or(0)
    }

    // optional int64 installationSize = 9;

    pub fn get_installationSize(&self) -> i64 {
        self.installationSize.unwrap_or(0)
    }

    // optional string developerEmail = 11;

    pub fn get_developerEmail(&self) -> &str {
        match self.developerEmail.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string developerWebsite = 12;

    pub fn get_developerWebsite(&self) -> &str {
        match self.developerWebsite.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string numDownloads = 13;

    pub fn get_numDownloads(&self) -> &str {
        match self.numDownloads.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string packageName = 14;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string recentChangesHtml = 15;

    pub fn get_recentChangesHtml(&self) -> &str {
        match self.recentChangesHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string uploadDate = 16;

    pub fn get_uploadDate(&self) -> &str {
        match self.uploadDate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string appType = 18;

    pub fn get_appType(&self) -> &str {
        match self.appType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool variesByAccount = 21;

    pub fn get_variesByAccount(&self) -> bool {
        self.variesByAccount.unwrap_or(false)
    }

    // optional bool declaresIab = 24;

    pub fn get_declaresIab(&self) -> bool {
        self.declaresIab.unwrap_or(false)
    }

    // optional bool gamepadRequired = 26;

    pub fn get_gamepadRequired(&self) -> bool {
        self.gamepadRequired.unwrap_or(false)
    }

    // optional bool externallyHosted = 27;

    pub fn get_externallyHosted(&self) -> bool {
        self.externallyHosted.unwrap_or(false)
    }

    // optional bool everExternallyHosted = 28;

    pub fn get_everExternallyHosted(&self) -> bool {
        self.everExternallyHosted.unwrap_or(false)
    }

    // optional string installNotes = 30;

    pub fn get_installNotes(&self) -> &str {
        match self.installNotes.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 installLocation = 31;

    pub fn get_installLocation(&self) -> i32 {
        self.installLocation.unwrap_or(0)
    }

    // optional int32 targetSdkVersion = 32;

    pub fn get_targetSdkVersion(&self) -> i32 {
        self.targetSdkVersion.unwrap_or(0)
    }

    // optional string hasPreregistrationPromoCode = 33;

    pub fn get_hasPreregistrationPromoCode(&self) -> &str {
        match self.hasPreregistrationPromoCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AppDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.certificateSet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.installDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.majorVersionNumber = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.versionString)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.appCategory)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentRating = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.installationSize = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.permission)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerEmail)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerWebsite)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.numDownloads)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recentChangesHtml)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uploadDate)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.file)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.appType)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.variesByAccount = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.certificateSet)?;
                },
                23 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.autoAcquireFreeAppIfHigherVersionAvailableTag)?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.declaresIab = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.splitId)?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.gamepadRequired = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.externallyHosted = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.everExternallyHosted = ::std::option::Option::Some(tmp);
                },
                30 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.installNotes)?;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.installLocation = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.targetSdkVersion = ::std::option::Option::Some(tmp);
                },
                33 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hasPreregistrationPromoCode)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into::<InstallDetails, _>(wire_type, is, &mut self.installDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.developerName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.majorVersionNumber {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionString.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.appCategory {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.contentRating {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.installationSize {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.permission {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(v) = self.developerEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.developerWebsite.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.numDownloads.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.recentChangesHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.uploadDate.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        for value in &self.file {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.appType.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        for value in &self.certificateHash {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if let Some(v) = self.variesByAccount {
            my_size += 3;
        }
        for value in &self.certificateSet {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.autoAcquireFreeAppIfHigherVersionAvailableTag {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        if let Some(v) = self.declaresIab {
            my_size += 3;
        }
        for value in &self.splitId {
            my_size += ::protobuf::rt::string_size(25, &value);
        };
        if let Some(v) = self.gamepadRequired {
            my_size += 3;
        }
        if let Some(v) = self.externallyHosted {
            my_size += 3;
        }
        if let Some(v) = self.everExternallyHosted {
            my_size += 3;
        }
        if let Some(v) = self.installNotes.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        if let Some(v) = self.installLocation {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.targetSdkVersion {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hasPreregistrationPromoCode.as_ref() {
            my_size += ::protobuf::rt::string_size(33, &v);
        }
        if let Some(v) = self.installDetails.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.developerName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.majorVersionNumber {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.versionString.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.appCategory {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.contentRating {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.installationSize {
            os.write_int64(9, v)?;
        }
        for v in &self.permission {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.developerEmail.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.developerWebsite.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.numDownloads.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.recentChangesHtml.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.uploadDate.as_ref() {
            os.write_string(16, v)?;
        }
        for v in &self.file {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.appType.as_ref() {
            os.write_string(18, v)?;
        }
        for v in &self.certificateHash {
            os.write_string(19, &v)?;
        };
        if let Some(v) = self.variesByAccount {
            os.write_bool(21, v)?;
        }
        for v in &self.certificateSet {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        for v in &self.autoAcquireFreeAppIfHigherVersionAvailableTag {
            os.write_string(23, &v)?;
        };
        if let Some(v) = self.declaresIab {
            os.write_bool(24, v)?;
        }
        for v in &self.splitId {
            os.write_string(25, &v)?;
        };
        if let Some(v) = self.gamepadRequired {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.externallyHosted {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.everExternallyHosted {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.installNotes.as_ref() {
            os.write_string(30, v)?;
        }
        if let Some(v) = self.installLocation {
            os.write_int32(31, v)?;
        }
        if let Some(v) = self.targetSdkVersion {
            os.write_int32(32, v)?;
        }
        if let Some(v) = self.hasPreregistrationPromoCode.as_ref() {
            os.write_string(33, v)?;
        }
        if let Some(v) = self.installDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDetails {
        AppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "developerName",
                |m: &AppDetails| { &m.developerName },
                |m: &mut AppDetails| { &mut m.developerName },
                AppDetails::get_developerName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "majorVersionNumber",
                |m: &AppDetails| { &m.majorVersionNumber },
                |m: &mut AppDetails| { &mut m.majorVersionNumber },
                AppDetails::get_majorVersionNumber,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &AppDetails| { &m.versionCode },
                |m: &mut AppDetails| { &mut m.versionCode },
                AppDetails::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "versionString",
                |m: &AppDetails| { &m.versionString },
                |m: &mut AppDetails| { &mut m.versionString },
                AppDetails::get_versionString,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &AppDetails| { &m.title },
                |m: &mut AppDetails| { &mut m.title },
                AppDetails::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appCategory",
                |m: &AppDetails| { &m.appCategory },
                |m: &mut AppDetails| { &mut m.appCategory },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "contentRating",
                |m: &AppDetails| { &m.contentRating },
                |m: &mut AppDetails| { &mut m.contentRating },
                AppDetails::get_contentRating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "installationSize",
                |m: &AppDetails| { &m.installationSize },
                |m: &mut AppDetails| { &mut m.installationSize },
                AppDetails::get_installationSize,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permission",
                |m: &AppDetails| { &m.permission },
                |m: &mut AppDetails| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "developerEmail",
                |m: &AppDetails| { &m.developerEmail },
                |m: &mut AppDetails| { &mut m.developerEmail },
                AppDetails::get_developerEmail,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "developerWebsite",
                |m: &AppDetails| { &m.developerWebsite },
                |m: &mut AppDetails| { &mut m.developerWebsite },
                AppDetails::get_developerWebsite,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "numDownloads",
                |m: &AppDetails| { &m.numDownloads },
                |m: &mut AppDetails| { &mut m.numDownloads },
                AppDetails::get_numDownloads,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &AppDetails| { &m.packageName },
                |m: &mut AppDetails| { &mut m.packageName },
                AppDetails::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "recentChangesHtml",
                |m: &AppDetails| { &m.recentChangesHtml },
                |m: &mut AppDetails| { &mut m.recentChangesHtml },
                AppDetails::get_recentChangesHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "uploadDate",
                |m: &AppDetails| { &m.uploadDate },
                |m: &mut AppDetails| { &mut m.uploadDate },
                AppDetails::get_uploadDate,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileMetadata>>(
                "file",
                |m: &AppDetails| { &m.file },
                |m: &mut AppDetails| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "appType",
                |m: &AppDetails| { &m.appType },
                |m: &mut AppDetails| { &mut m.appType },
                AppDetails::get_appType,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificateHash",
                |m: &AppDetails| { &m.certificateHash },
                |m: &mut AppDetails| { &mut m.certificateHash },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "variesByAccount",
                |m: &AppDetails| { &m.variesByAccount },
                |m: &mut AppDetails| { &mut m.variesByAccount },
                AppDetails::get_variesByAccount,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CertificateSet>>(
                "certificateSet",
                |m: &AppDetails| { &m.certificateSet },
                |m: &mut AppDetails| { &mut m.certificateSet },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "autoAcquireFreeAppIfHigherVersionAvailableTag",
                |m: &AppDetails| { &m.autoAcquireFreeAppIfHigherVersionAvailableTag },
                |m: &mut AppDetails| { &mut m.autoAcquireFreeAppIfHigherVersionAvailableTag },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "declaresIab",
                |m: &AppDetails| { &m.declaresIab },
                |m: &mut AppDetails| { &mut m.declaresIab },
                AppDetails::get_declaresIab,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "splitId",
                |m: &AppDetails| { &m.splitId },
                |m: &mut AppDetails| { &mut m.splitId },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "gamepadRequired",
                |m: &AppDetails| { &m.gamepadRequired },
                |m: &mut AppDetails| { &mut m.gamepadRequired },
                AppDetails::get_gamepadRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "externallyHosted",
                |m: &AppDetails| { &m.externallyHosted },
                |m: &mut AppDetails| { &mut m.externallyHosted },
                AppDetails::get_externallyHosted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "everExternallyHosted",
                |m: &AppDetails| { &m.everExternallyHosted },
                |m: &mut AppDetails| { &mut m.everExternallyHosted },
                AppDetails::get_everExternallyHosted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "installNotes",
                |m: &AppDetails| { &m.installNotes },
                |m: &mut AppDetails| { &mut m.installNotes },
                AppDetails::get_installNotes,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "installLocation",
                |m: &AppDetails| { &m.installLocation },
                |m: &mut AppDetails| { &mut m.installLocation },
                AppDetails::get_installLocation,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "targetSdkVersion",
                |m: &AppDetails| { &m.targetSdkVersion },
                |m: &mut AppDetails| { &mut m.targetSdkVersion },
                AppDetails::get_targetSdkVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "hasPreregistrationPromoCode",
                |m: &AppDetails| { &m.hasPreregistrationPromoCode },
                |m: &mut AppDetails| { &mut m.hasPreregistrationPromoCode },
                AppDetails::get_hasPreregistrationPromoCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstallDetails>, _>(
                "installDetails",
                |m: &AppDetails| { &m.installDetails },
                |m: &mut AppDetails| { &mut m.installDetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AppDetails>(
                "AppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppDetails {
        static instance: ::protobuf::rt::Lazy<AppDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(AppDetails::new)
    }
}

impl ::protobuf::Clear for AppDetails {
    fn clear(&mut self) {
        self.developerName.clear();
        self.majorVersionNumber = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.versionString.clear();
        self.title.clear();
        self.appCategory.clear();
        self.contentRating = ::std::option::Option::None;
        self.installationSize = ::std::option::Option::None;
        self.permission.clear();
        self.developerEmail.clear();
        self.developerWebsite.clear();
        self.numDownloads.clear();
        self.packageName.clear();
        self.recentChangesHtml.clear();
        self.uploadDate.clear();
        self.file.clear();
        self.appType.clear();
        self.certificateHash.clear();
        self.variesByAccount = ::std::option::Option::None;
        self.certificateSet.clear();
        self.autoAcquireFreeAppIfHigherVersionAvailableTag.clear();
        self.declaresIab = ::std::option::Option::None;
        self.splitId.clear();
        self.gamepadRequired = ::std::option::Option::None;
        self.externallyHosted = ::std::option::Option::None;
        self.everExternallyHosted = ::std::option::Option::None;
        self.installNotes.clear();
        self.installLocation = ::std::option::Option::None;
        self.targetSdkVersion = ::std::option::Option::None;
        self.hasPreregistrationPromoCode.clear();
        self.installDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CertificateSet {
    // message fields
    pub certificateHash: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CertificateSet {
    pub fn new() -> CertificateSet {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CertificateSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.certificateHash {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.certificateHash {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CertificateSet {
        CertificateSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificateHash",
                |m: &CertificateSet| { &m.certificateHash },
                |m: &mut CertificateSet| { &mut m.certificateHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CertificateSet>(
                "CertificateSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CertificateSet {
        static instance: ::protobuf::rt::Lazy<CertificateSet> = ::protobuf::rt::Lazy::INIT;
        instance.get(CertificateSet::new)
    }
}

impl ::protobuf::Clear for CertificateSet {
    fn clear(&mut self) {
        self.certificateHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CertificateSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertificateSet {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AppPermission {
    // message fields
    pub key: ::protobuf::SingularField<::std::string::String>,
    pub permissionRequired: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AppPermission {
    pub fn new() -> AppPermission {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool permissionRequired = 2;

    pub fn get_permissionRequired(&self) -> bool {
        self.permissionRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for AppPermission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.permissionRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.permissionRequired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.permissionRequired {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppPermission {
        AppPermission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "key",
                |m: &AppPermission| { &m.key },
                |m: &mut AppPermission| { &mut m.key },
                AppPermission::get_key,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "permissionRequired",
                |m: &AppPermission| { &m.permissionRequired },
                |m: &mut AppPermission| { &mut m.permissionRequired },
                AppPermission::get_permissionRequired,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AppPermission>(
                "AppPermission",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppPermission {
        static instance: ::protobuf::rt::Lazy<AppPermission> = ::protobuf::rt::Lazy::INIT;
        instance.get(AppPermission::new)
    }
}

impl ::protobuf::Clear for AppPermission {
    fn clear(&mut self) {
        self.key.clear();
        self.permissionRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppPermission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppPermission {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ArtistDetails {
    // message fields
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub externalLinks: ::protobuf::SingularPtrField<ArtistExternalLinks>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ArtistDetails {
    pub fn new() -> ArtistDetails {
        ::std::default::Default::default()
    }

    // optional string detailsUrl = 1;

    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string name = 2;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ArtistDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.externalLinks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<ArtistExternalLinks, _>(wire_type, is, &mut self.externalLinks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.externalLinks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.detailsUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.externalLinks.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtistDetails {
        ArtistDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "detailsUrl",
                |m: &ArtistDetails| { &m.detailsUrl },
                |m: &mut ArtistDetails| { &mut m.detailsUrl },
                ArtistDetails::get_detailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &ArtistDetails| { &m.name },
                |m: &mut ArtistDetails| { &mut m.name },
                ArtistDetails::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistExternalLinks>, _>(
                "externalLinks",
                |m: &ArtistDetails| { &m.externalLinks },
                |m: &mut ArtistDetails| { &mut m.externalLinks },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ArtistDetails>(
                "ArtistDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtistDetails {
        static instance: ::protobuf::rt::Lazy<ArtistDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(ArtistDetails::new)
    }
}

impl ::protobuf::Clear for ArtistDetails {
    fn clear(&mut self) {
        self.detailsUrl.clear();
        self.name.clear();
        self.externalLinks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtistDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtistDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ArtistExternalLinks {
    // message fields
    pub websiteUrl: ::protobuf::RepeatedField<::std::string::String>,
    pub googlePlusProfileUrl: ::protobuf::SingularField<::std::string::String>,
    pub youtubeChannelUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ArtistExternalLinks {
    pub fn new() -> ArtistExternalLinks {
        ::std::default::Default::default()
    }

    // optional string googlePlusProfileUrl = 2;

    pub fn get_googlePlusProfileUrl(&self) -> &str {
        match self.googlePlusProfileUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string youtubeChannelUrl = 3;

    pub fn get_youtubeChannelUrl(&self) -> &str {
        match self.youtubeChannelUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ArtistExternalLinks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.websiteUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.googlePlusProfileUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtubeChannelUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.websiteUrl {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.googlePlusProfileUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.youtubeChannelUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.websiteUrl {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.googlePlusProfileUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.youtubeChannelUrl.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtistExternalLinks {
        ArtistExternalLinks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "websiteUrl",
                |m: &ArtistExternalLinks| { &m.websiteUrl },
                |m: &mut ArtistExternalLinks| { &mut m.websiteUrl },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "googlePlusProfileUrl",
                |m: &ArtistExternalLinks| { &m.googlePlusProfileUrl },
                |m: &mut ArtistExternalLinks| { &mut m.googlePlusProfileUrl },
                ArtistExternalLinks::get_googlePlusProfileUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "youtubeChannelUrl",
                |m: &ArtistExternalLinks| { &m.youtubeChannelUrl },
                |m: &mut ArtistExternalLinks| { &mut m.youtubeChannelUrl },
                ArtistExternalLinks::get_youtubeChannelUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ArtistExternalLinks>(
                "ArtistExternalLinks",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtistExternalLinks {
        static instance: ::protobuf::rt::Lazy<ArtistExternalLinks> = ::protobuf::rt::Lazy::INIT;
        instance.get(ArtistExternalLinks::new)
    }
}

impl ::protobuf::Clear for ArtistExternalLinks {
    fn clear(&mut self) {
        self.websiteUrl.clear();
        self.googlePlusProfileUrl.clear();
        self.youtubeChannelUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtistExternalLinks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtistExternalLinks {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DocumentDetails {
    // message fields
    pub appDetails: ::protobuf::SingularPtrField<AppDetails>,
    pub albumDetails: ::protobuf::SingularPtrField<AlbumDetails>,
    pub artistDetails: ::protobuf::SingularPtrField<ArtistDetails>,
    pub songDetails: ::protobuf::SingularPtrField<SongDetails>,
    pub bookDetails: ::protobuf::SingularPtrField<BookDetails>,
    pub videoDetails: ::protobuf::SingularPtrField<VideoDetails>,
    pub subscriptionDetails: ::protobuf::SingularPtrField<SubscriptionDetails>,
    pub magazineDetails: ::protobuf::SingularPtrField<MagazineDetails>,
    pub tvShowDetails: ::protobuf::SingularPtrField<TvShowDetails>,
    pub tvSeasonDetails: ::protobuf::SingularPtrField<TvSeasonDetails>,
    pub tvEpisodeDetails: ::protobuf::SingularPtrField<TvEpisodeDetails>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DocumentDetails {
    pub fn new() -> DocumentDetails {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DocumentDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.appDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.albumDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.artistDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.songDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bookDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.videoDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.magazineDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvShowDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvSeasonDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvEpisodeDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<AppDetails, _>(wire_type, is, &mut self.appDetails)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<AlbumDetails, _>(wire_type, is, &mut self.albumDetails)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<ArtistDetails, _>(wire_type, is, &mut self.artistDetails)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<SongDetails, _>(wire_type, is, &mut self.songDetails)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<BookDetails, _>(wire_type, is, &mut self.bookDetails)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<VideoDetails, _>(wire_type, is, &mut self.videoDetails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<SubscriptionDetails, _>(wire_type, is, &mut self.subscriptionDetails)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<MagazineDetails, _>(wire_type, is, &mut self.magazineDetails)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<TvShowDetails, _>(wire_type, is, &mut self.tvShowDetails)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<TvSeasonDetails, _>(wire_type, is, &mut self.tvSeasonDetails)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<TvEpisodeDetails, _>(wire_type, is, &mut self.tvEpisodeDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.albumDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.artistDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.songDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.bookDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.videoDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.subscriptionDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.magazineDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tvShowDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tvSeasonDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tvEpisodeDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.albumDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.artistDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.songDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.bookDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.videoDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.subscriptionDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.magazineDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.tvShowDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.tvSeasonDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.tvEpisodeDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentDetails {
        DocumentDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppDetails>, _>(
                "appDetails",
                |m: &DocumentDetails| { &m.appDetails },
                |m: &mut DocumentDetails| { &mut m.appDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlbumDetails>, _>(
                "albumDetails",
                |m: &DocumentDetails| { &m.albumDetails },
                |m: &mut DocumentDetails| { &mut m.albumDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>, _>(
                "artistDetails",
                |m: &DocumentDetails| { &m.artistDetails },
                |m: &mut DocumentDetails| { &mut m.artistDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SongDetails>, _>(
                "songDetails",
                |m: &DocumentDetails| { &m.songDetails },
                |m: &mut DocumentDetails| { &mut m.songDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookDetails>, _>(
                "bookDetails",
                |m: &DocumentDetails| { &m.bookDetails },
                |m: &mut DocumentDetails| { &mut m.bookDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoDetails>, _>(
                "videoDetails",
                |m: &DocumentDetails| { &m.videoDetails },
                |m: &mut DocumentDetails| { &mut m.videoDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubscriptionDetails>, _>(
                "subscriptionDetails",
                |m: &DocumentDetails| { &m.subscriptionDetails },
                |m: &mut DocumentDetails| { &mut m.subscriptionDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MagazineDetails>, _>(
                "magazineDetails",
                |m: &DocumentDetails| { &m.magazineDetails },
                |m: &mut DocumentDetails| { &mut m.magazineDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvShowDetails>, _>(
                "tvShowDetails",
                |m: &DocumentDetails| { &m.tvShowDetails },
                |m: &mut DocumentDetails| { &mut m.tvShowDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvSeasonDetails>, _>(
                "tvSeasonDetails",
                |m: &DocumentDetails| { &m.tvSeasonDetails },
                |m: &mut DocumentDetails| { &mut m.tvSeasonDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvEpisodeDetails>, _>(
                "tvEpisodeDetails",
                |m: &DocumentDetails| { &m.tvEpisodeDetails },
                |m: &mut DocumentDetails| { &mut m.tvEpisodeDetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DocumentDetails>(
                "DocumentDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentDetails {
        static instance: ::protobuf::rt::Lazy<DocumentDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(DocumentDetails::new)
    }
}

impl ::protobuf::Clear for DocumentDetails {
    fn clear(&mut self) {
        self.appDetails.clear();
        self.albumDetails.clear();
        self.artistDetails.clear();
        self.songDetails.clear();
        self.bookDetails.clear();
        self.videoDetails.clear();
        self.subscriptionDetails.clear();
        self.magazineDetails.clear();
        self.tvShowDetails.clear();
        self.tvSeasonDetails.clear();
        self.tvEpisodeDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PatchDetails {
    // message fields
    pub baseVersionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PatchDetails {
    pub fn new() -> PatchDetails {
        ::std::default::Default::default()
    }

    // optional int32 baseVersionCode = 1;

    pub fn get_baseVersionCode(&self) -> i32 {
        self.baseVersionCode.unwrap_or(0)
    }

    // optional int64 size = 2;

    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }
}

impl ::protobuf::Message for PatchDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.baseVersionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.baseVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.baseVersionCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchDetails {
        PatchDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "baseVersionCode",
                |m: &PatchDetails| { &m.baseVersionCode },
                |m: &mut PatchDetails| { &mut m.baseVersionCode },
                PatchDetails::get_baseVersionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "size",
                |m: &PatchDetails| { &m.size },
                |m: &mut PatchDetails| { &mut m.size },
                PatchDetails::get_size,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PatchDetails>(
                "PatchDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchDetails {
        static instance: ::protobuf::rt::Lazy<PatchDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(PatchDetails::new)
    }
}

impl ::protobuf::Clear for PatchDetails {
    fn clear(&mut self) {
        self.baseVersionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct FileMetadata {
    // message fields
    pub fileType: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub splitId: ::protobuf::SingularField<::std::string::String>,
    pub compressedSize: ::std::option::Option<i64>,
    pub patchDetails: ::protobuf::RepeatedField<PatchDetails>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl FileMetadata {
    pub fn new() -> FileMetadata {
        ::std::default::Default::default()
    }

    // optional int32 fileType = 1;

    pub fn get_fileType(&self) -> i32 {
        self.fileType.unwrap_or(0)
    }

    // optional int32 versionCode = 2;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 size = 3;

    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional string splitId = 4;

    pub fn get_splitId(&self) -> &str {
        match self.splitId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 compressedSize = 5;

    pub fn get_compressedSize(&self) -> i64 {
        self.compressedSize.unwrap_or(0)
    }
}

impl ::protobuf::Message for FileMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.patchDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fileType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.splitId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compressedSize = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.patchDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.splitId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.compressedSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.patchDetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.splitId.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.compressedSize {
            os.write_int64(5, v)?;
        }
        for v in &self.patchDetails {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileMetadata {
        FileMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "fileType",
                |m: &FileMetadata| { &m.fileType },
                |m: &mut FileMetadata| { &mut m.fileType },
                FileMetadata::get_fileType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &FileMetadata| { &m.versionCode },
                |m: &mut FileMetadata| { &mut m.versionCode },
                FileMetadata::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "size",
                |m: &FileMetadata| { &m.size },
                |m: &mut FileMetadata| { &mut m.size },
                FileMetadata::get_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "splitId",
                |m: &FileMetadata| { &m.splitId },
                |m: &mut FileMetadata| { &mut m.splitId },
                FileMetadata::get_splitId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "compressedSize",
                |m: &FileMetadata| { &m.compressedSize },
                |m: &mut FileMetadata| { &mut m.compressedSize },
                FileMetadata::get_compressedSize,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchDetails>>(
                "patchDetails",
                |m: &FileMetadata| { &m.patchDetails },
                |m: &mut FileMetadata| { &mut m.patchDetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<FileMetadata>(
                "FileMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileMetadata {
        static instance: ::protobuf::rt::Lazy<FileMetadata> = ::protobuf::rt::Lazy::INIT;
        instance.get(FileMetadata::new)
    }
}

impl ::protobuf::Clear for FileMetadata {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.splitId.clear();
        self.compressedSize = ::std::option::Option::None;
        self.patchDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileMetadata {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct MagazineDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub deviceAvailabilityDescriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub psvDescription: ::protobuf::SingularField<::std::string::String>,
    pub deliveryFrequencyDescription: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl MagazineDetails {
    pub fn new() -> MagazineDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;

    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string deviceAvailabilityDescriptionHtml = 2;

    pub fn get_deviceAvailabilityDescriptionHtml(&self) -> &str {
        match self.deviceAvailabilityDescriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string psvDescription = 3;

    pub fn get_psvDescription(&self) -> &str {
        match self.psvDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string deliveryFrequencyDescription = 4;

    pub fn get_deliveryFrequencyDescription(&self) -> &str {
        match self.deliveryFrequencyDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for MagazineDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceAvailabilityDescriptionHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.psvDescription)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deliveryFrequencyDescription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.deviceAvailabilityDescriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.psvDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.deliveryFrequencyDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.deviceAvailabilityDescriptionHtml.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.psvDescription.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.deliveryFrequencyDescription.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MagazineDetails {
        MagazineDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "parentDetailsUrl",
                |m: &MagazineDetails| { &m.parentDetailsUrl },
                |m: &mut MagazineDetails| { &mut m.parentDetailsUrl },
                MagazineDetails::get_parentDetailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "deviceAvailabilityDescriptionHtml",
                |m: &MagazineDetails| { &m.deviceAvailabilityDescriptionHtml },
                |m: &mut MagazineDetails| { &mut m.deviceAvailabilityDescriptionHtml },
                MagazineDetails::get_deviceAvailabilityDescriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "psvDescription",
                |m: &MagazineDetails| { &m.psvDescription },
                |m: &mut MagazineDetails| { &mut m.psvDescription },
                MagazineDetails::get_psvDescription,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "deliveryFrequencyDescription",
                |m: &MagazineDetails| { &m.deliveryFrequencyDescription },
                |m: &mut MagazineDetails| { &mut m.deliveryFrequencyDescription },
                MagazineDetails::get_deliveryFrequencyDescription,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<MagazineDetails>(
                "MagazineDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MagazineDetails {
        static instance: ::protobuf::rt::Lazy<MagazineDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(MagazineDetails::new)
    }
}

impl ::protobuf::Clear for MagazineDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.deviceAvailabilityDescriptionHtml.clear();
        self.psvDescription.clear();
        self.deliveryFrequencyDescription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MagazineDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MagazineDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct MusicDetails {
    // message fields
    pub censoring: ::std::option::Option<i32>,
    pub durationSec: ::std::option::Option<i32>,
    pub originalReleaseDate: ::protobuf::SingularField<::std::string::String>,
    pub label: ::protobuf::SingularField<::std::string::String>,
    pub artist: ::protobuf::RepeatedField<ArtistDetails>,
    pub genre: ::protobuf::RepeatedField<::std::string::String>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub releaseType: ::std::vec::Vec<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl MusicDetails {
    pub fn new() -> MusicDetails {
        ::std::default::Default::default()
    }

    // optional int32 censoring = 1;

    pub fn get_censoring(&self) -> i32 {
        self.censoring.unwrap_or(0)
    }

    // optional int32 durationSec = 2;

    pub fn get_durationSec(&self) -> i32 {
        self.durationSec.unwrap_or(0)
    }

    // optional string originalReleaseDate = 3;

    pub fn get_originalReleaseDate(&self) -> &str {
        match self.originalReleaseDate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string label = 4;

    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string releaseDate = 7;

    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for MusicDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.artist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.censoring = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.durationSec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.originalReleaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.artist)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.genre)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.releaseType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.censoring {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.durationSec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.originalReleaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.artist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.genre {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.releaseType {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.censoring {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.durationSec {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.originalReleaseDate.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.artist {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.genre {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.releaseDate.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.releaseType {
            os.write_int32(8, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MusicDetails {
        MusicDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "censoring",
                |m: &MusicDetails| { &m.censoring },
                |m: &mut MusicDetails| { &mut m.censoring },
                MusicDetails::get_censoring,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "durationSec",
                |m: &MusicDetails| { &m.durationSec },
                |m: &mut MusicDetails| { &mut m.durationSec },
                MusicDetails::get_durationSec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "originalReleaseDate",
                |m: &MusicDetails| { &m.originalReleaseDate },
                |m: &mut MusicDetails| { &mut m.originalReleaseDate },
                MusicDetails::get_originalReleaseDate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "label",
                |m: &MusicDetails| { &m.label },
                |m: &mut MusicDetails| { &mut m.label },
                MusicDetails::get_label,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "artist",
                |m: &MusicDetails| { &m.artist },
                |m: &mut MusicDetails| { &mut m.artist },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "genre",
                |m: &MusicDetails| { &m.genre },
                |m: &mut MusicDetails| { &mut m.genre },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "releaseDate",
                |m: &MusicDetails| { &m.releaseDate },
                |m: &mut MusicDetails| { &mut m.releaseDate },
                MusicDetails::get_releaseDate,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "releaseType",
                |m: &MusicDetails| { &m.releaseType },
                |m: &mut MusicDetails| { &mut m.releaseType },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<MusicDetails>(
                "MusicDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MusicDetails {
        static instance: ::protobuf::rt::Lazy<MusicDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(MusicDetails::new)
    }
}

impl ::protobuf::Clear for MusicDetails {
    fn clear(&mut self) {
        self.censoring = ::std::option::Option::None;
        self.durationSec = ::std::option::Option::None;
        self.originalReleaseDate.clear();
        self.label.clear();
        self.artist.clear();
        self.genre.clear();
        self.releaseDate.clear();
        self.releaseType.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MusicDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MusicDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct NewsDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub psvDescription: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl NewsDetails {
    pub fn new() -> NewsDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;

    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string psvDescription = 3;

    pub fn get_psvDescription(&self) -> &str {
        match self.psvDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for NewsDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.psvDescription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.psvDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.psvDescription.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewsDetails {
        NewsDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "parentDetailsUrl",
                |m: &NewsDetails| { &m.parentDetailsUrl },
                |m: &mut NewsDetails| { &mut m.parentDetailsUrl },
                NewsDetails::get_parentDetailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "psvDescription",
                |m: &NewsDetails| { &m.psvDescription },
                |m: &mut NewsDetails| { &mut m.psvDescription },
                NewsDetails::get_psvDescription,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<NewsDetails>(
                "NewsDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NewsDetails {
        static instance: ::protobuf::rt::Lazy<NewsDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(NewsDetails::new)
    }
}

impl ::protobuf::Clear for NewsDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.psvDescription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewsDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewsDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SongDetails {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<MusicDetails>,
    pub albumName: ::protobuf::SingularField<::std::string::String>,
    pub trackNumber: ::std::option::Option<i32>,
    pub previewUrl: ::protobuf::SingularField<::std::string::String>,
    pub displayArtist: ::protobuf::SingularPtrField<ArtistDetails>,
    pub badge: ::protobuf::SingularPtrField<Badge>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SongDetails {
    pub fn new() -> SongDetails {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string albumName = 3;

    pub fn get_albumName(&self) -> &str {
        match self.albumName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 trackNumber = 4;

    pub fn get_trackNumber(&self) -> i32 {
        self.trackNumber.unwrap_or(0)
    }

    // optional string previewUrl = 5;

    pub fn get_previewUrl(&self) -> &str {
        match self.previewUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SongDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.displayArtist {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<MusicDetails, _>(wire_type, is, &mut self.details)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.albumName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trackNumber = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.previewUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<ArtistDetails, _>(wire_type, is, &mut self.displayArtist)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<Badge, _>(wire_type, is, &mut self.badge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.albumName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.trackNumber {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.previewUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.displayArtist.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.badge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.albumName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.trackNumber {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.previewUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.displayArtist.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.badge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SongDetails {
        SongDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &SongDetails| { &m.name },
                |m: &mut SongDetails| { &mut m.name },
                SongDetails::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MusicDetails>, _>(
                "details",
                |m: &SongDetails| { &m.details },
                |m: &mut SongDetails| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "albumName",
                |m: &SongDetails| { &m.albumName },
                |m: &mut SongDetails| { &mut m.albumName },
                SongDetails::get_albumName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "trackNumber",
                |m: &SongDetails| { &m.trackNumber },
                |m: &mut SongDetails| { &mut m.trackNumber },
                SongDetails::get_trackNumber,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "previewUrl",
                |m: &SongDetails| { &m.previewUrl },
                |m: &mut SongDetails| { &mut m.previewUrl },
                SongDetails::get_previewUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>, _>(
                "displayArtist",
                |m: &SongDetails| { &m.displayArtist },
                |m: &mut SongDetails| { &mut m.displayArtist },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>, _>(
                "badge",
                |m: &SongDetails| { &m.badge },
                |m: &mut SongDetails| { &mut m.badge },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SongDetails>(
                "SongDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SongDetails {
        static instance: ::protobuf::rt::Lazy<SongDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(SongDetails::new)
    }
}

impl ::protobuf::Clear for SongDetails {
    fn clear(&mut self) {
        self.name.clear();
        self.details.clear();
        self.albumName.clear();
        self.trackNumber = ::std::option::Option::None;
        self.previewUrl.clear();
        self.displayArtist.clear();
        self.badge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SongDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SongDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SubscriptionDetails {
    // message fields
    pub subscriptionPeriod: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SubscriptionDetails {
    pub fn new() -> SubscriptionDetails {
        ::std::default::Default::default()
    }

    // optional int32 subscriptionPeriod = 1;

    pub fn get_subscriptionPeriod(&self) -> i32 {
        self.subscriptionPeriod.unwrap_or(0)
    }
}

impl ::protobuf::Message for SubscriptionDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.subscriptionPeriod = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subscriptionPeriod {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subscriptionPeriod {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionDetails {
        SubscriptionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "subscriptionPeriod",
                |m: &SubscriptionDetails| { &m.subscriptionPeriod },
                |m: &mut SubscriptionDetails| { &mut m.subscriptionPeriod },
                SubscriptionDetails::get_subscriptionPeriod,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SubscriptionDetails>(
                "SubscriptionDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscriptionDetails {
        static instance: ::protobuf::rt::Lazy<SubscriptionDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(SubscriptionDetails::new)
    }
}

impl ::protobuf::Clear for SubscriptionDetails {
    fn clear(&mut self) {
        self.subscriptionPeriod = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Trailer {
    // message fields
    pub trailerId: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub thumbnailUrl: ::protobuf::SingularField<::std::string::String>,
    pub watchUrl: ::protobuf::SingularField<::std::string::String>,
    pub duration: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Trailer {
    pub fn new() -> Trailer {
        ::std::default::Default::default()
    }

    // optional string trailerId = 1;

    pub fn get_trailerId(&self) -> &str {
        match self.trailerId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string title = 2;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string thumbnailUrl = 3;

    pub fn get_thumbnailUrl(&self) -> &str {
        match self.thumbnailUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string watchUrl = 4;

    pub fn get_watchUrl(&self) -> &str {
        match self.watchUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string duration = 5;

    pub fn get_duration(&self) -> &str {
        match self.duration.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Trailer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.trailerId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnailUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.watchUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trailerId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.thumbnailUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.watchUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.duration.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trailerId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.thumbnailUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.watchUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.duration.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Trailer {
        Trailer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "trailerId",
                |m: &Trailer| { &m.trailerId },
                |m: &mut Trailer| { &mut m.trailerId },
                Trailer::get_trailerId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &Trailer| { &m.title },
                |m: &mut Trailer| { &mut m.title },
                Trailer::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "thumbnailUrl",
                |m: &Trailer| { &m.thumbnailUrl },
                |m: &mut Trailer| { &mut m.thumbnailUrl },
                Trailer::get_thumbnailUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "watchUrl",
                |m: &Trailer| { &m.watchUrl },
                |m: &mut Trailer| { &mut m.watchUrl },
                Trailer::get_watchUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "duration",
                |m: &Trailer| { &m.duration },
                |m: &mut Trailer| { &mut m.duration },
                Trailer::get_duration,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Trailer>(
                "Trailer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Trailer {
        static instance: ::protobuf::rt::Lazy<Trailer> = ::protobuf::rt::Lazy::INIT;
        instance.get(Trailer::new)
    }
}

impl ::protobuf::Clear for Trailer {
    fn clear(&mut self) {
        self.trailerId.clear();
        self.title.clear();
        self.thumbnailUrl.clear();
        self.watchUrl.clear();
        self.duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Trailer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trailer {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct TvEpisodeDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub episodeIndex: ::std::option::Option<i32>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl TvEpisodeDetails {
    pub fn new() -> TvEpisodeDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;

    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 episodeIndex = 2;

    pub fn get_episodeIndex(&self) -> i32 {
        self.episodeIndex.unwrap_or(0)
    }

    // optional string releaseDate = 3;

    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TvEpisodeDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.episodeIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.episodeIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.episodeIndex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.releaseDate.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvEpisodeDetails {
        TvEpisodeDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "parentDetailsUrl",
                |m: &TvEpisodeDetails| { &m.parentDetailsUrl },
                |m: &mut TvEpisodeDetails| { &mut m.parentDetailsUrl },
                TvEpisodeDetails::get_parentDetailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "episodeIndex",
                |m: &TvEpisodeDetails| { &m.episodeIndex },
                |m: &mut TvEpisodeDetails| { &mut m.episodeIndex },
                TvEpisodeDetails::get_episodeIndex,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "releaseDate",
                |m: &TvEpisodeDetails| { &m.releaseDate },
                |m: &mut TvEpisodeDetails| { &mut m.releaseDate },
                TvEpisodeDetails::get_releaseDate,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<TvEpisodeDetails>(
                "TvEpisodeDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvEpisodeDetails {
        static instance: ::protobuf::rt::Lazy<TvEpisodeDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(TvEpisodeDetails::new)
    }
}

impl ::protobuf::Clear for TvEpisodeDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.episodeIndex = ::std::option::Option::None;
        self.releaseDate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvEpisodeDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvEpisodeDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct TvSeasonDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub seasonIndex: ::std::option::Option<i32>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub broadcaster: ::protobuf::SingularField<::std::string::String>,
    pub episodeCount: ::std::option::Option<i32>,
    pub expectedEpisodeCount: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl TvSeasonDetails {
    pub fn new() -> TvSeasonDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;

    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 seasonIndex = 2;

    pub fn get_seasonIndex(&self) -> i32 {
        self.seasonIndex.unwrap_or(0)
    }

    // optional string releaseDate = 3;

    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string broadcaster = 4;

    pub fn get_broadcaster(&self) -> &str {
        match self.broadcaster.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 episodeCount = 5;

    pub fn get_episodeCount(&self) -> i32 {
        self.episodeCount.unwrap_or(0)
    }

    // optional int32 expectedEpisodeCount = 6;

    pub fn get_expectedEpisodeCount(&self) -> i32 {
        self.expectedEpisodeCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for TvSeasonDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seasonIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.broadcaster)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.episodeCount = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expectedEpisodeCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seasonIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.broadcaster.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.episodeCount {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expectedEpisodeCount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.seasonIndex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.releaseDate.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.broadcaster.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.episodeCount {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.expectedEpisodeCount {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvSeasonDetails {
        TvSeasonDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "parentDetailsUrl",
                |m: &TvSeasonDetails| { &m.parentDetailsUrl },
                |m: &mut TvSeasonDetails| { &mut m.parentDetailsUrl },
                TvSeasonDetails::get_parentDetailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "seasonIndex",
                |m: &TvSeasonDetails| { &m.seasonIndex },
                |m: &mut TvSeasonDetails| { &mut m.seasonIndex },
                TvSeasonDetails::get_seasonIndex,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "releaseDate",
                |m: &TvSeasonDetails| { &m.releaseDate },
                |m: &mut TvSeasonDetails| { &mut m.releaseDate },
                TvSeasonDetails::get_releaseDate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "broadcaster",
                |m: &TvSeasonDetails| { &m.broadcaster },
                |m: &mut TvSeasonDetails| { &mut m.broadcaster },
                TvSeasonDetails::get_broadcaster,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "episodeCount",
                |m: &TvSeasonDetails| { &m.episodeCount },
                |m: &mut TvSeasonDetails| { &mut m.episodeCount },
                TvSeasonDetails::get_episodeCount,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "expectedEpisodeCount",
                |m: &TvSeasonDetails| { &m.expectedEpisodeCount },
                |m: &mut TvSeasonDetails| { &mut m.expectedEpisodeCount },
                TvSeasonDetails::get_expectedEpisodeCount,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<TvSeasonDetails>(
                "TvSeasonDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvSeasonDetails {
        static instance: ::protobuf::rt::Lazy<TvSeasonDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(TvSeasonDetails::new)
    }
}

impl ::protobuf::Clear for TvSeasonDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.seasonIndex = ::std::option::Option::None;
        self.releaseDate.clear();
        self.broadcaster.clear();
        self.episodeCount = ::std::option::Option::None;
        self.expectedEpisodeCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvSeasonDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvSeasonDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct TvShowDetails {
    // message fields
    pub seasonCount: ::std::option::Option<i32>,
    pub startYear: ::std::option::Option<i32>,
    pub endYear: ::std::option::Option<i32>,
    pub broadcaster: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl TvShowDetails {
    pub fn new() -> TvShowDetails {
        ::std::default::Default::default()
    }

    // optional int32 seasonCount = 1;

    pub fn get_seasonCount(&self) -> i32 {
        self.seasonCount.unwrap_or(0)
    }

    // optional int32 startYear = 2;

    pub fn get_startYear(&self) -> i32 {
        self.startYear.unwrap_or(0)
    }

    // optional int32 endYear = 3;

    pub fn get_endYear(&self) -> i32 {
        self.endYear.unwrap_or(0)
    }

    // optional string broadcaster = 4;

    pub fn get_broadcaster(&self) -> &str {
        match self.broadcaster.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TvShowDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seasonCount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.startYear = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.endYear = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.broadcaster)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seasonCount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startYear {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endYear {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.broadcaster.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seasonCount {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.startYear {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.endYear {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.broadcaster.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvShowDetails {
        TvShowDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "seasonCount",
                |m: &TvShowDetails| { &m.seasonCount },
                |m: &mut TvShowDetails| { &mut m.seasonCount },
                TvShowDetails::get_seasonCount,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "startYear",
                |m: &TvShowDetails| { &m.startYear },
                |m: &mut TvShowDetails| { &mut m.startYear },
                TvShowDetails::get_startYear,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "endYear",
                |m: &TvShowDetails| { &m.endYear },
                |m: &mut TvShowDetails| { &mut m.endYear },
                TvShowDetails::get_endYear,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "broadcaster",
                |m: &TvShowDetails| { &m.broadcaster },
                |m: &mut TvShowDetails| { &mut m.broadcaster },
                TvShowDetails::get_broadcaster,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<TvShowDetails>(
                "TvShowDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvShowDetails {
        static instance: ::protobuf::rt::Lazy<TvShowDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(TvShowDetails::new)
    }
}

impl ::protobuf::Clear for TvShowDetails {
    fn clear(&mut self) {
        self.seasonCount = ::std::option::Option::None;
        self.startYear = ::std::option::Option::None;
        self.endYear = ::std::option::Option::None;
        self.broadcaster.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvShowDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvShowDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct VideoCredit {
    // message fields
    pub creditType: ::std::option::Option<i32>,
    pub credit: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl VideoCredit {
    pub fn new() -> VideoCredit {
        ::std::default::Default::default()
    }

    // optional int32 creditType = 1;

    pub fn get_creditType(&self) -> i32 {
        self.creditType.unwrap_or(0)
    }

    // optional string credit = 2;

    pub fn get_credit(&self) -> &str {
        match self.credit.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoCredit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.creditType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.credit)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.creditType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.credit.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.name {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.creditType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.credit.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.name {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoCredit {
        VideoCredit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "creditType",
                |m: &VideoCredit| { &m.creditType },
                |m: &mut VideoCredit| { &mut m.creditType },
                VideoCredit::get_creditType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "credit",
                |m: &VideoCredit| { &m.credit },
                |m: &mut VideoCredit| { &mut m.credit },
                VideoCredit::get_credit,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VideoCredit| { &m.name },
                |m: &mut VideoCredit| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<VideoCredit>(
                "VideoCredit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoCredit {
        static instance: ::protobuf::rt::Lazy<VideoCredit> = ::protobuf::rt::Lazy::INIT;
        instance.get(VideoCredit::new)
    }
}

impl ::protobuf::Clear for VideoCredit {
    fn clear(&mut self) {
        self.creditType = ::std::option::Option::None;
        self.credit.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoCredit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoCredit {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct VideoDetails {
    // message fields
    pub credit: ::protobuf::RepeatedField<VideoCredit>,
    pub duration: ::protobuf::SingularField<::std::string::String>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub contentRating: ::protobuf::SingularField<::std::string::String>,
    pub likes: ::std::option::Option<i64>,
    pub dislikes: ::std::option::Option<i64>,
    pub genre: ::protobuf::RepeatedField<::std::string::String>,
    pub trailer: ::protobuf::RepeatedField<Trailer>,
    pub rentalTerm: ::protobuf::RepeatedField<VideoRentalTerm>,
    pub audioLanguage: ::protobuf::RepeatedField<::std::string::String>,
    pub captionLanguage: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl VideoDetails {
    pub fn new() -> VideoDetails {
        ::std::default::Default::default()
    }

    // optional string duration = 2;

    pub fn get_duration(&self) -> &str {
        match self.duration.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string releaseDate = 3;

    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string contentRating = 4;

    pub fn get_contentRating(&self) -> &str {
        match self.contentRating.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 likes = 5;

    pub fn get_likes(&self) -> i64 {
        self.likes.unwrap_or(0)
    }

    // optional int64 dislikes = 6;

    pub fn get_dislikes(&self) -> i64 {
        self.dislikes.unwrap_or(0)
    }
}

impl ::protobuf::Message for VideoDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.credit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trailer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rentalTerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.credit)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.duration)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentRating)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.likes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dislikes = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.genre)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.trailer)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.rentalTerm)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.audioLanguage)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.captionLanguage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.credit {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.duration.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.contentRating.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.likes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dislikes {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.genre {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.trailer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.rentalTerm {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.audioLanguage {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.captionLanguage {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.credit {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.duration.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.releaseDate.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.contentRating.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.likes {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.dislikes {
            os.write_int64(6, v)?;
        }
        for v in &self.genre {
            os.write_string(7, &v)?;
        };
        for v in &self.trailer {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.rentalTerm {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.audioLanguage {
            os.write_string(10, &v)?;
        };
        for v in &self.captionLanguage {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoDetails {
        VideoDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoCredit>>(
                "credit",
                |m: &VideoDetails| { &m.credit },
                |m: &mut VideoDetails| { &mut m.credit },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "duration",
                |m: &VideoDetails| { &m.duration },
                |m: &mut VideoDetails| { &mut m.duration },
                VideoDetails::get_duration,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "releaseDate",
                |m: &VideoDetails| { &m.releaseDate },
                |m: &mut VideoDetails| { &mut m.releaseDate },
                VideoDetails::get_releaseDate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contentRating",
                |m: &VideoDetails| { &m.contentRating },
                |m: &mut VideoDetails| { &mut m.contentRating },
                VideoDetails::get_contentRating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "likes",
                |m: &VideoDetails| { &m.likes },
                |m: &mut VideoDetails| { &mut m.likes },
                VideoDetails::get_likes,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "dislikes",
                |m: &VideoDetails| { &m.dislikes },
                |m: &mut VideoDetails| { &mut m.dislikes },
                VideoDetails::get_dislikes,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "genre",
                |m: &VideoDetails| { &m.genre },
                |m: &mut VideoDetails| { &mut m.genre },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Trailer>>(
                "trailer",
                |m: &VideoDetails| { &m.trailer },
                |m: &mut VideoDetails| { &mut m.trailer },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoRentalTerm>>(
                "rentalTerm",
                |m: &VideoDetails| { &m.rentalTerm },
                |m: &mut VideoDetails| { &mut m.rentalTerm },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audioLanguage",
                |m: &VideoDetails| { &m.audioLanguage },
                |m: &mut VideoDetails| { &mut m.audioLanguage },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "captionLanguage",
                |m: &VideoDetails| { &m.captionLanguage },
                |m: &mut VideoDetails| { &mut m.captionLanguage },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<VideoDetails>(
                "VideoDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoDetails {
        static instance: ::protobuf::rt::Lazy<VideoDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(VideoDetails::new)
    }
}

impl ::protobuf::Clear for VideoDetails {
    fn clear(&mut self) {
        self.credit.clear();
        self.duration.clear();
        self.releaseDate.clear();
        self.contentRating.clear();
        self.likes = ::std::option::Option::None;
        self.dislikes = ::std::option::Option::None;
        self.genre.clear();
        self.trailer.clear();
        self.rentalTerm.clear();
        self.audioLanguage.clear();
        self.captionLanguage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct VideoRentalTerm {
    // message fields
    pub offerType: ::std::option::Option<i32>,
    pub offerAbbreviation: ::protobuf::SingularField<::std::string::String>,
    pub rentalHeader: ::protobuf::SingularField<::std::string::String>,
    // term: <group>
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl VideoRentalTerm {
    pub fn new() -> VideoRentalTerm {
        ::std::default::Default::default()
    }

    // optional int32 offerType = 1;

    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional string offerAbbreviation = 2;

    pub fn get_offerAbbreviation(&self) -> &str {
        match self.offerAbbreviation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string rentalHeader = 3;

    pub fn get_rentalHeader(&self) -> &str {
        match self.rentalHeader.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoRentalTerm {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerAbbreviation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rentalHeader)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offerAbbreviation.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.rentalHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offerType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.offerAbbreviation.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.rentalHeader.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoRentalTerm {
        VideoRentalTerm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "offerType",
                |m: &VideoRentalTerm| { &m.offerType },
                |m: &mut VideoRentalTerm| { &mut m.offerType },
                VideoRentalTerm::get_offerType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "offerAbbreviation",
                |m: &VideoRentalTerm| { &m.offerAbbreviation },
                |m: &mut VideoRentalTerm| { &mut m.offerAbbreviation },
                VideoRentalTerm::get_offerAbbreviation,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "rentalHeader",
                |m: &VideoRentalTerm| { &m.rentalHeader },
                |m: &mut VideoRentalTerm| { &mut m.rentalHeader },
                VideoRentalTerm::get_rentalHeader,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<VideoRentalTerm>(
                "VideoRentalTerm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoRentalTerm {
        static instance: ::protobuf::rt::Lazy<VideoRentalTerm> = ::protobuf::rt::Lazy::INIT;
        instance.get(VideoRentalTerm::new)
    }
}

impl ::protobuf::Clear for VideoRentalTerm {
    fn clear(&mut self) {
        self.offerType = ::std::option::Option::None;
        self.offerAbbreviation.clear();
        self.rentalHeader.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoRentalTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoRentalTerm {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct VideoRentalTerm_Term {
    // message fields
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub body: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl VideoRentalTerm_Term {
    pub fn new() -> VideoRentalTerm_Term {
        ::std::default::Default::default()
    }

    // optional string header = 5;

    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string body = 6;

    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoRentalTerm_Term {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.header.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoRentalTerm_Term {
        VideoRentalTerm_Term::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "header",
                |m: &VideoRentalTerm_Term| { &m.header },
                |m: &mut VideoRentalTerm_Term| { &mut m.header },
                VideoRentalTerm_Term::get_header,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "body",
                |m: &VideoRentalTerm_Term| { &m.body },
                |m: &mut VideoRentalTerm_Term| { &mut m.body },
                VideoRentalTerm_Term::get_body,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<VideoRentalTerm_Term>(
                "VideoRentalTerm_Term",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoRentalTerm_Term {
        static instance: ::protobuf::rt::Lazy<VideoRentalTerm_Term> = ::protobuf::rt::Lazy::INIT;
        instance.get(VideoRentalTerm_Term::new)
    }
}

impl ::protobuf::Clear for VideoRentalTerm_Term {
    fn clear(&mut self) {
        self.header.clear();
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoRentalTerm_Term {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoRentalTerm_Term {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Bucket {
    // message fields
    pub document: ::protobuf::RepeatedField<DocV1>,
    pub multiCorpus: ::std::option::Option<bool>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub iconUrl: ::protobuf::SingularField<::std::string::String>,
    pub fullContentsUrl: ::protobuf::SingularField<::std::string::String>,
    pub relevance: ::std::option::Option<f64>,
    pub estimatedResults: ::std::option::Option<i64>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub fullContentsListUrl: ::protobuf::SingularField<::std::string::String>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub ordered: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Bucket {
    pub fn new() -> Bucket {
        ::std::default::Default::default()
    }

    // optional bool multiCorpus = 2;

    pub fn get_multiCorpus(&self) -> bool {
        self.multiCorpus.unwrap_or(false)
    }

    // optional string title = 3;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string iconUrl = 4;

    pub fn get_iconUrl(&self) -> &str {
        match self.iconUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string fullContentsUrl = 5;

    pub fn get_fullContentsUrl(&self) -> &str {
        match self.fullContentsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional double relevance = 6;

    pub fn get_relevance(&self) -> f64 {
        self.relevance.unwrap_or(0.)
    }

    // optional int64 estimatedResults = 7;

    pub fn get_estimatedResults(&self) -> i64 {
        self.estimatedResults.unwrap_or(0)
    }

    // optional string analyticsCookie = 8;

    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string fullContentsListUrl = 9;

    pub fn get_fullContentsListUrl(&self) -> &str {
        match self.fullContentsListUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string nextPageUrl = 10;

    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool ordered = 11;

    pub fn get_ordered(&self) -> bool {
        self.ordered.unwrap_or(false)
    }
}

impl ::protobuf::Message for Bucket {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.document)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.multiCorpus = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iconUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fullContentsUrl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.relevance = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.estimatedResults = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fullContentsListUrl)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ordered = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.document {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.multiCorpus {
            my_size += 2;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.iconUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.fullContentsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.relevance {
            my_size += 9;
        }
        if let Some(v) = self.estimatedResults {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fullContentsListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.ordered {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.document {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.multiCorpus {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.iconUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.fullContentsUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.relevance {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.estimatedResults {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.analyticsCookie.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fullContentsListUrl.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.nextPageUrl.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.ordered {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket {
        Bucket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV1>>(
                "document",
                |m: &Bucket| { &m.document },
                |m: &mut Bucket| { &mut m.document },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "multiCorpus",
                |m: &Bucket| { &m.multiCorpus },
                |m: &mut Bucket| { &mut m.multiCorpus },
                Bucket::get_multiCorpus,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &Bucket| { &m.title },
                |m: &mut Bucket| { &mut m.title },
                Bucket::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "iconUrl",
                |m: &Bucket| { &m.iconUrl },
                |m: &mut Bucket| { &mut m.iconUrl },
                Bucket::get_iconUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "fullContentsUrl",
                |m: &Bucket| { &m.fullContentsUrl },
                |m: &mut Bucket| { &mut m.fullContentsUrl },
                Bucket::get_fullContentsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeDouble, _>(
                "relevance",
                |m: &Bucket| { &m.relevance },
                |m: &mut Bucket| { &mut m.relevance },
                Bucket::get_relevance,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "estimatedResults",
                |m: &Bucket| { &m.estimatedResults },
                |m: &mut Bucket| { &mut m.estimatedResults },
                Bucket::get_estimatedResults,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "analyticsCookie",
                |m: &Bucket| { &m.analyticsCookie },
                |m: &mut Bucket| { &mut m.analyticsCookie },
                Bucket::get_analyticsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "fullContentsListUrl",
                |m: &Bucket| { &m.fullContentsListUrl },
                |m: &mut Bucket| { &mut m.fullContentsListUrl },
                Bucket::get_fullContentsListUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "nextPageUrl",
                |m: &Bucket| { &m.nextPageUrl },
                |m: &mut Bucket| { &mut m.nextPageUrl },
                Bucket::get_nextPageUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "ordered",
                |m: &Bucket| { &m.ordered },
                |m: &mut Bucket| { &mut m.ordered },
                Bucket::get_ordered,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Bucket>(
                "Bucket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket {
        static instance: ::protobuf::rt::Lazy<Bucket> = ::protobuf::rt::Lazy::INIT;
        instance.get(Bucket::new)
    }
}

impl ::protobuf::Clear for Bucket {
    fn clear(&mut self) {
        self.document.clear();
        self.multiCorpus = ::std::option::Option::None;
        self.title.clear();
        self.iconUrl.clear();
        self.fullContentsUrl.clear();
        self.relevance = ::std::option::Option::None;
        self.estimatedResults = ::std::option::Option::None;
        self.analyticsCookie.clear();
        self.fullContentsListUrl.clear();
        self.nextPageUrl.clear();
        self.ordered = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ListResponse {
    // message fields
    pub bucket: ::protobuf::RepeatedField<Bucket>,
    pub doc: ::protobuf::RepeatedField<DocV2>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ListResponse {
    pub fn new() -> ListResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.doc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.doc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bucket {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.doc {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListResponse {
        ListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket>>(
                "bucket",
                |m: &ListResponse| { &m.bucket },
                |m: &mut ListResponse| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "doc",
                |m: &ListResponse| { &m.doc },
                |m: &mut ListResponse| { &mut m.doc },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ListResponse>(
                "ListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListResponse {
        static instance: ::protobuf::rt::Lazy<ListResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ListResponse::new)
    }
}

impl ::protobuf::Clear for ListResponse {
    fn clear(&mut self) {
        self.bucket.clear();
        self.doc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DocV1 {
    // message fields
    pub finskyDoc: ::protobuf::SingularPtrField<Document>,
    pub docid: ::protobuf::SingularField<::std::string::String>,
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub reviewsUrl: ::protobuf::SingularField<::std::string::String>,
    pub relatedListUrl: ::protobuf::SingularField<::std::string::String>,
    pub moreByListUrl: ::protobuf::SingularField<::std::string::String>,
    pub shareUrl: ::protobuf::SingularField<::std::string::String>,
    pub creator: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<DocumentDetails>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub relatedBrowseUrl: ::protobuf::SingularField<::std::string::String>,
    pub moreByBrowseUrl: ::protobuf::SingularField<::std::string::String>,
    pub relatedHeader: ::protobuf::SingularField<::std::string::String>,
    pub moreByHeader: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub plusOneData: ::protobuf::SingularPtrField<PlusOneData>,
    pub warningMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DocV1 {
    pub fn new() -> DocV1 {
        ::std::default::Default::default()
    }

    // optional string docid = 2;

    pub fn get_docid(&self) -> &str {
        match self.docid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string detailsUrl = 3;

    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string reviewsUrl = 4;

    pub fn get_reviewsUrl(&self) -> &str {
        match self.reviewsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string relatedListUrl = 5;

    pub fn get_relatedListUrl(&self) -> &str {
        match self.relatedListUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string moreByListUrl = 6;

    pub fn get_moreByListUrl(&self) -> &str {
        match self.moreByListUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string shareUrl = 7;

    pub fn get_shareUrl(&self) -> &str {
        match self.shareUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string creator = 8;

    pub fn get_creator(&self) -> &str {
        match self.creator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string descriptionHtml = 10;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string relatedBrowseUrl = 11;

    pub fn get_relatedBrowseUrl(&self) -> &str {
        match self.relatedBrowseUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string moreByBrowseUrl = 12;

    pub fn get_moreByBrowseUrl(&self) -> &str {
        match self.moreByBrowseUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string relatedHeader = 13;

    pub fn get_relatedHeader(&self) -> &str {
        match self.relatedHeader.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string moreByHeader = 14;

    pub fn get_moreByHeader(&self) -> &str {
        match self.moreByHeader.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string title = 15;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string warningMessage = 17;

    pub fn get_warningMessage(&self) -> &str {
        match self.warningMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DocV1 {
    fn is_initialized(&self) -> bool {
        for v in &self.finskyDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusOneData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Document, _>(wire_type, is, &mut self.finskyDoc)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reviewsUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedListUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByListUrl)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareUrl)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creator)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<DocumentDetails, _>(wire_type, is, &mut self.details)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedBrowseUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByBrowseUrl)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedHeader)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByHeader)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into::<PlusOneData, _>(wire_type, is, &mut self.plusOneData)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.warningMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.finskyDoc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.docid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.reviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.relatedListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.moreByListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.shareUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.creator.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.relatedBrowseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.moreByBrowseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.relatedHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.moreByHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.plusOneData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.warningMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.finskyDoc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.docid.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.detailsUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.reviewsUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.relatedListUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.moreByListUrl.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.shareUrl.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.creator.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.relatedBrowseUrl.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.moreByBrowseUrl.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.relatedHeader.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.moreByHeader.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.plusOneData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.warningMessage.as_ref() {
            os.write_string(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocV1 {
        DocV1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>, _>(
                "finskyDoc",
                |m: &DocV1| { &m.finskyDoc },
                |m: &mut DocV1| { &mut m.finskyDoc },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "docid",
                |m: &DocV1| { &m.docid },
                |m: &mut DocV1| { &mut m.docid },
                DocV1::get_docid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "detailsUrl",
                |m: &DocV1| { &m.detailsUrl },
                |m: &mut DocV1| { &mut m.detailsUrl },
                DocV1::get_detailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "reviewsUrl",
                |m: &DocV1| { &m.reviewsUrl },
                |m: &mut DocV1| { &mut m.reviewsUrl },
                DocV1::get_reviewsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "relatedListUrl",
                |m: &DocV1| { &m.relatedListUrl },
                |m: &mut DocV1| { &mut m.relatedListUrl },
                DocV1::get_relatedListUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "moreByListUrl",
                |m: &DocV1| { &m.moreByListUrl },
                |m: &mut DocV1| { &mut m.moreByListUrl },
                DocV1::get_moreByListUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "shareUrl",
                |m: &DocV1| { &m.shareUrl },
                |m: &mut DocV1| { &mut m.shareUrl },
                DocV1::get_shareUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "creator",
                |m: &DocV1| { &m.creator },
                |m: &mut DocV1| { &mut m.creator },
                DocV1::get_creator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentDetails>, _>(
                "details",
                |m: &DocV1| { &m.details },
                |m: &mut DocV1| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &DocV1| { &m.descriptionHtml },
                |m: &mut DocV1| { &mut m.descriptionHtml },
                DocV1::get_descriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "relatedBrowseUrl",
                |m: &DocV1| { &m.relatedBrowseUrl },
                |m: &mut DocV1| { &mut m.relatedBrowseUrl },
                DocV1::get_relatedBrowseUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "moreByBrowseUrl",
                |m: &DocV1| { &m.moreByBrowseUrl },
                |m: &mut DocV1| { &mut m.moreByBrowseUrl },
                DocV1::get_moreByBrowseUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "relatedHeader",
                |m: &DocV1| { &m.relatedHeader },
                |m: &mut DocV1| { &mut m.relatedHeader },
                DocV1::get_relatedHeader,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "moreByHeader",
                |m: &DocV1| { &m.moreByHeader },
                |m: &mut DocV1| { &mut m.moreByHeader },
                DocV1::get_moreByHeader,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &DocV1| { &m.title },
                |m: &mut DocV1| { &mut m.title },
                DocV1::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusOneData>, _>(
                "plusOneData",
                |m: &DocV1| { &m.plusOneData },
                |m: &mut DocV1| { &mut m.plusOneData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "warningMessage",
                |m: &DocV1| { &m.warningMessage },
                |m: &mut DocV1| { &mut m.warningMessage },
                DocV1::get_warningMessage,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DocV1>(
                "DocV1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocV1 {
        static instance: ::protobuf::rt::Lazy<DocV1> = ::protobuf::rt::Lazy::INIT;
        instance.get(DocV1::new)
    }
}

impl ::protobuf::Clear for DocV1 {
    fn clear(&mut self) {
        self.finskyDoc.clear();
        self.docid.clear();
        self.detailsUrl.clear();
        self.reviewsUrl.clear();
        self.relatedListUrl.clear();
        self.moreByListUrl.clear();
        self.shareUrl.clear();
        self.creator.clear();
        self.details.clear();
        self.descriptionHtml.clear();
        self.relatedBrowseUrl.clear();
        self.moreByBrowseUrl.clear();
        self.relatedHeader.clear();
        self.moreByHeader.clear();
        self.title.clear();
        self.plusOneData.clear();
        self.warningMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocV1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocV1 {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Annotations {
    // message fields
    pub sectionRelated: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionMoreBy: ::protobuf::SingularPtrField<SectionMetadata>,
    pub plusOneData: ::protobuf::SingularPtrField<PlusOneData>,
    pub warning: ::protobuf::RepeatedField<Warning>,
    pub sectionBodyOfWork: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionCoreContent: ::protobuf::SingularPtrField<SectionMetadata>,
    pub template: ::protobuf::SingularPtrField<Template>,
    pub badgeForCreator: ::protobuf::RepeatedField<Badge>,
    pub badgeForDoc: ::protobuf::RepeatedField<Badge>,
    pub link: ::protobuf::SingularPtrField<Link>,
    pub sectionCrossSell: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionRelatedDocType: ::protobuf::SingularPtrField<SectionMetadata>,
    pub promotedDoc: ::protobuf::RepeatedField<PromotedDoc>,
    pub offerNote: ::protobuf::SingularField<::std::string::String>,
    pub subscription: ::protobuf::RepeatedField<DocV2>,
    pub oBSOLETEReason: ::protobuf::SingularPtrField<OBSOLETE_Reason>,
    pub privacyPolicyUrl: ::protobuf::SingularField<::std::string::String>,
    pub suggestionReasons: ::protobuf::SingularPtrField<SuggestionReasons>,
    pub optimalDeviceClassWarning: ::protobuf::SingularPtrField<Warning>,
    pub docBadgeContainer: ::protobuf::RepeatedField<BadgeContainer>,
    pub sectionSuggestForRating: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionRateAndReview: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionPurchaseCrossSell: ::protobuf::SingularPtrField<SectionMetadata>,
    pub overflowLink: ::protobuf::RepeatedField<OverflowLink>,
    pub creatorDoc: ::protobuf::SingularPtrField<DocV2>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Annotations {
    pub fn new() -> Annotations {
        ::std::default::Default::default()
    }

    // optional string offerNote = 14;

    pub fn get_offerNote(&self) -> &str {
        match self.offerNote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string privacyPolicyUrl = 18;

    pub fn get_privacyPolicyUrl(&self) -> &str {
        match self.privacyPolicyUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Annotations {
    fn is_initialized(&self) -> bool {
        for v in &self.sectionRelated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionMoreBy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusOneData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.warning {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionBodyOfWork {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionCoreContent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badgeForCreator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badgeForDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionCrossSell {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionRelatedDocType {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.promotedDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscription {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oBSOLETEReason {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.suggestionReasons {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.optimalDeviceClassWarning {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docBadgeContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionSuggestForRating {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionRateAndReview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionPurchaseCrossSell {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overflowLink {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creatorDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionRelated)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionMoreBy)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<PlusOneData, _>(wire_type, is, &mut self.plusOneData)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.warning)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionBodyOfWork)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionCoreContent)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<Template, _>(wire_type, is, &mut self.template)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.badgeForCreator)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.badgeForDoc)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<Link, _>(wire_type, is, &mut self.link)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionCrossSell)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionRelatedDocType)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.promotedDoc)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerNote)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.subscription)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<OBSOLETE_Reason, _>(wire_type, is, &mut self.oBSOLETEReason)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.privacyPolicyUrl)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into::<SuggestionReasons, _>(wire_type, is, &mut self.suggestionReasons)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into::<Warning, _>(wire_type, is, &mut self.optimalDeviceClassWarning)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.docBadgeContainer)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionSuggestForRating)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionRateAndReview)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into::<SectionMetadata, _>(wire_type, is, &mut self.sectionPurchaseCrossSell)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.overflowLink)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into::<DocV2, _>(wire_type, is, &mut self.creatorDoc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sectionRelated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sectionMoreBy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.plusOneData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.warning {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.sectionBodyOfWork.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sectionCoreContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.badgeForCreator {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.badgeForDoc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sectionCrossSell.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sectionRelatedDocType.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.promotedDoc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.offerNote.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        for value in &self.subscription {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.oBSOLETEReason.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.privacyPolicyUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.suggestionReasons.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.optimalDeviceClassWarning.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.docBadgeContainer {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.sectionSuggestForRating.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sectionRateAndReview.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sectionPurchaseCrossSell.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.overflowLink {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.creatorDoc.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sectionRelated.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.sectionMoreBy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.plusOneData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.warning {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.sectionBodyOfWork.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.sectionCoreContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.badgeForCreator {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.badgeForDoc {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.link.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.sectionCrossSell.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.sectionRelatedDocType.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.promotedDoc {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.offerNote.as_ref() {
            os.write_string(14, v)?;
        }
        for v in &self.subscription {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if let Some(v) = self.oBSOLETEReason.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.privacyPolicyUrl.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.suggestionReasons.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.optimalDeviceClassWarning.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        for v in &self.docBadgeContainer {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        if let Some(v) = self.sectionSuggestForRating.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.sectionRateAndReview.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.sectionPurchaseCrossSell.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        for v in &self.overflowLink {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        if let Some(v) = self.creatorDoc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Annotations {
        Annotations::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionRelated",
                |m: &Annotations| { &m.sectionRelated },
                |m: &mut Annotations| { &mut m.sectionRelated },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionMoreBy",
                |m: &Annotations| { &m.sectionMoreBy },
                |m: &mut Annotations| { &mut m.sectionMoreBy },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusOneData>, _>(
                "plusOneData",
                |m: &Annotations| { &m.plusOneData },
                |m: &mut Annotations| { &mut m.plusOneData },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Warning>>(
                "warning",
                |m: &Annotations| { &m.warning },
                |m: &mut Annotations| { &mut m.warning },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionBodyOfWork",
                |m: &Annotations| { &m.sectionBodyOfWork },
                |m: &mut Annotations| { &mut m.sectionBodyOfWork },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionCoreContent",
                |m: &Annotations| { &m.sectionCoreContent },
                |m: &mut Annotations| { &mut m.sectionCoreContent },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Template>, _>(
                "template",
                |m: &Annotations| { &m.template },
                |m: &mut Annotations| { &mut m.template },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>>(
                "badgeForCreator",
                |m: &Annotations| { &m.badgeForCreator },
                |m: &mut Annotations| { &mut m.badgeForCreator },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>>(
                "badgeForDoc",
                |m: &Annotations| { &m.badgeForDoc },
                |m: &mut Annotations| { &mut m.badgeForDoc },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Link>, _>(
                "link",
                |m: &Annotations| { &m.link },
                |m: &mut Annotations| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionCrossSell",
                |m: &Annotations| { &m.sectionCrossSell },
                |m: &mut Annotations| { &mut m.sectionCrossSell },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionRelatedDocType",
                |m: &Annotations| { &m.sectionRelatedDocType },
                |m: &mut Annotations| { &mut m.sectionRelatedDocType },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PromotedDoc>>(
                "promotedDoc",
                |m: &Annotations| { &m.promotedDoc },
                |m: &mut Annotations| { &mut m.promotedDoc },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "offerNote",
                |m: &Annotations| { &m.offerNote },
                |m: &mut Annotations| { &mut m.offerNote },
                Annotations::get_offerNote,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "subscription",
                |m: &Annotations| { &m.subscription },
                |m: &mut Annotations| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OBSOLETE_Reason>, _>(
                "oBSOLETEReason",
                |m: &Annotations| { &m.oBSOLETEReason },
                |m: &mut Annotations| { &mut m.oBSOLETEReason },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "privacyPolicyUrl",
                |m: &Annotations| { &m.privacyPolicyUrl },
                |m: &mut Annotations| { &mut m.privacyPolicyUrl },
                Annotations::get_privacyPolicyUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SuggestionReasons>, _>(
                "suggestionReasons",
                |m: &Annotations| { &m.suggestionReasons },
                |m: &mut Annotations| { &mut m.suggestionReasons },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Warning>, _>(
                "optimalDeviceClassWarning",
                |m: &Annotations| { &m.optimalDeviceClassWarning },
                |m: &mut Annotations| { &mut m.optimalDeviceClassWarning },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BadgeContainer>>(
                "docBadgeContainer",
                |m: &Annotations| { &m.docBadgeContainer },
                |m: &mut Annotations| { &mut m.docBadgeContainer },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionSuggestForRating",
                |m: &Annotations| { &m.sectionSuggestForRating },
                |m: &mut Annotations| { &mut m.sectionSuggestForRating },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionRateAndReview",
                |m: &Annotations| { &m.sectionRateAndReview },
                |m: &mut Annotations| { &mut m.sectionRateAndReview },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>, _>(
                "sectionPurchaseCrossSell",
                |m: &Annotations| { &m.sectionPurchaseCrossSell },
                |m: &mut Annotations| { &mut m.sectionPurchaseCrossSell },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OverflowLink>>(
                "overflowLink",
                |m: &Annotations| { &m.overflowLink },
                |m: &mut Annotations| { &mut m.overflowLink },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>, _>(
                "creatorDoc",
                |m: &Annotations| { &m.creatorDoc },
                |m: &mut Annotations| { &mut m.creatorDoc },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Annotations>(
                "Annotations",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Annotations {
        static instance: ::protobuf::rt::Lazy<Annotations> = ::protobuf::rt::Lazy::INIT;
        instance.get(Annotations::new)
    }
}

impl ::protobuf::Clear for Annotations {
    fn clear(&mut self) {
        self.sectionRelated.clear();
        self.sectionMoreBy.clear();
        self.plusOneData.clear();
        self.warning.clear();
        self.sectionBodyOfWork.clear();
        self.sectionCoreContent.clear();
        self.template.clear();
        self.badgeForCreator.clear();
        self.badgeForDoc.clear();
        self.link.clear();
        self.sectionCrossSell.clear();
        self.sectionRelatedDocType.clear();
        self.promotedDoc.clear();
        self.offerNote.clear();
        self.subscription.clear();
        self.oBSOLETEReason.clear();
        self.privacyPolicyUrl.clear();
        self.suggestionReasons.clear();
        self.optimalDeviceClassWarning.clear();
        self.docBadgeContainer.clear();
        self.sectionSuggestForRating.clear();
        self.sectionRateAndReview.clear();
        self.sectionPurchaseCrossSell.clear();
        self.overflowLink.clear();
        self.creatorDoc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Annotations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotations {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct OverflowLink {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub link: ::protobuf::SingularPtrField<Link>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl OverflowLink {
    pub fn new() -> OverflowLink {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for OverflowLink {
    fn is_initialized(&self) -> bool {
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Link, _>(wire_type, is, &mut self.link)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.link.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OverflowLink {
        OverflowLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &OverflowLink| { &m.title },
                |m: &mut OverflowLink| { &mut m.title },
                OverflowLink::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Link>, _>(
                "link",
                |m: &OverflowLink| { &m.link },
                |m: &mut OverflowLink| { &mut m.link },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<OverflowLink>(
                "OverflowLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OverflowLink {
        static instance: ::protobuf::rt::Lazy<OverflowLink> = ::protobuf::rt::Lazy::INIT;
        instance.get(OverflowLink::new)
    }
}

impl ::protobuf::Clear for OverflowLink {
    fn clear(&mut self) {
        self.title.clear();
        self.link.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OverflowLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OverflowLink {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ReviewTip {
    // message fields
    pub tipUrl: ::protobuf::SingularField<::std::string::String>,
    pub text: ::protobuf::SingularField<::std::string::String>,
    pub polarity: ::std::option::Option<i32>,
    pub reviewCount: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ReviewTip {
    pub fn new() -> ReviewTip {
        ::std::default::Default::default()
    }

    // optional string tipUrl = 1;

    pub fn get_tipUrl(&self) -> &str {
        match self.tipUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string text = 2;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 polarity = 3;

    pub fn get_polarity(&self) -> i32 {
        self.polarity.unwrap_or(0)
    }

    // optional int64 reviewCount = 4;

    pub fn get_reviewCount(&self) -> i64 {
        self.reviewCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for ReviewTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tipUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.polarity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.reviewCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tipUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.polarity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reviewCount {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tipUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.polarity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.reviewCount {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReviewTip {
        ReviewTip::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tipUrl",
                |m: &ReviewTip| { &m.tipUrl },
                |m: &mut ReviewTip| { &mut m.tipUrl },
                ReviewTip::get_tipUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "text",
                |m: &ReviewTip| { &m.text },
                |m: &mut ReviewTip| { &mut m.text },
                ReviewTip::get_text,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "polarity",
                |m: &ReviewTip| { &m.polarity },
                |m: &mut ReviewTip| { &mut m.polarity },
                ReviewTip::get_polarity,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "reviewCount",
                |m: &ReviewTip| { &m.reviewCount },
                |m: &mut ReviewTip| { &mut m.reviewCount },
                ReviewTip::get_reviewCount,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ReviewTip>(
                "ReviewTip",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReviewTip {
        static instance: ::protobuf::rt::Lazy<ReviewTip> = ::protobuf::rt::Lazy::INIT;
        instance.get(ReviewTip::new)
    }
}

impl ::protobuf::Clear for ReviewTip {
    fn clear(&mut self) {
        self.tipUrl.clear();
        self.text.clear();
        self.polarity = ::std::option::Option::None;
        self.reviewCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReviewTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewTip {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DocV2 {
    // message fields
    pub docid: ::protobuf::SingularField<::std::string::String>,
    pub backendDocid: ::protobuf::SingularField<::std::string::String>,
    pub docType: ::std::option::Option<i32>,
    pub backendId: ::std::option::Option<i32>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub creator: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub availability: ::protobuf::SingularPtrField<Availability>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub child: ::protobuf::RepeatedField<DocV2>,
    pub containerMetadata: ::protobuf::SingularPtrField<ContainerMetadata>,
    pub details: ::protobuf::SingularPtrField<DocumentDetails>,
    pub aggregateRating: ::protobuf::SingularPtrField<AggregateRating>,
    pub annotations: ::protobuf::SingularPtrField<Annotations>,
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub shareUrl: ::protobuf::SingularField<::std::string::String>,
    pub reviewsUrl: ::protobuf::SingularField<::std::string::String>,
    pub backendUrl: ::protobuf::SingularField<::std::string::String>,
    pub purchaseDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub detailsReusable: ::std::option::Option<bool>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub translatedDescriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub productDetails: ::protobuf::SingularPtrField<ProductDetails>,
    pub mature: ::std::option::Option<bool>,
    pub promotionalDescription: ::protobuf::SingularField<::std::string::String>,
    pub availabileForPreregistration: ::std::option::Option<bool>,
    pub tip: ::protobuf::RepeatedField<ReviewTip>,
    pub snippetsUrl: ::protobuf::SingularField<::std::string::String>,
    pub forceShareability: ::std::option::Option<bool>,
    pub useWishlistAsPrimaryAction: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DocV2 {
    pub fn new() -> DocV2 {
        ::std::default::Default::default()
    }

    // optional string docid = 1;

    pub fn get_docid(&self) -> &str {
        match self.docid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string backendDocid = 2;

    pub fn get_backendDocid(&self) -> &str {
        match self.backendDocid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 docType = 3;

    pub fn get_docType(&self) -> i32 {
        self.docType.unwrap_or(0)
    }

    // optional int32 backendId = 4;

    pub fn get_backendId(&self) -> i32 {
        self.backendId.unwrap_or(0)
    }

    // optional string title = 5;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string creator = 6;

    pub fn get_creator(&self) -> &str {
        match self.creator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string descriptionHtml = 7;

    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string detailsUrl = 16;

    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string shareUrl = 17;

    pub fn get_shareUrl(&self) -> &str {
        match self.shareUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string reviewsUrl = 18;

    pub fn get_reviewsUrl(&self) -> &str {
        match self.reviewsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string backendUrl = 19;

    pub fn get_backendUrl(&self) -> &str {
        match self.backendUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string purchaseDetailsUrl = 20;

    pub fn get_purchaseDetailsUrl(&self) -> &str {
        match self.purchaseDetailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool detailsReusable = 21;

    pub fn get_detailsReusable(&self) -> bool {
        self.detailsReusable.unwrap_or(false)
    }

    // optional string subtitle = 22;

    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string translatedDescriptionHtml = 23;

    pub fn get_translatedDescriptionHtml(&self) -> &str {
        match self.translatedDescriptionHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 24;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bool mature = 26;

    pub fn get_mature(&self) -> bool {
        self.mature.unwrap_or(false)
    }

    // optional string promotionalDescription = 27;

    pub fn get_promotionalDescription(&self) -> &str {
        match self.promotionalDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool availabileForPreregistration = 29;

    pub fn get_availabileForPreregistration(&self) -> bool {
        self.availabileForPreregistration.unwrap_or(false)
    }

    // optional string snippetsUrl = 31;

    pub fn get_snippetsUrl(&self) -> &str {
        match self.snippetsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool forceShareability = 32;

    pub fn get_forceShareability(&self) -> bool {
        self.forceShareability.unwrap_or(false)
    }

    // optional bool useWishlistAsPrimaryAction = 33;

    pub fn get_useWishlistAsPrimaryAction(&self) -> bool {
        self.useWishlistAsPrimaryAction.unwrap_or(false)
    }
}

impl ::protobuf::Message for DocV2 {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containerMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregateRating {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.productDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendDocid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.docType = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backendId = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creator)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.offer)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<Availability, _>(wire_type, is, &mut self.availability)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.image)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.child)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<ContainerMetadata, _>(wire_type, is, &mut self.containerMetadata)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<DocumentDetails, _>(wire_type, is, &mut self.details)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into::<AggregateRating, _>(wire_type, is, &mut self.aggregateRating)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into::<Annotations, _>(wire_type, is, &mut self.annotations)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareUrl)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reviewsUrl)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendUrl)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseDetailsUrl)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detailsReusable = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.translatedDescriptionHtml)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into::<ProductDetails, _>(wire_type, is, &mut self.productDetails)?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mature = ::std::option::Option::Some(tmp);
                },
                27 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.promotionalDescription)?;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.availabileForPreregistration = ::std::option::Option::Some(tmp);
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.tip)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snippetsUrl)?;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forceShareability = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.useWishlistAsPrimaryAction = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.docid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.backendDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.docType {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.backendId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.creator.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.availability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.containerMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.aggregateRating.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.annotations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.shareUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.reviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.backendUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.purchaseDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.detailsReusable {
            my_size += 3;
        }
        if let Some(v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.translatedDescriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(24, &v);
        }
        if let Some(v) = self.productDetails.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.mature {
            my_size += 3;
        }
        if let Some(v) = self.promotionalDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.availabileForPreregistration {
            my_size += 3;
        }
        for value in &self.tip {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.snippetsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        if let Some(v) = self.forceShareability {
            my_size += 3;
        }
        if let Some(v) = self.useWishlistAsPrimaryAction {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.docid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.backendDocid.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.docType {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.backendId {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.creator.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.descriptionHtml.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.offer {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.availability.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.image {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.child {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.containerMetadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.aggregateRating.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.annotations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.detailsUrl.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.shareUrl.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.reviewsUrl.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.backendUrl.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.purchaseDetailsUrl.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.detailsReusable {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.subtitle.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.translatedDescriptionHtml.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(24, v)?;
        }
        if let Some(v) = self.productDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.mature {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.promotionalDescription.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.availabileForPreregistration {
            os.write_bool(29, v)?;
        }
        for v in &self.tip {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        };
        if let Some(v) = self.snippetsUrl.as_ref() {
            os.write_string(31, v)?;
        }
        if let Some(v) = self.forceShareability {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.useWishlistAsPrimaryAction {
            os.write_bool(33, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocV2 {
        DocV2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "docid",
                |m: &DocV2| { &m.docid },
                |m: &mut DocV2| { &mut m.docid },
                DocV2::get_docid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "backendDocid",
                |m: &DocV2| { &m.backendDocid },
                |m: &mut DocV2| { &mut m.backendDocid },
                DocV2::get_backendDocid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "docType",
                |m: &DocV2| { &m.docType },
                |m: &mut DocV2| { &mut m.docType },
                DocV2::get_docType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "backendId",
                |m: &DocV2| { &m.backendId },
                |m: &mut DocV2| { &mut m.backendId },
                DocV2::get_backendId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &DocV2| { &m.title },
                |m: &mut DocV2| { &mut m.title },
                DocV2::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "creator",
                |m: &DocV2| { &m.creator },
                |m: &mut DocV2| { &mut m.creator },
                DocV2::get_creator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "descriptionHtml",
                |m: &DocV2| { &m.descriptionHtml },
                |m: &mut DocV2| { &mut m.descriptionHtml },
                DocV2::get_descriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &DocV2| { &m.offer },
                |m: &mut DocV2| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Availability>, _>(
                "availability",
                |m: &DocV2| { &m.availability },
                |m: &mut DocV2| { &mut m.availability },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &DocV2| { &m.image },
                |m: &mut DocV2| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "child",
                |m: &DocV2| { &m.child },
                |m: &mut DocV2| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerMetadata>, _>(
                "containerMetadata",
                |m: &DocV2| { &m.containerMetadata },
                |m: &mut DocV2| { &mut m.containerMetadata },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentDetails>, _>(
                "details",
                |m: &DocV2| { &m.details },
                |m: &mut DocV2| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AggregateRating>, _>(
                "aggregateRating",
                |m: &DocV2| { &m.aggregateRating },
                |m: &mut DocV2| { &mut m.aggregateRating },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotations>, _>(
                "annotations",
                |m: &DocV2| { &m.annotations },
                |m: &mut DocV2| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "detailsUrl",
                |m: &DocV2| { &m.detailsUrl },
                |m: &mut DocV2| { &mut m.detailsUrl },
                DocV2::get_detailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "shareUrl",
                |m: &DocV2| { &m.shareUrl },
                |m: &mut DocV2| { &mut m.shareUrl },
                DocV2::get_shareUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "reviewsUrl",
                |m: &DocV2| { &m.reviewsUrl },
                |m: &mut DocV2| { &mut m.reviewsUrl },
                DocV2::get_reviewsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "backendUrl",
                |m: &DocV2| { &m.backendUrl },
                |m: &mut DocV2| { &mut m.backendUrl },
                DocV2::get_backendUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "purchaseDetailsUrl",
                |m: &DocV2| { &m.purchaseDetailsUrl },
                |m: &mut DocV2| { &mut m.purchaseDetailsUrl },
                DocV2::get_purchaseDetailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "detailsReusable",
                |m: &DocV2| { &m.detailsReusable },
                |m: &mut DocV2| { &mut m.detailsReusable },
                DocV2::get_detailsReusable,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subtitle",
                |m: &DocV2| { &m.subtitle },
                |m: &mut DocV2| { &mut m.subtitle },
                DocV2::get_subtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "translatedDescriptionHtml",
                |m: &DocV2| { &m.translatedDescriptionHtml },
                |m: &mut DocV2| { &mut m.translatedDescriptionHtml },
                DocV2::get_translatedDescriptionHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &DocV2| { &m.serverLogsCookie },
                |m: &mut DocV2| { &mut m.serverLogsCookie },
                DocV2::get_serverLogsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductDetails>, _>(
                "productDetails",
                |m: &DocV2| { &m.productDetails },
                |m: &mut DocV2| { &mut m.productDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "mature",
                |m: &DocV2| { &m.mature },
                |m: &mut DocV2| { &mut m.mature },
                DocV2::get_mature,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "promotionalDescription",
                |m: &DocV2| { &m.promotionalDescription },
                |m: &mut DocV2| { &mut m.promotionalDescription },
                DocV2::get_promotionalDescription,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "availabileForPreregistration",
                |m: &DocV2| { &m.availabileForPreregistration },
                |m: &mut DocV2| { &mut m.availabileForPreregistration },
                DocV2::get_availabileForPreregistration,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReviewTip>>(
                "tip",
                |m: &DocV2| { &m.tip },
                |m: &mut DocV2| { &mut m.tip },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "snippetsUrl",
                |m: &DocV2| { &m.snippetsUrl },
                |m: &mut DocV2| { &mut m.snippetsUrl },
                DocV2::get_snippetsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "forceShareability",
                |m: &DocV2| { &m.forceShareability },
                |m: &mut DocV2| { &mut m.forceShareability },
                DocV2::get_forceShareability,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "useWishlistAsPrimaryAction",
                |m: &DocV2| { &m.useWishlistAsPrimaryAction },
                |m: &mut DocV2| { &mut m.useWishlistAsPrimaryAction },
                DocV2::get_useWishlistAsPrimaryAction,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DocV2>(
                "DocV2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocV2 {
        static instance: ::protobuf::rt::Lazy<DocV2> = ::protobuf::rt::Lazy::INIT;
        instance.get(DocV2::new)
    }
}

impl ::protobuf::Clear for DocV2 {
    fn clear(&mut self) {
        self.docid.clear();
        self.backendDocid.clear();
        self.docType = ::std::option::Option::None;
        self.backendId = ::std::option::Option::None;
        self.title.clear();
        self.creator.clear();
        self.descriptionHtml.clear();
        self.offer.clear();
        self.availability.clear();
        self.image.clear();
        self.child.clear();
        self.containerMetadata.clear();
        self.details.clear();
        self.aggregateRating.clear();
        self.annotations.clear();
        self.detailsUrl.clear();
        self.shareUrl.clear();
        self.reviewsUrl.clear();
        self.backendUrl.clear();
        self.purchaseDetailsUrl.clear();
        self.detailsReusable = ::std::option::Option::None;
        self.subtitle.clear();
        self.translatedDescriptionHtml.clear();
        self.serverLogsCookie.clear();
        self.productDetails.clear();
        self.mature = ::std::option::Option::None;
        self.promotionalDescription.clear();
        self.availabileForPreregistration = ::std::option::Option::None;
        self.tip.clear();
        self.snippetsUrl.clear();
        self.forceShareability = ::std::option::Option::None;
        self.useWishlistAsPrimaryAction = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocV2 {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ProductDetails {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub section: ::protobuf::RepeatedField<ProductDetailsSection>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ProductDetails {
    pub fn new() -> ProductDetails {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ProductDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.section {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.section)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.section {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.section {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductDetails {
        ProductDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &ProductDetails| { &m.title },
                |m: &mut ProductDetails| { &mut m.title },
                ProductDetails::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductDetailsSection>>(
                "section",
                |m: &ProductDetails| { &m.section },
                |m: &mut ProductDetails| { &mut m.section },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ProductDetails>(
                "ProductDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductDetails {
        static instance: ::protobuf::rt::Lazy<ProductDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(ProductDetails::new)
    }
}

impl ::protobuf::Clear for ProductDetails {
    fn clear(&mut self) {
        self.title.clear();
        self.section.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ProductDetailsSection {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::RepeatedField<ProductDetailsDescription>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ProductDetailsSection {
    pub fn new() -> ProductDetailsSection {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ProductDetailsSection {
    fn is_initialized(&self) -> bool {
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.description {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.description {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductDetailsSection {
        ProductDetailsSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &ProductDetailsSection| { &m.title },
                |m: &mut ProductDetailsSection| { &mut m.title },
                ProductDetailsSection::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductDetailsDescription>>(
                "description",
                |m: &ProductDetailsSection| { &m.description },
                |m: &mut ProductDetailsSection| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ProductDetailsSection>(
                "ProductDetailsSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductDetailsSection {
        static instance: ::protobuf::rt::Lazy<ProductDetailsSection> = ::protobuf::rt::Lazy::INIT;
        instance.get(ProductDetailsSection::new)
    }
}

impl ::protobuf::Clear for ProductDetailsSection {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductDetailsSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductDetailsSection {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ProductDetailsDescription {
    // message fields
    pub image: ::protobuf::SingularPtrField<Image>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ProductDetailsDescription {
    pub fn new() -> ProductDetailsDescription {
        ::std::default::Default::default()
    }

    // optional string description = 2;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ProductDetailsDescription {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Image, _>(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductDetailsDescription {
        ProductDetailsDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>, _>(
                "image",
                |m: &ProductDetailsDescription| { &m.image },
                |m: &mut ProductDetailsDescription| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "description",
                |m: &ProductDetailsDescription| { &m.description },
                |m: &mut ProductDetailsDescription| { &mut m.description },
                ProductDetailsDescription::get_description,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ProductDetailsDescription>(
                "ProductDetailsDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductDetailsDescription {
        static instance: ::protobuf::rt::Lazy<ProductDetailsDescription> = ::protobuf::rt::Lazy::INIT;
        instance.get(ProductDetailsDescription::new)
    }
}

impl ::protobuf::Clear for ProductDetailsDescription {
    fn clear(&mut self) {
        self.image.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductDetailsDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductDetailsDescription {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct EncryptedSubscriberInfo {
    // message fields
    pub data: ::protobuf::SingularField<::std::string::String>,
    pub encryptedKey: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    pub initVector: ::protobuf::SingularField<::std::string::String>,
    pub googleKeyVersion: ::std::option::Option<i32>,
    pub carrierKeyVersion: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl EncryptedSubscriberInfo {
    pub fn new() -> EncryptedSubscriberInfo {
        ::std::default::Default::default()
    }

    // optional string data = 1;

    pub fn get_data(&self) -> &str {
        match self.data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string encryptedKey = 2;

    pub fn get_encryptedKey(&self) -> &str {
        match self.encryptedKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string signature = 3;

    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string initVector = 4;

    pub fn get_initVector(&self) -> &str {
        match self.initVector.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 googleKeyVersion = 5;

    pub fn get_googleKeyVersion(&self) -> i32 {
        self.googleKeyVersion.unwrap_or(0)
    }

    // optional int32 carrierKeyVersion = 6;

    pub fn get_carrierKeyVersion(&self) -> i32 {
        self.carrierKeyVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for EncryptedSubscriberInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryptedKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.initVector)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.googleKeyVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.carrierKeyVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.encryptedKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.initVector.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.googleKeyVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.carrierKeyVersion {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.encryptedKey.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.initVector.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.googleKeyVersion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.carrierKeyVersion {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptedSubscriberInfo {
        EncryptedSubscriberInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "data",
                |m: &EncryptedSubscriberInfo| { &m.data },
                |m: &mut EncryptedSubscriberInfo| { &mut m.data },
                EncryptedSubscriberInfo::get_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "encryptedKey",
                |m: &EncryptedSubscriberInfo| { &m.encryptedKey },
                |m: &mut EncryptedSubscriberInfo| { &mut m.encryptedKey },
                EncryptedSubscriberInfo::get_encryptedKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signature",
                |m: &EncryptedSubscriberInfo| { &m.signature },
                |m: &mut EncryptedSubscriberInfo| { &mut m.signature },
                EncryptedSubscriberInfo::get_signature,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "initVector",
                |m: &EncryptedSubscriberInfo| { &m.initVector },
                |m: &mut EncryptedSubscriberInfo| { &mut m.initVector },
                EncryptedSubscriberInfo::get_initVector,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "googleKeyVersion",
                |m: &EncryptedSubscriberInfo| { &m.googleKeyVersion },
                |m: &mut EncryptedSubscriberInfo| { &mut m.googleKeyVersion },
                EncryptedSubscriberInfo::get_googleKeyVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "carrierKeyVersion",
                |m: &EncryptedSubscriberInfo| { &m.carrierKeyVersion },
                |m: &mut EncryptedSubscriberInfo| { &mut m.carrierKeyVersion },
                EncryptedSubscriberInfo::get_carrierKeyVersion,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<EncryptedSubscriberInfo>(
                "EncryptedSubscriberInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptedSubscriberInfo {
        static instance: ::protobuf::rt::Lazy<EncryptedSubscriberInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(EncryptedSubscriberInfo::new)
    }
}

impl ::protobuf::Clear for EncryptedSubscriberInfo {
    fn clear(&mut self) {
        self.data.clear();
        self.encryptedKey.clear();
        self.signature.clear();
        self.initVector.clear();
        self.googleKeyVersion = ::std::option::Option::None;
        self.carrierKeyVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptedSubscriberInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptedSubscriberInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Availability {
    // message fields
    pub restriction: ::std::option::Option<i32>,
    pub offerType: ::std::option::Option<i32>,
    pub rule: ::protobuf::SingularPtrField<Rule>,
    // perdeviceavailabilityrestriction: <group>
    pub availableIfOwned: ::std::option::Option<bool>,
    pub install: ::protobuf::RepeatedField<Install>,
    pub filterInfo: ::protobuf::SingularPtrField<FilterEvaluationInfo>,
    pub ownershipInfo: ::protobuf::SingularPtrField<OwnershipInfo>,
    pub availabilityProblem: ::protobuf::RepeatedField<AvailabilityProblem>,
    pub hidden: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Availability {
    pub fn new() -> Availability {
        ::std::default::Default::default()
    }

    // optional int32 restriction = 5;

    pub fn get_restriction(&self) -> i32 {
        self.restriction.unwrap_or(0)
    }

    // optional int32 offerType = 6;

    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional bool availableIfOwned = 13;

    pub fn get_availableIfOwned(&self) -> bool {
        self.availableIfOwned.unwrap_or(false)
    }

    // optional bool hidden = 21;

    pub fn get_hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }
}

impl ::protobuf::Message for Availability {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.install {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filterInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ownershipInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availabilityProblem {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.restriction = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<Rule, _>(wire_type, is, &mut self.rule)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.availableIfOwned = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.install)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into::<FilterEvaluationInfo, _>(wire_type, is, &mut self.filterInfo)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<OwnershipInfo, _>(wire_type, is, &mut self.ownershipInfo)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.availabilityProblem)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.restriction {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.availableIfOwned {
            my_size += 2;
        }
        for value in &self.install {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.filterInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ownershipInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.availabilityProblem {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hidden {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.restriction {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.rule.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.availableIfOwned {
            os.write_bool(13, v)?;
        }
        for v in &self.install {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if let Some(v) = self.filterInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.ownershipInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        for v in &self.availabilityProblem {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.hidden {
            os.write_bool(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Availability {
        Availability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "restriction",
                |m: &Availability| { &m.restriction },
                |m: &mut Availability| { &mut m.restriction },
                Availability::get_restriction,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "offerType",
                |m: &Availability| { &m.offerType },
                |m: &mut Availability| { &mut m.offerType },
                Availability::get_offerType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>, _>(
                "rule",
                |m: &Availability| { &m.rule },
                |m: &mut Availability| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "availableIfOwned",
                |m: &Availability| { &m.availableIfOwned },
                |m: &mut Availability| { &mut m.availableIfOwned },
                Availability::get_availableIfOwned,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Install>>(
                "install",
                |m: &Availability| { &m.install },
                |m: &mut Availability| { &mut m.install },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterEvaluationInfo>, _>(
                "filterInfo",
                |m: &Availability| { &m.filterInfo },
                |m: &mut Availability| { &mut m.filterInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OwnershipInfo>, _>(
                "ownershipInfo",
                |m: &Availability| { &m.ownershipInfo },
                |m: &mut Availability| { &mut m.ownershipInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AvailabilityProblem>>(
                "availabilityProblem",
                |m: &Availability| { &m.availabilityProblem },
                |m: &mut Availability| { &mut m.availabilityProblem },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "hidden",
                |m: &Availability| { &m.hidden },
                |m: &mut Availability| { &mut m.hidden },
                Availability::get_hidden,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Availability>(
                "Availability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Availability {
        static instance: ::protobuf::rt::Lazy<Availability> = ::protobuf::rt::Lazy::INIT;
        instance.get(Availability::new)
    }
}

impl ::protobuf::Clear for Availability {
    fn clear(&mut self) {
        self.restriction = ::std::option::Option::None;
        self.offerType = ::std::option::Option::None;
        self.rule.clear();
        self.availableIfOwned = ::std::option::Option::None;
        self.install.clear();
        self.filterInfo.clear();
        self.ownershipInfo.clear();
        self.availabilityProblem.clear();
        self.hidden = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Availability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Availability_PerDeviceAvailabilityRestriction {
    // message fields
    pub androidId: ::std::option::Option<u64>,
    pub deviceRestriction: ::std::option::Option<i32>,
    pub channelId: ::std::option::Option<i64>,
    pub filterInfo: ::protobuf::SingularPtrField<FilterEvaluationInfo>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Availability_PerDeviceAvailabilityRestriction {
    pub fn new() -> Availability_PerDeviceAvailabilityRestriction {
        ::std::default::Default::default()
    }

    // optional fixed64 androidId = 10;

    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }

    // optional int32 deviceRestriction = 11;

    pub fn get_deviceRestriction(&self) -> i32 {
        self.deviceRestriction.unwrap_or(0)
    }

    // optional int64 channelId = 12;

    pub fn get_channelId(&self) -> i64 {
        self.channelId.unwrap_or(0)
    }
}

impl ::protobuf::Message for Availability_PerDeviceAvailabilityRestriction {
    fn is_initialized(&self) -> bool {
        for v in &self.filterInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceRestriction = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.channelId = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into::<FilterEvaluationInfo, _>(wire_type, is, &mut self.filterInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        if let Some(v) = self.deviceRestriction {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channelId {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filterInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.deviceRestriction {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.channelId {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.filterInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Availability_PerDeviceAvailabilityRestriction {
        Availability_PerDeviceAvailabilityRestriction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeFixed64, _>(
                "androidId",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.androidId },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.androidId },
                Availability_PerDeviceAvailabilityRestriction::get_androidId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "deviceRestriction",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.deviceRestriction },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.deviceRestriction },
                Availability_PerDeviceAvailabilityRestriction::get_deviceRestriction,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "channelId",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.channelId },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.channelId },
                Availability_PerDeviceAvailabilityRestriction::get_channelId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterEvaluationInfo>, _>(
                "filterInfo",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.filterInfo },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.filterInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Availability_PerDeviceAvailabilityRestriction>(
                "Availability_PerDeviceAvailabilityRestriction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Availability_PerDeviceAvailabilityRestriction {
        static instance: ::protobuf::rt::Lazy<Availability_PerDeviceAvailabilityRestriction> = ::protobuf::rt::Lazy::INIT;
        instance.get(Availability_PerDeviceAvailabilityRestriction::new)
    }
}

impl ::protobuf::Clear for Availability_PerDeviceAvailabilityRestriction {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.deviceRestriction = ::std::option::Option::None;
        self.channelId = ::std::option::Option::None;
        self.filterInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Availability_PerDeviceAvailabilityRestriction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability_PerDeviceAvailabilityRestriction {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AvailabilityProblem {
    // message fields
    pub problemType: ::std::option::Option<i32>,
    pub missingValue: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AvailabilityProblem {
    pub fn new() -> AvailabilityProblem {
        ::std::default::Default::default()
    }

    // optional int32 problemType = 1;

    pub fn get_problemType(&self) -> i32 {
        self.problemType.unwrap_or(0)
    }
}

impl ::protobuf::Message for AvailabilityProblem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.problemType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.missingValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.problemType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.missingValue {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.problemType {
            os.write_int32(1, v)?;
        }
        for v in &self.missingValue {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AvailabilityProblem {
        AvailabilityProblem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "problemType",
                |m: &AvailabilityProblem| { &m.problemType },
                |m: &mut AvailabilityProblem| { &mut m.problemType },
                AvailabilityProblem::get_problemType,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "missingValue",
                |m: &AvailabilityProblem| { &m.missingValue },
                |m: &mut AvailabilityProblem| { &mut m.missingValue },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AvailabilityProblem>(
                "AvailabilityProblem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AvailabilityProblem {
        static instance: ::protobuf::rt::Lazy<AvailabilityProblem> = ::protobuf::rt::Lazy::INIT;
        instance.get(AvailabilityProblem::new)
    }
}

impl ::protobuf::Clear for AvailabilityProblem {
    fn clear(&mut self) {
        self.problemType = ::std::option::Option::None;
        self.missingValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AvailabilityProblem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvailabilityProblem {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct FilterEvaluationInfo {
    // message fields
    pub ruleEvaluation: ::protobuf::RepeatedField<RuleEvaluation>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl FilterEvaluationInfo {
    pub fn new() -> FilterEvaluationInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FilterEvaluationInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.ruleEvaluation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.ruleEvaluation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ruleEvaluation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ruleEvaluation {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterEvaluationInfo {
        FilterEvaluationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuleEvaluation>>(
                "ruleEvaluation",
                |m: &FilterEvaluationInfo| { &m.ruleEvaluation },
                |m: &mut FilterEvaluationInfo| { &mut m.ruleEvaluation },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<FilterEvaluationInfo>(
                "FilterEvaluationInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilterEvaluationInfo {
        static instance: ::protobuf::rt::Lazy<FilterEvaluationInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(FilterEvaluationInfo::new)
    }
}

impl ::protobuf::Clear for FilterEvaluationInfo {
    fn clear(&mut self) {
        self.ruleEvaluation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterEvaluationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterEvaluationInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Rule {
    // message fields
    pub negate: ::std::option::Option<bool>,
    pub operator: ::std::option::Option<i32>,
    pub key: ::std::option::Option<i32>,
    pub stringArg: ::protobuf::RepeatedField<::std::string::String>,
    pub longArg: ::std::vec::Vec<i64>,
    pub doubleArg: ::std::vec::Vec<f64>,
    pub subrule: ::protobuf::RepeatedField<Rule>,
    pub responseCode: ::std::option::Option<i32>,
    pub comment: ::protobuf::SingularField<::std::string::String>,
    pub stringArgHash: ::std::vec::Vec<u64>,
    pub constArg: ::std::vec::Vec<i32>,
    pub availabilityProblemType: ::std::option::Option<i32>,
    pub includeMissingValues: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Rule {
    pub fn new() -> Rule {
        ::std::default::Default::default()
    }

    // optional bool negate = 1;

    pub fn get_negate(&self) -> bool {
        self.negate.unwrap_or(false)
    }

    // optional int32 operator = 2;

    pub fn get_operator(&self) -> i32 {
        self.operator.unwrap_or(0)
    }

    // optional int32 key = 3;

    pub fn get_key(&self) -> i32 {
        self.key.unwrap_or(0)
    }

    // optional int32 responseCode = 8;

    pub fn get_responseCode(&self) -> i32 {
        self.responseCode.unwrap_or(0)
    }

    // optional string comment = 9;

    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 availabilityProblemType = 12;

    pub fn get_availabilityProblemType(&self) -> i32 {
        self.availabilityProblemType.unwrap_or(0)
    }

    // optional bool includeMissingValues = 13;

    pub fn get_includeMissingValues(&self) -> bool {
        self.includeMissingValues.unwrap_or(false)
    }
}

impl ::protobuf::Message for Rule {
    fn is_initialized(&self) -> bool {
        for v in &self.subrule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.negate = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.operator = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.stringArg)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.longArg)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.doubleArg)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.subrule)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.responseCode = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.stringArgHash)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.constArg)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.availabilityProblemType = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeMissingValues = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.negate {
            my_size += 2;
        }
        if let Some(v) = self.operator {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stringArg {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.longArg {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 9 * self.doubleArg.len() as u32;
        for value in &self.subrule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.responseCode {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += 9 * self.stringArgHash.len() as u32;
        for value in &self.constArg {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.availabilityProblemType {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.includeMissingValues {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.negate {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.operator {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.key {
            os.write_int32(3, v)?;
        }
        for v in &self.stringArg {
            os.write_string(4, &v)?;
        };
        for v in &self.longArg {
            os.write_int64(5, *v)?;
        };
        for v in &self.doubleArg {
            os.write_double(6, *v)?;
        };
        for v in &self.subrule {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.responseCode {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.stringArgHash {
            os.write_fixed64(10, *v)?;
        };
        for v in &self.constArg {
            os.write_int32(11, *v)?;
        };
        if let Some(v) = self.availabilityProblemType {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.includeMissingValues {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rule {
        Rule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "negate",
                |m: &Rule| { &m.negate },
                |m: &mut Rule| { &mut m.negate },
                Rule::get_negate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "operator",
                |m: &Rule| { &m.operator },
                |m: &mut Rule| { &mut m.operator },
                Rule::get_operator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "key",
                |m: &Rule| { &m.key },
                |m: &mut Rule| { &mut m.key },
                Rule::get_key,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stringArg",
                |m: &Rule| { &m.stringArg },
                |m: &mut Rule| { &mut m.stringArg },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "longArg",
                |m: &Rule| { &m.longArg },
                |m: &mut Rule| { &mut m.longArg },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "doubleArg",
                |m: &Rule| { &m.doubleArg },
                |m: &mut Rule| { &mut m.doubleArg },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "subrule",
                |m: &Rule| { &m.subrule },
                |m: &mut Rule| { &mut m.subrule },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "responseCode",
                |m: &Rule| { &m.responseCode },
                |m: &mut Rule| { &mut m.responseCode },
                Rule::get_responseCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "comment",
                |m: &Rule| { &m.comment },
                |m: &mut Rule| { &mut m.comment },
                Rule::get_comment,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "stringArgHash",
                |m: &Rule| { &m.stringArgHash },
                |m: &mut Rule| { &mut m.stringArgHash },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "constArg",
                |m: &Rule| { &m.constArg },
                |m: &mut Rule| { &mut m.constArg },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "availabilityProblemType",
                |m: &Rule| { &m.availabilityProblemType },
                |m: &mut Rule| { &mut m.availabilityProblemType },
                Rule::get_availabilityProblemType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "includeMissingValues",
                |m: &Rule| { &m.includeMissingValues },
                |m: &mut Rule| { &mut m.includeMissingValues },
                Rule::get_includeMissingValues,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Rule>(
                "Rule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rule {
        static instance: ::protobuf::rt::Lazy<Rule> = ::protobuf::rt::Lazy::INIT;
        instance.get(Rule::new)
    }
}

impl ::protobuf::Clear for Rule {
    fn clear(&mut self) {
        self.negate = ::std::option::Option::None;
        self.operator = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.stringArg.clear();
        self.longArg.clear();
        self.doubleArg.clear();
        self.subrule.clear();
        self.responseCode = ::std::option::Option::None;
        self.comment.clear();
        self.stringArgHash.clear();
        self.constArg.clear();
        self.availabilityProblemType = ::std::option::Option::None;
        self.includeMissingValues = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rule {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RuleEvaluation {
    // message fields
    pub rule: ::protobuf::SingularPtrField<Rule>,
    pub actualStringValue: ::protobuf::RepeatedField<::std::string::String>,
    pub actualLongValue: ::std::vec::Vec<i64>,
    pub actualBoolValue: ::std::vec::Vec<bool>,
    pub actualDoubleValue: ::std::vec::Vec<f64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RuleEvaluation {
    pub fn new() -> RuleEvaluation {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RuleEvaluation {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Rule, _>(wire_type, is, &mut self.rule)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actualStringValue)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.actualLongValue)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.actualBoolValue)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.actualDoubleValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.actualStringValue {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.actualLongValue {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 2 * self.actualBoolValue.len() as u32;
        my_size += 9 * self.actualDoubleValue.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rule.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.actualStringValue {
            os.write_string(2, &v)?;
        };
        for v in &self.actualLongValue {
            os.write_int64(3, *v)?;
        };
        for v in &self.actualBoolValue {
            os.write_bool(4, *v)?;
        };
        for v in &self.actualDoubleValue {
            os.write_double(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuleEvaluation {
        RuleEvaluation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>, _>(
                "rule",
                |m: &RuleEvaluation| { &m.rule },
                |m: &mut RuleEvaluation| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actualStringValue",
                |m: &RuleEvaluation| { &m.actualStringValue },
                |m: &mut RuleEvaluation| { &mut m.actualStringValue },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "actualLongValue",
                |m: &RuleEvaluation| { &m.actualLongValue },
                |m: &mut RuleEvaluation| { &mut m.actualLongValue },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "actualBoolValue",
                |m: &RuleEvaluation| { &m.actualBoolValue },
                |m: &mut RuleEvaluation| { &mut m.actualBoolValue },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "actualDoubleValue",
                |m: &RuleEvaluation| { &m.actualDoubleValue },
                |m: &mut RuleEvaluation| { &mut m.actualDoubleValue },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RuleEvaluation>(
                "RuleEvaluation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuleEvaluation {
        static instance: ::protobuf::rt::Lazy<RuleEvaluation> = ::protobuf::rt::Lazy::INIT;
        instance.get(RuleEvaluation::new)
    }
}

impl ::protobuf::Clear for RuleEvaluation {
    fn clear(&mut self) {
        self.rule.clear();
        self.actualStringValue.clear();
        self.actualLongValue.clear();
        self.actualBoolValue.clear();
        self.actualDoubleValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuleEvaluation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuleEvaluation {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GroupLicenseInfo {
    // message fields
    pub licensedOfferType: ::std::option::Option<i32>,
    pub gaiaGroupId: ::std::option::Option<u64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GroupLicenseInfo {
    pub fn new() -> GroupLicenseInfo {
        ::std::default::Default::default()
    }

    // optional int32 licensedOfferType = 1;

    pub fn get_licensedOfferType(&self) -> i32 {
        self.licensedOfferType.unwrap_or(0)
    }

    // optional fixed64 gaiaGroupId = 2;

    pub fn get_gaiaGroupId(&self) -> u64 {
        self.gaiaGroupId.unwrap_or(0)
    }
}

impl ::protobuf::Message for GroupLicenseInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.licensedOfferType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gaiaGroupId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.licensedOfferType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gaiaGroupId {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.licensedOfferType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gaiaGroupId {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupLicenseInfo {
        GroupLicenseInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "licensedOfferType",
                |m: &GroupLicenseInfo| { &m.licensedOfferType },
                |m: &mut GroupLicenseInfo| { &mut m.licensedOfferType },
                GroupLicenseInfo::get_licensedOfferType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeFixed64, _>(
                "gaiaGroupId",
                |m: &GroupLicenseInfo| { &m.gaiaGroupId },
                |m: &mut GroupLicenseInfo| { &mut m.gaiaGroupId },
                GroupLicenseInfo::get_gaiaGroupId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GroupLicenseInfo>(
                "GroupLicenseInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupLicenseInfo {
        static instance: ::protobuf::rt::Lazy<GroupLicenseInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(GroupLicenseInfo::new)
    }
}

impl ::protobuf::Clear for GroupLicenseInfo {
    fn clear(&mut self) {
        self.licensedOfferType = ::std::option::Option::None;
        self.gaiaGroupId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupLicenseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupLicenseInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LicensedDocumentInfo {
    // message fields
    pub gaiaGroupId: ::std::vec::Vec<u64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LicensedDocumentInfo {
    pub fn new() -> LicensedDocumentInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LicensedDocumentInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.gaiaGroupId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.gaiaGroupId.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gaiaGroupId {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LicensedDocumentInfo {
        LicensedDocumentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "gaiaGroupId",
                |m: &LicensedDocumentInfo| { &m.gaiaGroupId },
                |m: &mut LicensedDocumentInfo| { &mut m.gaiaGroupId },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LicensedDocumentInfo>(
                "LicensedDocumentInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LicensedDocumentInfo {
        static instance: ::protobuf::rt::Lazy<LicensedDocumentInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(LicensedDocumentInfo::new)
    }
}

impl ::protobuf::Clear for LicensedDocumentInfo {
    fn clear(&mut self) {
        self.gaiaGroupId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LicensedDocumentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LicensedDocumentInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LibraryAppDetails {
    // message fields
    pub certificateHash: ::protobuf::SingularField<::std::string::String>,
    pub refundTimeoutTimestampMsec: ::std::option::Option<i64>,
    pub postDeliveryRefundWindowMsec: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LibraryAppDetails {
    pub fn new() -> LibraryAppDetails {
        ::std::default::Default::default()
    }

    // optional string certificateHash = 2;

    pub fn get_certificateHash(&self) -> &str {
        match self.certificateHash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 refundTimeoutTimestampMsec = 3;

    pub fn get_refundTimeoutTimestampMsec(&self) -> i64 {
        self.refundTimeoutTimestampMsec.unwrap_or(0)
    }

    // optional int64 postDeliveryRefundWindowMsec = 4;

    pub fn get_postDeliveryRefundWindowMsec(&self) -> i64 {
        self.postDeliveryRefundWindowMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for LibraryAppDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutTimestampMsec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postDeliveryRefundWindowMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.certificateHash.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.certificateHash.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryAppDetails {
        LibraryAppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "certificateHash",
                |m: &LibraryAppDetails| { &m.certificateHash },
                |m: &mut LibraryAppDetails| { &mut m.certificateHash },
                LibraryAppDetails::get_certificateHash,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "refundTimeoutTimestampMsec",
                |m: &LibraryAppDetails| { &m.refundTimeoutTimestampMsec },
                |m: &mut LibraryAppDetails| { &mut m.refundTimeoutTimestampMsec },
                LibraryAppDetails::get_refundTimeoutTimestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "postDeliveryRefundWindowMsec",
                |m: &LibraryAppDetails| { &m.postDeliveryRefundWindowMsec },
                |m: &mut LibraryAppDetails| { &mut m.postDeliveryRefundWindowMsec },
                LibraryAppDetails::get_postDeliveryRefundWindowMsec,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LibraryAppDetails>(
                "LibraryAppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryAppDetails {
        static instance: ::protobuf::rt::Lazy<LibraryAppDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(LibraryAppDetails::new)
    }
}

impl ::protobuf::Clear for LibraryAppDetails {
    fn clear(&mut self) {
        self.certificateHash.clear();
        self.refundTimeoutTimestampMsec = ::std::option::Option::None;
        self.postDeliveryRefundWindowMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryAppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryAppDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LibraryInAppDetails {
    // message fields
    pub signedPurchaseData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LibraryInAppDetails {
    pub fn new() -> LibraryInAppDetails {
        ::std::default::Default::default()
    }

    // optional string signedPurchaseData = 1;

    pub fn get_signedPurchaseData(&self) -> &str {
        match self.signedPurchaseData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string signature = 2;

    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibraryInAppDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedPurchaseData)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.signedPurchaseData.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.signedPurchaseData.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryInAppDetails {
        LibraryInAppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signedPurchaseData",
                |m: &LibraryInAppDetails| { &m.signedPurchaseData },
                |m: &mut LibraryInAppDetails| { &mut m.signedPurchaseData },
                LibraryInAppDetails::get_signedPurchaseData,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signature",
                |m: &LibraryInAppDetails| { &m.signature },
                |m: &mut LibraryInAppDetails| { &mut m.signature },
                LibraryInAppDetails::get_signature,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LibraryInAppDetails>(
                "LibraryInAppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryInAppDetails {
        static instance: ::protobuf::rt::Lazy<LibraryInAppDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(LibraryInAppDetails::new)
    }
}

impl ::protobuf::Clear for LibraryInAppDetails {
    fn clear(&mut self) {
        self.signedPurchaseData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryInAppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryInAppDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LibraryMutation {
    // message fields
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub offerType: ::std::option::Option<i32>,
    pub documentHash: ::std::option::Option<i64>,
    pub deleted: ::std::option::Option<bool>,
    pub appDetails: ::protobuf::SingularPtrField<LibraryAppDetails>,
    pub subscriptionDetails: ::protobuf::SingularPtrField<LibrarySubscriptionDetails>,
    pub inAppDetails: ::protobuf::SingularPtrField<LibraryInAppDetails>,
    pub validUntilTimestampMsec: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LibraryMutation {
    pub fn new() -> LibraryMutation {
        ::std::default::Default::default()
    }

    // optional int32 offerType = 2;

    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional int64 documentHash = 3;

    pub fn get_documentHash(&self) -> i64 {
        self.documentHash.unwrap_or(0)
    }

    // optional bool deleted = 4;

    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    // optional int64 validUntilTimestampMsec = 8;

    pub fn get_validUntilTimestampMsec(&self) -> i64 {
        self.validUntilTimestampMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for LibraryMutation {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.documentHash = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryAppDetails, _>(wire_type, is, &mut self.appDetails)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<LibrarySubscriptionDetails, _>(wire_type, is, &mut self.subscriptionDetails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryInAppDetails, _>(wire_type, is, &mut self.inAppDetails)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.validUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.documentHash {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        if let Some(v) = self.appDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.subscriptionDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.inAppDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.validUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.docid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.documentHash {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.appDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.subscriptionDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.inAppDetails.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.validUntilTimestampMsec {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryMutation {
        LibraryMutation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "docid",
                |m: &LibraryMutation| { &m.docid },
                |m: &mut LibraryMutation| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "offerType",
                |m: &LibraryMutation| { &m.offerType },
                |m: &mut LibraryMutation| { &mut m.offerType },
                LibraryMutation::get_offerType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "documentHash",
                |m: &LibraryMutation| { &m.documentHash },
                |m: &mut LibraryMutation| { &mut m.documentHash },
                LibraryMutation::get_documentHash,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "deleted",
                |m: &LibraryMutation| { &m.deleted },
                |m: &mut LibraryMutation| { &mut m.deleted },
                LibraryMutation::get_deleted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryAppDetails>, _>(
                "appDetails",
                |m: &LibraryMutation| { &m.appDetails },
                |m: &mut LibraryMutation| { &mut m.appDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibrarySubscriptionDetails>, _>(
                "subscriptionDetails",
                |m: &LibraryMutation| { &m.subscriptionDetails },
                |m: &mut LibraryMutation| { &mut m.subscriptionDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryInAppDetails>, _>(
                "inAppDetails",
                |m: &LibraryMutation| { &m.inAppDetails },
                |m: &mut LibraryMutation| { &mut m.inAppDetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "validUntilTimestampMsec",
                |m: &LibraryMutation| { &m.validUntilTimestampMsec },
                |m: &mut LibraryMutation| { &mut m.validUntilTimestampMsec },
                LibraryMutation::get_validUntilTimestampMsec,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LibraryMutation>(
                "LibraryMutation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryMutation {
        static instance: ::protobuf::rt::Lazy<LibraryMutation> = ::protobuf::rt::Lazy::INIT;
        instance.get(LibraryMutation::new)
    }
}

impl ::protobuf::Clear for LibraryMutation {
    fn clear(&mut self) {
        self.docid.clear();
        self.offerType = ::std::option::Option::None;
        self.documentHash = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.appDetails.clear();
        self.subscriptionDetails.clear();
        self.inAppDetails.clear();
        self.validUntilTimestampMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryMutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryMutation {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LibrarySubscriptionDetails {
    // message fields
    pub initiationTimestampMsec: ::std::option::Option<i64>,
    pub deprecatedValidUntilTimestampMsec: ::std::option::Option<i64>,
    pub autoRenewing: ::std::option::Option<bool>,
    pub trialUntilTimestampMsec: ::std::option::Option<i64>,
    pub signedPurchaseData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LibrarySubscriptionDetails {
    pub fn new() -> LibrarySubscriptionDetails {
        ::std::default::Default::default()
    }

    // optional int64 initiationTimestampMsec = 1;

    pub fn get_initiationTimestampMsec(&self) -> i64 {
        self.initiationTimestampMsec.unwrap_or(0)
    }

    // optional int64 deprecatedValidUntilTimestampMsec = 2;

    pub fn get_deprecatedValidUntilTimestampMsec(&self) -> i64 {
        self.deprecatedValidUntilTimestampMsec.unwrap_or(0)
    }

    // optional bool autoRenewing = 3;

    pub fn get_autoRenewing(&self) -> bool {
        self.autoRenewing.unwrap_or(false)
    }

    // optional int64 trialUntilTimestampMsec = 4;

    pub fn get_trialUntilTimestampMsec(&self) -> i64 {
        self.trialUntilTimestampMsec.unwrap_or(0)
    }

    // optional string signedPurchaseData = 5;

    pub fn get_signedPurchaseData(&self) -> &str {
        match self.signedPurchaseData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string signature = 6;

    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibrarySubscriptionDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initiationTimestampMsec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deprecatedValidUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoRenewing = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.trialUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedPurchaseData)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initiationTimestampMsec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecatedValidUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.autoRenewing {
            my_size += 2;
        }
        if let Some(v) = self.trialUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signedPurchaseData.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initiationTimestampMsec {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.deprecatedValidUntilTimestampMsec {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.autoRenewing {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.trialUntilTimestampMsec {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.signedPurchaseData.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibrarySubscriptionDetails {
        LibrarySubscriptionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "initiationTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.initiationTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.initiationTimestampMsec },
                LibrarySubscriptionDetails::get_initiationTimestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "deprecatedValidUntilTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.deprecatedValidUntilTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.deprecatedValidUntilTimestampMsec },
                LibrarySubscriptionDetails::get_deprecatedValidUntilTimestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "autoRenewing",
                |m: &LibrarySubscriptionDetails| { &m.autoRenewing },
                |m: &mut LibrarySubscriptionDetails| { &mut m.autoRenewing },
                LibrarySubscriptionDetails::get_autoRenewing,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "trialUntilTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.trialUntilTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.trialUntilTimestampMsec },
                LibrarySubscriptionDetails::get_trialUntilTimestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signedPurchaseData",
                |m: &LibrarySubscriptionDetails| { &m.signedPurchaseData },
                |m: &mut LibrarySubscriptionDetails| { &mut m.signedPurchaseData },
                LibrarySubscriptionDetails::get_signedPurchaseData,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signature",
                |m: &LibrarySubscriptionDetails| { &m.signature },
                |m: &mut LibrarySubscriptionDetails| { &mut m.signature },
                LibrarySubscriptionDetails::get_signature,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LibrarySubscriptionDetails>(
                "LibrarySubscriptionDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibrarySubscriptionDetails {
        static instance: ::protobuf::rt::Lazy<LibrarySubscriptionDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(LibrarySubscriptionDetails::new)
    }
}

impl ::protobuf::Clear for LibrarySubscriptionDetails {
    fn clear(&mut self) {
        self.initiationTimestampMsec = ::std::option::Option::None;
        self.deprecatedValidUntilTimestampMsec = ::std::option::Option::None;
        self.autoRenewing = ::std::option::Option::None;
        self.trialUntilTimestampMsec = ::std::option::Option::None;
        self.signedPurchaseData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibrarySubscriptionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibrarySubscriptionDetails {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LibraryUpdate {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub corpus: ::std::option::Option<i32>,
    pub serverToken: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub mutation: ::protobuf::RepeatedField<LibraryMutation>,
    pub hasMore: ::std::option::Option<bool>,
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LibraryUpdate {
    pub fn new() -> LibraryUpdate {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;

    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional int32 corpus = 2;

    pub fn get_corpus(&self) -> i32 {
        self.corpus.unwrap_or(0)
    }

    // optional bytes serverToken = 3;

    pub fn get_serverToken(&self) -> &[u8] {
        match self.serverToken.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bool hasMore = 5;

    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    // optional string libraryId = 6;

    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibraryUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.mutation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.corpus = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverToken)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.mutation)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corpus {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serverToken.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.mutation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        if let Some(v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.corpus {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.serverToken.as_ref() {
            os.write_bytes(3, v)?;
        }
        for v in &self.mutation {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.libraryId.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryUpdate {
        LibraryUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "status",
                |m: &LibraryUpdate| { &m.status },
                |m: &mut LibraryUpdate| { &mut m.status },
                LibraryUpdate::get_status,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "corpus",
                |m: &LibraryUpdate| { &m.corpus },
                |m: &mut LibraryUpdate| { &mut m.corpus },
                LibraryUpdate::get_corpus,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverToken",
                |m: &LibraryUpdate| { &m.serverToken },
                |m: &mut LibraryUpdate| { &mut m.serverToken },
                LibraryUpdate::get_serverToken,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryMutation>>(
                "mutation",
                |m: &LibraryUpdate| { &m.mutation },
                |m: &mut LibraryUpdate| { &mut m.mutation },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "hasMore",
                |m: &LibraryUpdate| { &m.hasMore },
                |m: &mut LibraryUpdate| { &mut m.hasMore },
                LibraryUpdate::get_hasMore,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "libraryId",
                |m: &LibraryUpdate| { &m.libraryId },
                |m: &mut LibraryUpdate| { &mut m.libraryId },
                LibraryUpdate::get_libraryId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LibraryUpdate>(
                "LibraryUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryUpdate {
        static instance: ::protobuf::rt::Lazy<LibraryUpdate> = ::protobuf::rt::Lazy::INIT;
        instance.get(LibraryUpdate::new)
    }
}

impl ::protobuf::Clear for LibraryUpdate {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.corpus = ::std::option::Option::None;
        self.serverToken.clear();
        self.mutation.clear();
        self.hasMore = ::std::option::Option::None;
        self.libraryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryUpdate {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientLibraryState {
    // message fields
    pub corpus: ::std::option::Option<i32>,
    pub serverToken: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub hashCodeSum: ::std::option::Option<i64>,
    pub librarySize: ::std::option::Option<i32>,
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientLibraryState {
    pub fn new() -> ClientLibraryState {
        ::std::default::Default::default()
    }

    // optional int32 corpus = 1;

    pub fn get_corpus(&self) -> i32 {
        self.corpus.unwrap_or(0)
    }

    // optional bytes serverToken = 2;

    pub fn get_serverToken(&self) -> &[u8] {
        match self.serverToken.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional int64 hashCodeSum = 3;

    pub fn get_hashCodeSum(&self) -> i64 {
        self.hashCodeSum.unwrap_or(0)
    }

    // optional int32 librarySize = 4;

    pub fn get_librarySize(&self) -> i32 {
        self.librarySize.unwrap_or(0)
    }

    // optional string libraryId = 5;

    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClientLibraryState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.corpus = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverToken)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.hashCodeSum = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.librarySize = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.corpus {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serverToken.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.hashCodeSum {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.librarySize {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.corpus {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.serverToken.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.hashCodeSum {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.librarySize {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.libraryId.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientLibraryState {
        ClientLibraryState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "corpus",
                |m: &ClientLibraryState| { &m.corpus },
                |m: &mut ClientLibraryState| { &mut m.corpus },
                ClientLibraryState::get_corpus,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverToken",
                |m: &ClientLibraryState| { &m.serverToken },
                |m: &mut ClientLibraryState| { &mut m.serverToken },
                ClientLibraryState::get_serverToken,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "hashCodeSum",
                |m: &ClientLibraryState| { &m.hashCodeSum },
                |m: &mut ClientLibraryState| { &mut m.hashCodeSum },
                ClientLibraryState::get_hashCodeSum,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "librarySize",
                |m: &ClientLibraryState| { &m.librarySize },
                |m: &mut ClientLibraryState| { &mut m.librarySize },
                ClientLibraryState::get_librarySize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "libraryId",
                |m: &ClientLibraryState| { &m.libraryId },
                |m: &mut ClientLibraryState| { &mut m.libraryId },
                ClientLibraryState::get_libraryId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientLibraryState>(
                "ClientLibraryState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientLibraryState {
        static instance: ::protobuf::rt::Lazy<ClientLibraryState> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientLibraryState::new)
    }
}

impl ::protobuf::Clear for ClientLibraryState {
    fn clear(&mut self) {
        self.corpus = ::std::option::Option::None;
        self.serverToken.clear();
        self.hashCodeSum = ::std::option::Option::None;
        self.librarySize = ::std::option::Option::None;
        self.libraryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientLibraryState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientLibraryState {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LibraryReplicationRequest {
    // message fields
    pub libraryState: ::protobuf::RepeatedField<ClientLibraryState>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LibraryReplicationRequest {
    pub fn new() -> LibraryReplicationRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LibraryReplicationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.libraryState)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.libraryState {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.libraryState {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryReplicationRequest {
        LibraryReplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientLibraryState>>(
                "libraryState",
                |m: &LibraryReplicationRequest| { &m.libraryState },
                |m: &mut LibraryReplicationRequest| { &mut m.libraryState },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LibraryReplicationRequest>(
                "LibraryReplicationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryReplicationRequest {
        static instance: ::protobuf::rt::Lazy<LibraryReplicationRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(LibraryReplicationRequest::new)
    }
}

impl ::protobuf::Clear for LibraryReplicationRequest {
    fn clear(&mut self) {
        self.libraryState.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryReplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryReplicationRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LibraryReplicationResponse {
    // message fields
    pub update: ::protobuf::RepeatedField<LibraryUpdate>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LibraryReplicationResponse {
    pub fn new() -> LibraryReplicationResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LibraryReplicationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.update {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.update {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryReplicationResponse {
        LibraryReplicationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "update",
                |m: &LibraryReplicationResponse| { &m.update },
                |m: &mut LibraryReplicationResponse| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LibraryReplicationResponse>(
                "LibraryReplicationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryReplicationResponse {
        static instance: ::protobuf::rt::Lazy<LibraryReplicationResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(LibraryReplicationResponse::new)
    }
}

impl ::protobuf::Clear for LibraryReplicationResponse {
    fn clear(&mut self) {
        self.update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryReplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryReplicationResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClickLogEvent {
    // message fields
    pub eventTime: ::std::option::Option<i64>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub listId: ::protobuf::SingularField<::std::string::String>,
    pub referrerUrl: ::protobuf::SingularField<::std::string::String>,
    pub referrerListId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClickLogEvent {
    pub fn new() -> ClickLogEvent {
        ::std::default::Default::default()
    }

    // optional int64 eventTime = 1;

    pub fn get_eventTime(&self) -> i64 {
        self.eventTime.unwrap_or(0)
    }

    // optional string url = 2;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string listId = 3;

    pub fn get_listId(&self) -> &str {
        match self.listId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string referrerUrl = 4;

    pub fn get_referrerUrl(&self) -> &str {
        match self.referrerUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string referrerListId = 5;

    pub fn get_referrerListId(&self) -> &str {
        match self.referrerListId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClickLogEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.eventTime = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.listId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrerUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrerListId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.listId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.referrerUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.referrerListId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventTime {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.listId.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.referrerUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.referrerListId.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClickLogEvent {
        ClickLogEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "eventTime",
                |m: &ClickLogEvent| { &m.eventTime },
                |m: &mut ClickLogEvent| { &mut m.eventTime },
                ClickLogEvent::get_eventTime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &ClickLogEvent| { &m.url },
                |m: &mut ClickLogEvent| { &mut m.url },
                ClickLogEvent::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "listId",
                |m: &ClickLogEvent| { &m.listId },
                |m: &mut ClickLogEvent| { &mut m.listId },
                ClickLogEvent::get_listId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "referrerUrl",
                |m: &ClickLogEvent| { &m.referrerUrl },
                |m: &mut ClickLogEvent| { &mut m.referrerUrl },
                ClickLogEvent::get_referrerUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "referrerListId",
                |m: &ClickLogEvent| { &m.referrerListId },
                |m: &mut ClickLogEvent| { &mut m.referrerListId },
                ClickLogEvent::get_referrerListId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClickLogEvent>(
                "ClickLogEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClickLogEvent {
        static instance: ::protobuf::rt::Lazy<ClickLogEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClickLogEvent::new)
    }
}

impl ::protobuf::Clear for ClickLogEvent {
    fn clear(&mut self) {
        self.eventTime = ::std::option::Option::None;
        self.url.clear();
        self.listId.clear();
        self.referrerUrl.clear();
        self.referrerListId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClickLogEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClickLogEvent {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ModifyLibraryRequest {
    // message fields
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    pub forAddDocid: ::protobuf::RepeatedField<::std::string::String>,
    pub forRemovalDocid: ::protobuf::RepeatedField<::std::string::String>,
    pub forArchiveDocid: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ModifyLibraryRequest {
    pub fn new() -> ModifyLibraryRequest {
        ::std::default::Default::default()
    }

    // optional string libraryId = 1;

    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ModifyLibraryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.forAddDocid)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.forRemovalDocid)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.forArchiveDocid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.forAddDocid {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.forRemovalDocid {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.forArchiveDocid {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.libraryId.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.forAddDocid {
            os.write_string(2, &v)?;
        };
        for v in &self.forRemovalDocid {
            os.write_string(3, &v)?;
        };
        for v in &self.forArchiveDocid {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyLibraryRequest {
        ModifyLibraryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "libraryId",
                |m: &ModifyLibraryRequest| { &m.libraryId },
                |m: &mut ModifyLibraryRequest| { &mut m.libraryId },
                ModifyLibraryRequest::get_libraryId,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forAddDocid",
                |m: &ModifyLibraryRequest| { &m.forAddDocid },
                |m: &mut ModifyLibraryRequest| { &mut m.forAddDocid },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forRemovalDocid",
                |m: &ModifyLibraryRequest| { &m.forRemovalDocid },
                |m: &mut ModifyLibraryRequest| { &mut m.forRemovalDocid },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forArchiveDocid",
                |m: &ModifyLibraryRequest| { &m.forArchiveDocid },
                |m: &mut ModifyLibraryRequest| { &mut m.forArchiveDocid },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ModifyLibraryRequest>(
                "ModifyLibraryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyLibraryRequest {
        static instance: ::protobuf::rt::Lazy<ModifyLibraryRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(ModifyLibraryRequest::new)
    }
}

impl ::protobuf::Clear for ModifyLibraryRequest {
    fn clear(&mut self) {
        self.libraryId.clear();
        self.forAddDocid.clear();
        self.forRemovalDocid.clear();
        self.forArchiveDocid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyLibraryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyLibraryRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ModifyLibraryResponse {
    // message fields
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ModifyLibraryResponse {
    pub fn new() -> ModifyLibraryResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModifyLibraryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryUpdate, _>(wire_type, is, &mut self.libraryUpdate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.libraryUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyLibraryResponse {
        ModifyLibraryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>, _>(
                "libraryUpdate",
                |m: &ModifyLibraryResponse| { &m.libraryUpdate },
                |m: &mut ModifyLibraryResponse| { &mut m.libraryUpdate },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ModifyLibraryResponse>(
                "ModifyLibraryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyLibraryResponse {
        static instance: ::protobuf::rt::Lazy<ModifyLibraryResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ModifyLibraryResponse::new)
    }
}

impl ::protobuf::Clear for ModifyLibraryResponse {
    fn clear(&mut self) {
        self.libraryUpdate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyLibraryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyLibraryResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AndroidAppNotificationData {
    // message fields
    pub versionCode: ::std::option::Option<i32>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AndroidAppNotificationData {
    pub fn new() -> AndroidAppNotificationData {
        ::std::default::Default::default()
    }

    // optional int32 versionCode = 1;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string assetId = 2;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidAppNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.versionCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppNotificationData {
        AndroidAppNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &AndroidAppNotificationData| { &m.versionCode },
                |m: &mut AndroidAppNotificationData| { &mut m.versionCode },
                AndroidAppNotificationData::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &AndroidAppNotificationData| { &m.assetId },
                |m: &mut AndroidAppNotificationData| { &mut m.assetId },
                AndroidAppNotificationData::get_assetId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AndroidAppNotificationData>(
                "AndroidAppNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppNotificationData {
        static instance: ::protobuf::rt::Lazy<AndroidAppNotificationData> = ::protobuf::rt::Lazy::INIT;
        instance.get(AndroidAppNotificationData::new)
    }
}

impl ::protobuf::Clear for AndroidAppNotificationData {
    fn clear(&mut self) {
        self.versionCode = ::std::option::Option::None;
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppNotificationData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InAppNotificationData {
    // message fields
    pub checkoutOrderId: ::protobuf::SingularField<::std::string::String>,
    pub inAppNotificationId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InAppNotificationData {
    pub fn new() -> InAppNotificationData {
        ::std::default::Default::default()
    }

    // optional string checkoutOrderId = 1;

    pub fn get_checkoutOrderId(&self) -> &str {
        match self.checkoutOrderId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string inAppNotificationId = 2;

    pub fn get_inAppNotificationId(&self) -> &str {
        match self.inAppNotificationId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for InAppNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutOrderId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.inAppNotificationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.checkoutOrderId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inAppNotificationId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.checkoutOrderId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.inAppNotificationId.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppNotificationData {
        InAppNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "checkoutOrderId",
                |m: &InAppNotificationData| { &m.checkoutOrderId },
                |m: &mut InAppNotificationData| { &mut m.checkoutOrderId },
                InAppNotificationData::get_checkoutOrderId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "inAppNotificationId",
                |m: &InAppNotificationData| { &m.inAppNotificationId },
                |m: &mut InAppNotificationData| { &mut m.inAppNotificationId },
                InAppNotificationData::get_inAppNotificationId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InAppNotificationData>(
                "InAppNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppNotificationData {
        static instance: ::protobuf::rt::Lazy<InAppNotificationData> = ::protobuf::rt::Lazy::INIT;
        instance.get(InAppNotificationData::new)
    }
}

impl ::protobuf::Clear for InAppNotificationData {
    fn clear(&mut self) {
        self.checkoutOrderId.clear();
        self.inAppNotificationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppNotificationData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct LibraryDirtyData {
    // message fields
    pub backend: ::std::option::Option<i32>,
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl LibraryDirtyData {
    pub fn new() -> LibraryDirtyData {
        ::std::default::Default::default()
    }

    // optional int32 backend = 1;

    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }

    // optional string libraryId = 2;

    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibraryDirtyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.backend {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.libraryId.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryDirtyData {
        LibraryDirtyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "backend",
                |m: &LibraryDirtyData| { &m.backend },
                |m: &mut LibraryDirtyData| { &mut m.backend },
                LibraryDirtyData::get_backend,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "libraryId",
                |m: &LibraryDirtyData| { &m.libraryId },
                |m: &mut LibraryDirtyData| { &mut m.libraryId },
                LibraryDirtyData::get_libraryId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<LibraryDirtyData>(
                "LibraryDirtyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryDirtyData {
        static instance: ::protobuf::rt::Lazy<LibraryDirtyData> = ::protobuf::rt::Lazy::INIT;
        instance.get(LibraryDirtyData::new)
    }
}

impl ::protobuf::Clear for LibraryDirtyData {
    fn clear(&mut self) {
        self.backend = ::std::option::Option::None;
        self.libraryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryDirtyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryDirtyData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Notification {
    // message fields
    pub notificationType: ::std::option::Option<i32>,
    pub timestamp: ::std::option::Option<i64>,
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub docTitle: ::protobuf::SingularField<::std::string::String>,
    pub userEmail: ::protobuf::SingularField<::std::string::String>,
    pub appData: ::protobuf::SingularPtrField<AndroidAppNotificationData>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    pub purchaseRemovalData: ::protobuf::SingularPtrField<PurchaseRemovalData>,
    pub userNotificationData: ::protobuf::SingularPtrField<UserNotificationData>,
    pub inAppNotificationData: ::protobuf::SingularPtrField<InAppNotificationData>,
    pub purchaseDeclinedData: ::protobuf::SingularPtrField<PurchaseDeclinedData>,
    pub notificationId: ::protobuf::SingularField<::std::string::String>,
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    pub libraryDirtyData: ::protobuf::SingularPtrField<LibraryDirtyData>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Notification {
    pub fn new() -> Notification {
        ::std::default::Default::default()
    }

    // optional int32 notificationType = 1;

    pub fn get_notificationType(&self) -> i32 {
        self.notificationType.unwrap_or(0)
    }

    // optional int64 timestamp = 3;

    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    // optional string docTitle = 5;

    pub fn get_docTitle(&self) -> &str {
        match self.docTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string userEmail = 6;

    pub fn get_userEmail(&self) -> &str {
        match self.userEmail.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string notificationId = 13;

    pub fn get_notificationId(&self) -> &str {
        match self.notificationId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseRemovalData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userNotificationData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppNotificationData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseDeclinedData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryDirtyData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.notificationType = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.docid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docTitle)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userEmail)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<AndroidAppNotificationData, _>(wire_type, is, &mut self.appData)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<AndroidAppDeliveryData, _>(wire_type, is, &mut self.appDeliveryData)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseRemovalData, _>(wire_type, is, &mut self.purchaseRemovalData)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<UserNotificationData, _>(wire_type, is, &mut self.userNotificationData)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<InAppNotificationData, _>(wire_type, is, &mut self.inAppNotificationData)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseDeclinedData, _>(wire_type, is, &mut self.purchaseDeclinedData)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationId)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryUpdate, _>(wire_type, is, &mut self.libraryUpdate)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryDirtyData, _>(wire_type, is, &mut self.libraryDirtyData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.notificationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.docTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.userEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.appData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseRemovalData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.userNotificationData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.inAppNotificationData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseDeclinedData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.notificationId.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.libraryDirtyData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.notificationType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.docid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.docTitle.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.userEmail.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.appData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.appDeliveryData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.purchaseRemovalData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.userNotificationData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.inAppNotificationData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.purchaseDeclinedData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.notificationId.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.libraryUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.libraryDirtyData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Notification {
        Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "notificationType",
                |m: &Notification| { &m.notificationType },
                |m: &mut Notification| { &mut m.notificationType },
                Notification::get_notificationType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "timestamp",
                |m: &Notification| { &m.timestamp },
                |m: &mut Notification| { &mut m.timestamp },
                Notification::get_timestamp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "docid",
                |m: &Notification| { &m.docid },
                |m: &mut Notification| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "docTitle",
                |m: &Notification| { &m.docTitle },
                |m: &mut Notification| { &mut m.docTitle },
                Notification::get_docTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userEmail",
                |m: &Notification| { &m.userEmail },
                |m: &mut Notification| { &mut m.userEmail },
                Notification::get_userEmail,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppNotificationData>, _>(
                "appData",
                |m: &Notification| { &m.appData },
                |m: &mut Notification| { &mut m.appData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>, _>(
                "appDeliveryData",
                |m: &Notification| { &m.appDeliveryData },
                |m: &mut Notification| { &mut m.appDeliveryData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseRemovalData>, _>(
                "purchaseRemovalData",
                |m: &Notification| { &m.purchaseRemovalData },
                |m: &mut Notification| { &mut m.purchaseRemovalData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserNotificationData>, _>(
                "userNotificationData",
                |m: &Notification| { &m.userNotificationData },
                |m: &mut Notification| { &mut m.userNotificationData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppNotificationData>, _>(
                "inAppNotificationData",
                |m: &Notification| { &m.inAppNotificationData },
                |m: &mut Notification| { &mut m.inAppNotificationData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseDeclinedData>, _>(
                "purchaseDeclinedData",
                |m: &Notification| { &m.purchaseDeclinedData },
                |m: &mut Notification| { &mut m.purchaseDeclinedData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "notificationId",
                |m: &Notification| { &m.notificationId },
                |m: &mut Notification| { &mut m.notificationId },
                Notification::get_notificationId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>, _>(
                "libraryUpdate",
                |m: &Notification| { &m.libraryUpdate },
                |m: &mut Notification| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryDirtyData>, _>(
                "libraryDirtyData",
                |m: &Notification| { &m.libraryDirtyData },
                |m: &mut Notification| { &mut m.libraryDirtyData },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Notification>(
                "Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Notification {
        static instance: ::protobuf::rt::Lazy<Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(Notification::new)
    }
}

impl ::protobuf::Clear for Notification {
    fn clear(&mut self) {
        self.notificationType = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.docid.clear();
        self.docTitle.clear();
        self.userEmail.clear();
        self.appData.clear();
        self.appDeliveryData.clear();
        self.purchaseRemovalData.clear();
        self.userNotificationData.clear();
        self.inAppNotificationData.clear();
        self.purchaseDeclinedData.clear();
        self.notificationId.clear();
        self.libraryUpdate.clear();
        self.libraryDirtyData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Notification {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseDeclinedData {
    // message fields
    pub reason: ::std::option::Option<i32>,
    pub showNotification: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseDeclinedData {
    pub fn new() -> PurchaseDeclinedData {
        ::std::default::Default::default()
    }

    // optional int32 reason = 1;

    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    // optional bool showNotification = 2;

    pub fn get_showNotification(&self) -> bool {
        self.showNotification.unwrap_or(false)
    }
}

impl ::protobuf::Message for PurchaseDeclinedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.showNotification = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.showNotification {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.showNotification {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseDeclinedData {
        PurchaseDeclinedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "reason",
                |m: &PurchaseDeclinedData| { &m.reason },
                |m: &mut PurchaseDeclinedData| { &mut m.reason },
                PurchaseDeclinedData::get_reason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "showNotification",
                |m: &PurchaseDeclinedData| { &m.showNotification },
                |m: &mut PurchaseDeclinedData| { &mut m.showNotification },
                PurchaseDeclinedData::get_showNotification,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseDeclinedData>(
                "PurchaseDeclinedData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseDeclinedData {
        static instance: ::protobuf::rt::Lazy<PurchaseDeclinedData> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseDeclinedData::new)
    }
}

impl ::protobuf::Clear for PurchaseDeclinedData {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.showNotification = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseDeclinedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseDeclinedData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseRemovalData {
    // message fields
    pub malicious: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseRemovalData {
    pub fn new() -> PurchaseRemovalData {
        ::std::default::Default::default()
    }

    // optional bool malicious = 1;

    pub fn get_malicious(&self) -> bool {
        self.malicious.unwrap_or(false)
    }
}

impl ::protobuf::Message for PurchaseRemovalData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.malicious = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.malicious {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.malicious {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseRemovalData {
        PurchaseRemovalData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "malicious",
                |m: &PurchaseRemovalData| { &m.malicious },
                |m: &mut PurchaseRemovalData| { &mut m.malicious },
                PurchaseRemovalData::get_malicious,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseRemovalData>(
                "PurchaseRemovalData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseRemovalData {
        static instance: ::protobuf::rt::Lazy<PurchaseRemovalData> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseRemovalData::new)
    }
}

impl ::protobuf::Clear for PurchaseRemovalData {
    fn clear(&mut self) {
        self.malicious = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseRemovalData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseRemovalData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UserNotificationData {
    // message fields
    pub notificationTitle: ::protobuf::SingularField<::std::string::String>,
    pub notificationText: ::protobuf::SingularField<::std::string::String>,
    pub tickerText: ::protobuf::SingularField<::std::string::String>,
    pub dialogTitle: ::protobuf::SingularField<::std::string::String>,
    pub dialogText: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UserNotificationData {
    pub fn new() -> UserNotificationData {
        ::std::default::Default::default()
    }

    // optional string notificationTitle = 1;

    pub fn get_notificationTitle(&self) -> &str {
        match self.notificationTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string notificationText = 2;

    pub fn get_notificationText(&self) -> &str {
        match self.notificationText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string tickerText = 3;

    pub fn get_tickerText(&self) -> &str {
        match self.tickerText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string dialogTitle = 4;

    pub fn get_dialogTitle(&self) -> &str {
        match self.dialogTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string dialogText = 5;

    pub fn get_dialogText(&self) -> &str {
        match self.dialogText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UserNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationText)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tickerText)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dialogTitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dialogText)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.notificationTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.notificationText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.tickerText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.dialogTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.dialogText.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.notificationTitle.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.notificationText.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.tickerText.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.dialogTitle.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.dialogText.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserNotificationData {
        UserNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "notificationTitle",
                |m: &UserNotificationData| { &m.notificationTitle },
                |m: &mut UserNotificationData| { &mut m.notificationTitle },
                UserNotificationData::get_notificationTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "notificationText",
                |m: &UserNotificationData| { &m.notificationText },
                |m: &mut UserNotificationData| { &mut m.notificationText },
                UserNotificationData::get_notificationText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tickerText",
                |m: &UserNotificationData| { &m.tickerText },
                |m: &mut UserNotificationData| { &mut m.tickerText },
                UserNotificationData::get_tickerText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "dialogTitle",
                |m: &UserNotificationData| { &m.dialogTitle },
                |m: &mut UserNotificationData| { &mut m.dialogTitle },
                UserNotificationData::get_dialogTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "dialogText",
                |m: &UserNotificationData| { &m.dialogText },
                |m: &mut UserNotificationData| { &mut m.dialogText },
                UserNotificationData::get_dialogText,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<UserNotificationData>(
                "UserNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserNotificationData {
        static instance: ::protobuf::rt::Lazy<UserNotificationData> = ::protobuf::rt::Lazy::INIT;
        instance.get(UserNotificationData::new)
    }
}

impl ::protobuf::Clear for UserNotificationData {
    fn clear(&mut self) {
        self.notificationTitle.clear();
        self.notificationText.clear();
        self.tickerText.clear();
        self.dialogTitle.clear();
        self.dialogText.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserNotificationData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct OwnershipInfo {
    // message fields
    pub initiationTimestampMsec: ::std::option::Option<i64>,
    pub validUntilTimestampMsec: ::std::option::Option<i64>,
    pub autoRenewing: ::std::option::Option<bool>,
    pub refundTimeoutTimestampMsec: ::std::option::Option<i64>,
    pub postDeliveryRefundWindowMsec: ::std::option::Option<i64>,
    pub developerPurchaseInfo: ::protobuf::SingularPtrField<SignedData>,
    pub preordered: ::std::option::Option<bool>,
    pub hidden: ::std::option::Option<bool>,
    pub rentalTerms: ::protobuf::SingularPtrField<RentalTerms>,
    pub groupLicenseInfo: ::protobuf::SingularPtrField<GroupLicenseInfo>,
    pub licensedDocumentInfo: ::protobuf::SingularPtrField<LicensedDocumentInfo>,
    pub quantity: ::std::option::Option<i32>,
    pub libraryExpirationTimestampMsec: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl OwnershipInfo {
    pub fn new() -> OwnershipInfo {
        ::std::default::Default::default()
    }

    // optional int64 initiationTimestampMsec = 1;

    pub fn get_initiationTimestampMsec(&self) -> i64 {
        self.initiationTimestampMsec.unwrap_or(0)
    }

    // optional int64 validUntilTimestampMsec = 2;

    pub fn get_validUntilTimestampMsec(&self) -> i64 {
        self.validUntilTimestampMsec.unwrap_or(0)
    }

    // optional bool autoRenewing = 3;

    pub fn get_autoRenewing(&self) -> bool {
        self.autoRenewing.unwrap_or(false)
    }

    // optional int64 refundTimeoutTimestampMsec = 4;

    pub fn get_refundTimeoutTimestampMsec(&self) -> i64 {
        self.refundTimeoutTimestampMsec.unwrap_or(0)
    }

    // optional int64 postDeliveryRefundWindowMsec = 5;

    pub fn get_postDeliveryRefundWindowMsec(&self) -> i64 {
        self.postDeliveryRefundWindowMsec.unwrap_or(0)
    }

    // optional bool preordered = 7;

    pub fn get_preordered(&self) -> bool {
        self.preordered.unwrap_or(false)
    }

    // optional bool hidden = 8;

    pub fn get_hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    // optional int32 quantity = 12;

    pub fn get_quantity(&self) -> i32 {
        self.quantity.unwrap_or(0)
    }

    // optional int64 libraryExpirationTimestampMsec = 14;

    pub fn get_libraryExpirationTimestampMsec(&self) -> i64 {
        self.libraryExpirationTimestampMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for OwnershipInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.developerPurchaseInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rentalTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groupLicenseInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.licensedDocumentInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initiationTimestampMsec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.validUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoRenewing = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutTimestampMsec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postDeliveryRefundWindowMsec = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<SignedData, _>(wire_type, is, &mut self.developerPurchaseInfo)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.preordered = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<RentalTerms, _>(wire_type, is, &mut self.rentalTerms)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<GroupLicenseInfo, _>(wire_type, is, &mut self.groupLicenseInfo)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<LicensedDocumentInfo, _>(wire_type, is, &mut self.licensedDocumentInfo)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.libraryExpirationTimestampMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initiationTimestampMsec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.validUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.autoRenewing {
            my_size += 2;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.developerPurchaseInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.preordered {
            my_size += 2;
        }
        if let Some(v) = self.hidden {
            my_size += 2;
        }
        if let Some(v) = self.rentalTerms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.groupLicenseInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.licensedDocumentInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.libraryExpirationTimestampMsec {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initiationTimestampMsec {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.validUntilTimestampMsec {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.autoRenewing {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.developerPurchaseInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.preordered {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.rentalTerms.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.groupLicenseInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.licensedDocumentInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.quantity {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.libraryExpirationTimestampMsec {
            os.write_int64(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OwnershipInfo {
        OwnershipInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "initiationTimestampMsec",
                |m: &OwnershipInfo| { &m.initiationTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.initiationTimestampMsec },
                OwnershipInfo::get_initiationTimestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "validUntilTimestampMsec",
                |m: &OwnershipInfo| { &m.validUntilTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.validUntilTimestampMsec },
                OwnershipInfo::get_validUntilTimestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "autoRenewing",
                |m: &OwnershipInfo| { &m.autoRenewing },
                |m: &mut OwnershipInfo| { &mut m.autoRenewing },
                OwnershipInfo::get_autoRenewing,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "refundTimeoutTimestampMsec",
                |m: &OwnershipInfo| { &m.refundTimeoutTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.refundTimeoutTimestampMsec },
                OwnershipInfo::get_refundTimeoutTimestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "postDeliveryRefundWindowMsec",
                |m: &OwnershipInfo| { &m.postDeliveryRefundWindowMsec },
                |m: &mut OwnershipInfo| { &mut m.postDeliveryRefundWindowMsec },
                OwnershipInfo::get_postDeliveryRefundWindowMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignedData>, _>(
                "developerPurchaseInfo",
                |m: &OwnershipInfo| { &m.developerPurchaseInfo },
                |m: &mut OwnershipInfo| { &mut m.developerPurchaseInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "preordered",
                |m: &OwnershipInfo| { &m.preordered },
                |m: &mut OwnershipInfo| { &mut m.preordered },
                OwnershipInfo::get_preordered,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "hidden",
                |m: &OwnershipInfo| { &m.hidden },
                |m: &mut OwnershipInfo| { &mut m.hidden },
                OwnershipInfo::get_hidden,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RentalTerms>, _>(
                "rentalTerms",
                |m: &OwnershipInfo| { &m.rentalTerms },
                |m: &mut OwnershipInfo| { &mut m.rentalTerms },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupLicenseInfo>, _>(
                "groupLicenseInfo",
                |m: &OwnershipInfo| { &m.groupLicenseInfo },
                |m: &mut OwnershipInfo| { &mut m.groupLicenseInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LicensedDocumentInfo>, _>(
                "licensedDocumentInfo",
                |m: &OwnershipInfo| { &m.licensedDocumentInfo },
                |m: &mut OwnershipInfo| { &mut m.licensedDocumentInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "quantity",
                |m: &OwnershipInfo| { &m.quantity },
                |m: &mut OwnershipInfo| { &mut m.quantity },
                OwnershipInfo::get_quantity,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "libraryExpirationTimestampMsec",
                |m: &OwnershipInfo| { &m.libraryExpirationTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.libraryExpirationTimestampMsec },
                OwnershipInfo::get_libraryExpirationTimestampMsec,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<OwnershipInfo>(
                "OwnershipInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OwnershipInfo {
        static instance: ::protobuf::rt::Lazy<OwnershipInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(OwnershipInfo::new)
    }
}

impl ::protobuf::Clear for OwnershipInfo {
    fn clear(&mut self) {
        self.initiationTimestampMsec = ::std::option::Option::None;
        self.validUntilTimestampMsec = ::std::option::Option::None;
        self.autoRenewing = ::std::option::Option::None;
        self.refundTimeoutTimestampMsec = ::std::option::Option::None;
        self.postDeliveryRefundWindowMsec = ::std::option::Option::None;
        self.developerPurchaseInfo.clear();
        self.preordered = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.rentalTerms.clear();
        self.groupLicenseInfo.clear();
        self.licensedDocumentInfo.clear();
        self.quantity = ::std::option::Option::None;
        self.libraryExpirationTimestampMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OwnershipInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OwnershipInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AppData {
    // message fields
    pub version: ::std::option::Option<i32>,
    pub oldVersion: ::std::option::Option<i32>,
    pub systemApp: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AppData {
    pub fn new() -> AppData {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional int32 oldVersion = 2;

    pub fn get_oldVersion(&self) -> i32 {
        self.oldVersion.unwrap_or(0)
    }

    // optional bool systemApp = 3;

    pub fn get_systemApp(&self) -> bool {
        self.systemApp.unwrap_or(false)
    }
}

impl ::protobuf::Message for AppData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.oldVersion = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.systemApp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.oldVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.systemApp {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.oldVersion {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.systemApp {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppData {
        AppData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "version",
                |m: &AppData| { &m.version },
                |m: &mut AppData| { &mut m.version },
                AppData::get_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "oldVersion",
                |m: &AppData| { &m.oldVersion },
                |m: &mut AppData| { &mut m.oldVersion },
                AppData::get_oldVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "systemApp",
                |m: &AppData| { &m.systemApp },
                |m: &mut AppData| { &mut m.systemApp },
                AppData::get_systemApp,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AppData>(
                "AppData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppData {
        static instance: ::protobuf::rt::Lazy<AppData> = ::protobuf::rt::Lazy::INIT;
        instance.get(AppData::new)
    }
}

impl ::protobuf::Clear for AppData {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.oldVersion = ::std::option::Option::None;
        self.systemApp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreBackgroundActionEvent {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub document: ::protobuf::SingularField<::std::string::String>,
    pub reason: ::protobuf::SingularField<::std::string::String>,
    pub errorCode: ::std::option::Option<i32>,
    pub exceptionType: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub offerType: ::std::option::Option<i32>,
    pub fromSetting: ::std::option::Option<i32>,
    pub toSetting: ::std::option::Option<i32>,
    pub sessionInfo: ::protobuf::SingularPtrField<PlayStoreSessionData>,
    pub appData: ::protobuf::SingularPtrField<AppData>,
    pub serverLatencyMs: ::std::option::Option<i64>,
    pub clientLatencyMs: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreBackgroundActionEvent {
    pub fn new() -> PlayStoreBackgroundActionEvent {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string document = 2;

    pub fn get_document(&self) -> &str {
        match self.document.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string reason = 3;

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 errorCode = 4;

    pub fn get_errorCode(&self) -> i32 {
        self.errorCode.unwrap_or(0)
    }

    // optional string exceptionType = 5;

    pub fn get_exceptionType(&self) -> &str {
        match self.exceptionType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 6;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional int32 offerType = 7;

    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional int32 fromSetting = 8;

    pub fn get_fromSetting(&self) -> i32 {
        self.fromSetting.unwrap_or(0)
    }

    // optional int32 toSetting = 9;

    pub fn get_toSetting(&self) -> i32 {
        self.toSetting.unwrap_or(0)
    }

    // optional int64 serverLatencyMs = 12;

    pub fn get_serverLatencyMs(&self) -> i64 {
        self.serverLatencyMs.unwrap_or(0)
    }

    // optional int64 clientLatencyMs = 13;

    pub fn get_clientLatencyMs(&self) -> i64 {
        self.clientLatencyMs.unwrap_or(0)
    }
}

impl ::protobuf::Message for PlayStoreBackgroundActionEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.sessionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.document)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.exceptionType)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fromSetting = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.toSetting = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreSessionData, _>(wire_type, is, &mut self.sessionInfo)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<AppData, _>(wire_type, is, &mut self.appData)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.serverLatencyMs = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.clientLatencyMs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.document.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.exceptionType.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fromSetting {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.toSetting {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sessionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.appData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.serverLatencyMs {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.clientLatencyMs {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.document.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.errorCode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.exceptionType.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.fromSetting {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.toSetting {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.sessionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.appData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.serverLatencyMs {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.clientLatencyMs {
            os.write_int64(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreBackgroundActionEvent {
        PlayStoreBackgroundActionEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &PlayStoreBackgroundActionEvent| { &m.field_type },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.field_type },
                PlayStoreBackgroundActionEvent::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "document",
                |m: &PlayStoreBackgroundActionEvent| { &m.document },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.document },
                PlayStoreBackgroundActionEvent::get_document,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "reason",
                |m: &PlayStoreBackgroundActionEvent| { &m.reason },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.reason },
                PlayStoreBackgroundActionEvent::get_reason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "errorCode",
                |m: &PlayStoreBackgroundActionEvent| { &m.errorCode },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.errorCode },
                PlayStoreBackgroundActionEvent::get_errorCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "exceptionType",
                |m: &PlayStoreBackgroundActionEvent| { &m.exceptionType },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.exceptionType },
                PlayStoreBackgroundActionEvent::get_exceptionType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &PlayStoreBackgroundActionEvent| { &m.serverLogsCookie },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.serverLogsCookie },
                PlayStoreBackgroundActionEvent::get_serverLogsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "offerType",
                |m: &PlayStoreBackgroundActionEvent| { &m.offerType },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.offerType },
                PlayStoreBackgroundActionEvent::get_offerType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "fromSetting",
                |m: &PlayStoreBackgroundActionEvent| { &m.fromSetting },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.fromSetting },
                PlayStoreBackgroundActionEvent::get_fromSetting,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "toSetting",
                |m: &PlayStoreBackgroundActionEvent| { &m.toSetting },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.toSetting },
                PlayStoreBackgroundActionEvent::get_toSetting,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreSessionData>, _>(
                "sessionInfo",
                |m: &PlayStoreBackgroundActionEvent| { &m.sessionInfo },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.sessionInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppData>, _>(
                "appData",
                |m: &PlayStoreBackgroundActionEvent| { &m.appData },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.appData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "serverLatencyMs",
                |m: &PlayStoreBackgroundActionEvent| { &m.serverLatencyMs },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.serverLatencyMs },
                PlayStoreBackgroundActionEvent::get_serverLatencyMs,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "clientLatencyMs",
                |m: &PlayStoreBackgroundActionEvent| { &m.clientLatencyMs },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.clientLatencyMs },
                PlayStoreBackgroundActionEvent::get_clientLatencyMs,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreBackgroundActionEvent>(
                "PlayStoreBackgroundActionEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreBackgroundActionEvent {
        static instance: ::protobuf::rt::Lazy<PlayStoreBackgroundActionEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreBackgroundActionEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreBackgroundActionEvent {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.document.clear();
        self.reason.clear();
        self.errorCode = ::std::option::Option::None;
        self.exceptionType.clear();
        self.serverLogsCookie.clear();
        self.offerType = ::std::option::Option::None;
        self.fromSetting = ::std::option::Option::None;
        self.toSetting = ::std::option::Option::None;
        self.sessionInfo.clear();
        self.appData.clear();
        self.serverLatencyMs = ::std::option::Option::None;
        self.clientLatencyMs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreBackgroundActionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreBackgroundActionEvent {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreClickEvent {
    // message fields
    pub elementPath: ::protobuf::RepeatedField<PlayStoreUiElement>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreClickEvent {
    pub fn new() -> PlayStoreClickEvent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PlayStoreClickEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.elementPath {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.elementPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elementPath {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elementPath {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreClickEvent {
        PlayStoreClickEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElement>>(
                "elementPath",
                |m: &PlayStoreClickEvent| { &m.elementPath },
                |m: &mut PlayStoreClickEvent| { &mut m.elementPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreClickEvent>(
                "PlayStoreClickEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreClickEvent {
        static instance: ::protobuf::rt::Lazy<PlayStoreClickEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreClickEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreClickEvent {
    fn clear(&mut self) {
        self.elementPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreClickEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreClickEvent {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreDeepLinkEvent {
    // message fields
    pub externalUrl: ::protobuf::SingularField<::std::string::String>,
    pub resolvedType: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreDeepLinkEvent {
    pub fn new() -> PlayStoreDeepLinkEvent {
        ::std::default::Default::default()
    }

    // optional string externalUrl = 1;

    pub fn get_externalUrl(&self) -> &str {
        match self.externalUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 resolvedType = 2;

    pub fn get_resolvedType(&self) -> i32 {
        self.resolvedType.unwrap_or(0)
    }
}

impl ::protobuf::Message for PlayStoreDeepLinkEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalUrl)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.resolvedType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.externalUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resolvedType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.externalUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resolvedType {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreDeepLinkEvent {
        PlayStoreDeepLinkEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "externalUrl",
                |m: &PlayStoreDeepLinkEvent| { &m.externalUrl },
                |m: &mut PlayStoreDeepLinkEvent| { &mut m.externalUrl },
                PlayStoreDeepLinkEvent::get_externalUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "resolvedType",
                |m: &PlayStoreDeepLinkEvent| { &m.resolvedType },
                |m: &mut PlayStoreDeepLinkEvent| { &mut m.resolvedType },
                PlayStoreDeepLinkEvent::get_resolvedType,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreDeepLinkEvent>(
                "PlayStoreDeepLinkEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreDeepLinkEvent {
        static instance: ::protobuf::rt::Lazy<PlayStoreDeepLinkEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreDeepLinkEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreDeepLinkEvent {
    fn clear(&mut self) {
        self.externalUrl.clear();
        self.resolvedType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreDeepLinkEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreDeepLinkEvent {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreImpressionEvent {
    // message fields
    pub tree: ::protobuf::SingularPtrField<PlayStoreUiElement>,
    pub referrerPath: ::protobuf::RepeatedField<PlayStoreUiElement>,
    pub id: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreImpressionEvent {
    pub fn new() -> PlayStoreImpressionEvent {
        ::std::default::Default::default()
    }

    // optional int64 id = 3;

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
}

impl ::protobuf::Message for PlayStoreImpressionEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.tree {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.referrerPath {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreUiElement, _>(wire_type, is, &mut self.tree)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.referrerPath)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tree.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.referrerPath {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tree.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.referrerPath {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.id {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreImpressionEvent {
        PlayStoreImpressionEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElement>, _>(
                "tree",
                |m: &PlayStoreImpressionEvent| { &m.tree },
                |m: &mut PlayStoreImpressionEvent| { &mut m.tree },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElement>>(
                "referrerPath",
                |m: &PlayStoreImpressionEvent| { &m.referrerPath },
                |m: &mut PlayStoreImpressionEvent| { &mut m.referrerPath },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "id",
                |m: &PlayStoreImpressionEvent| { &m.id },
                |m: &mut PlayStoreImpressionEvent| { &mut m.id },
                PlayStoreImpressionEvent::get_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreImpressionEvent>(
                "PlayStoreImpressionEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreImpressionEvent {
        static instance: ::protobuf::rt::Lazy<PlayStoreImpressionEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreImpressionEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreImpressionEvent {
    fn clear(&mut self) {
        self.tree.clear();
        self.referrerPath.clear();
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreImpressionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreImpressionEvent {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreLogEvent {
    // message fields
    pub impression: ::protobuf::SingularPtrField<PlayStoreImpressionEvent>,
    pub click: ::protobuf::SingularPtrField<PlayStoreClickEvent>,
    pub backgroundAction: ::protobuf::SingularPtrField<PlayStoreBackgroundActionEvent>,
    pub search: ::protobuf::SingularPtrField<PlayStoreSearchEvent>,
    pub deepLink: ::protobuf::SingularPtrField<PlayStoreDeepLinkEvent>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreLogEvent {
    pub fn new() -> PlayStoreLogEvent {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PlayStoreLogEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.impression {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.click {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.backgroundAction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deepLink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreImpressionEvent, _>(wire_type, is, &mut self.impression)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreClickEvent, _>(wire_type, is, &mut self.click)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreBackgroundActionEvent, _>(wire_type, is, &mut self.backgroundAction)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreSearchEvent, _>(wire_type, is, &mut self.search)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreDeepLinkEvent, _>(wire_type, is, &mut self.deepLink)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.impression.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.click.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.backgroundAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deepLink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.impression.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.click.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.backgroundAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.deepLink.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreLogEvent {
        PlayStoreLogEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreImpressionEvent>, _>(
                "impression",
                |m: &PlayStoreLogEvent| { &m.impression },
                |m: &mut PlayStoreLogEvent| { &mut m.impression },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreClickEvent>, _>(
                "click",
                |m: &PlayStoreLogEvent| { &m.click },
                |m: &mut PlayStoreLogEvent| { &mut m.click },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreBackgroundActionEvent>, _>(
                "backgroundAction",
                |m: &PlayStoreLogEvent| { &m.backgroundAction },
                |m: &mut PlayStoreLogEvent| { &mut m.backgroundAction },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreSearchEvent>, _>(
                "search",
                |m: &PlayStoreLogEvent| { &m.search },
                |m: &mut PlayStoreLogEvent| { &mut m.search },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreDeepLinkEvent>, _>(
                "deepLink",
                |m: &PlayStoreLogEvent| { &m.deepLink },
                |m: &mut PlayStoreLogEvent| { &mut m.deepLink },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreLogEvent>(
                "PlayStoreLogEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreLogEvent {
        static instance: ::protobuf::rt::Lazy<PlayStoreLogEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreLogEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreLogEvent {
    fn clear(&mut self) {
        self.impression.clear();
        self.click.clear();
        self.backgroundAction.clear();
        self.search.clear();
        self.deepLink.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreLogEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreLogEvent {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreSearchEvent {
    // message fields
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub queryUrl: ::protobuf::SingularField<::std::string::String>,
    pub referrerUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreSearchEvent {
    pub fn new() -> PlayStoreSearchEvent {
        ::std::default::Default::default()
    }

    // optional string query = 1;

    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string queryUrl = 2;

    pub fn get_queryUrl(&self) -> &str {
        match self.queryUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string referrerUrl = 3;

    pub fn get_referrerUrl(&self) -> &str {
        match self.referrerUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PlayStoreSearchEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.queryUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrerUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.queryUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.referrerUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.query.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.queryUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.referrerUrl.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreSearchEvent {
        PlayStoreSearchEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "query",
                |m: &PlayStoreSearchEvent| { &m.query },
                |m: &mut PlayStoreSearchEvent| { &mut m.query },
                PlayStoreSearchEvent::get_query,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "queryUrl",
                |m: &PlayStoreSearchEvent| { &m.queryUrl },
                |m: &mut PlayStoreSearchEvent| { &mut m.queryUrl },
                PlayStoreSearchEvent::get_queryUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "referrerUrl",
                |m: &PlayStoreSearchEvent| { &m.referrerUrl },
                |m: &mut PlayStoreSearchEvent| { &mut m.referrerUrl },
                PlayStoreSearchEvent::get_referrerUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreSearchEvent>(
                "PlayStoreSearchEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreSearchEvent {
        static instance: ::protobuf::rt::Lazy<PlayStoreSearchEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreSearchEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreSearchEvent {
    fn clear(&mut self) {
        self.query.clear();
        self.queryUrl.clear();
        self.referrerUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreSearchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreSearchEvent {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreSessionData {
    // message fields
    pub globalAutoUpdateEnabled: ::std::option::Option<bool>,
    pub globalAutoUpdateOverWifiOnly: ::std::option::Option<bool>,
    pub autoUpdateCleanupDialogNumTimesShown: ::std::option::Option<i32>,
    pub networkType: ::std::option::Option<i32>,
    pub networkSubType: ::std::option::Option<i32>,
    pub numAccountsOnDevice: ::std::option::Option<i32>,
    pub numInstalledApps: ::std::option::Option<i32>,
    pub numAutoUpdatingInstalledApps: ::std::option::Option<i32>,
    pub numInstalledAppsNotAutoUpdating: ::std::option::Option<i32>,
    pub gaiaPasswordAuthOptedOut: ::std::option::Option<bool>,
    pub contentFilterLevel: ::std::option::Option<i32>,
    pub allowUnknownSources: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreSessionData {
    pub fn new() -> PlayStoreSessionData {
        ::std::default::Default::default()
    }

    // optional bool globalAutoUpdateEnabled = 1;

    pub fn get_globalAutoUpdateEnabled(&self) -> bool {
        self.globalAutoUpdateEnabled.unwrap_or(false)
    }

    // optional bool globalAutoUpdateOverWifiOnly = 2;

    pub fn get_globalAutoUpdateOverWifiOnly(&self) -> bool {
        self.globalAutoUpdateOverWifiOnly.unwrap_or(false)
    }

    // optional int32 autoUpdateCleanupDialogNumTimesShown = 3;

    pub fn get_autoUpdateCleanupDialogNumTimesShown(&self) -> i32 {
        self.autoUpdateCleanupDialogNumTimesShown.unwrap_or(0)
    }

    // optional int32 networkType = 4;

    pub fn get_networkType(&self) -> i32 {
        self.networkType.unwrap_or(0)
    }

    // optional int32 networkSubType = 5;

    pub fn get_networkSubType(&self) -> i32 {
        self.networkSubType.unwrap_or(0)
    }

    // optional int32 numAccountsOnDevice = 6;

    pub fn get_numAccountsOnDevice(&self) -> i32 {
        self.numAccountsOnDevice.unwrap_or(0)
    }

    // optional int32 numInstalledApps = 7;

    pub fn get_numInstalledApps(&self) -> i32 {
        self.numInstalledApps.unwrap_or(0)
    }

    // optional int32 numAutoUpdatingInstalledApps = 8;

    pub fn get_numAutoUpdatingInstalledApps(&self) -> i32 {
        self.numAutoUpdatingInstalledApps.unwrap_or(0)
    }

    // optional int32 numInstalledAppsNotAutoUpdating = 9;

    pub fn get_numInstalledAppsNotAutoUpdating(&self) -> i32 {
        self.numInstalledAppsNotAutoUpdating.unwrap_or(0)
    }

    // optional bool gaiaPasswordAuthOptedOut = 10;

    pub fn get_gaiaPasswordAuthOptedOut(&self) -> bool {
        self.gaiaPasswordAuthOptedOut.unwrap_or(false)
    }

    // optional int32 contentFilterLevel = 11;

    pub fn get_contentFilterLevel(&self) -> i32 {
        self.contentFilterLevel.unwrap_or(0)
    }

    // optional bool allowUnknownSources = 12;

    pub fn get_allowUnknownSources(&self) -> bool {
        self.allowUnknownSources.unwrap_or(false)
    }
}

impl ::protobuf::Message for PlayStoreSessionData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.globalAutoUpdateEnabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.globalAutoUpdateOverWifiOnly = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.autoUpdateCleanupDialogNumTimesShown = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.networkType = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.networkSubType = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numAccountsOnDevice = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numInstalledApps = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numAutoUpdatingInstalledApps = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numInstalledAppsNotAutoUpdating = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.gaiaPasswordAuthOptedOut = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentFilterLevel = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowUnknownSources = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.globalAutoUpdateEnabled {
            my_size += 2;
        }
        if let Some(v) = self.globalAutoUpdateOverWifiOnly {
            my_size += 2;
        }
        if let Some(v) = self.autoUpdateCleanupDialogNumTimesShown {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.networkType {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.networkSubType {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numAccountsOnDevice {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numInstalledApps {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numAutoUpdatingInstalledApps {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numInstalledAppsNotAutoUpdating {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gaiaPasswordAuthOptedOut {
            my_size += 2;
        }
        if let Some(v) = self.contentFilterLevel {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.allowUnknownSources {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.globalAutoUpdateEnabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.globalAutoUpdateOverWifiOnly {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.autoUpdateCleanupDialogNumTimesShown {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.networkType {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.networkSubType {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.numAccountsOnDevice {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.numInstalledApps {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.numAutoUpdatingInstalledApps {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.numInstalledAppsNotAutoUpdating {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.gaiaPasswordAuthOptedOut {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.contentFilterLevel {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.allowUnknownSources {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreSessionData {
        PlayStoreSessionData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "globalAutoUpdateEnabled",
                |m: &PlayStoreSessionData| { &m.globalAutoUpdateEnabled },
                |m: &mut PlayStoreSessionData| { &mut m.globalAutoUpdateEnabled },
                PlayStoreSessionData::get_globalAutoUpdateEnabled,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "globalAutoUpdateOverWifiOnly",
                |m: &PlayStoreSessionData| { &m.globalAutoUpdateOverWifiOnly },
                |m: &mut PlayStoreSessionData| { &mut m.globalAutoUpdateOverWifiOnly },
                PlayStoreSessionData::get_globalAutoUpdateOverWifiOnly,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "autoUpdateCleanupDialogNumTimesShown",
                |m: &PlayStoreSessionData| { &m.autoUpdateCleanupDialogNumTimesShown },
                |m: &mut PlayStoreSessionData| { &mut m.autoUpdateCleanupDialogNumTimesShown },
                PlayStoreSessionData::get_autoUpdateCleanupDialogNumTimesShown,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "networkType",
                |m: &PlayStoreSessionData| { &m.networkType },
                |m: &mut PlayStoreSessionData| { &mut m.networkType },
                PlayStoreSessionData::get_networkType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "networkSubType",
                |m: &PlayStoreSessionData| { &m.networkSubType },
                |m: &mut PlayStoreSessionData| { &mut m.networkSubType },
                PlayStoreSessionData::get_networkSubType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "numAccountsOnDevice",
                |m: &PlayStoreSessionData| { &m.numAccountsOnDevice },
                |m: &mut PlayStoreSessionData| { &mut m.numAccountsOnDevice },
                PlayStoreSessionData::get_numAccountsOnDevice,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "numInstalledApps",
                |m: &PlayStoreSessionData| { &m.numInstalledApps },
                |m: &mut PlayStoreSessionData| { &mut m.numInstalledApps },
                PlayStoreSessionData::get_numInstalledApps,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "numAutoUpdatingInstalledApps",
                |m: &PlayStoreSessionData| { &m.numAutoUpdatingInstalledApps },
                |m: &mut PlayStoreSessionData| { &mut m.numAutoUpdatingInstalledApps },
                PlayStoreSessionData::get_numAutoUpdatingInstalledApps,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "numInstalledAppsNotAutoUpdating",
                |m: &PlayStoreSessionData| { &m.numInstalledAppsNotAutoUpdating },
                |m: &mut PlayStoreSessionData| { &mut m.numInstalledAppsNotAutoUpdating },
                PlayStoreSessionData::get_numInstalledAppsNotAutoUpdating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "gaiaPasswordAuthOptedOut",
                |m: &PlayStoreSessionData| { &m.gaiaPasswordAuthOptedOut },
                |m: &mut PlayStoreSessionData| { &mut m.gaiaPasswordAuthOptedOut },
                PlayStoreSessionData::get_gaiaPasswordAuthOptedOut,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "contentFilterLevel",
                |m: &PlayStoreSessionData| { &m.contentFilterLevel },
                |m: &mut PlayStoreSessionData| { &mut m.contentFilterLevel },
                PlayStoreSessionData::get_contentFilterLevel,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "allowUnknownSources",
                |m: &PlayStoreSessionData| { &m.allowUnknownSources },
                |m: &mut PlayStoreSessionData| { &mut m.allowUnknownSources },
                PlayStoreSessionData::get_allowUnknownSources,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreSessionData>(
                "PlayStoreSessionData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreSessionData {
        static instance: ::protobuf::rt::Lazy<PlayStoreSessionData> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreSessionData::new)
    }
}

impl ::protobuf::Clear for PlayStoreSessionData {
    fn clear(&mut self) {
        self.globalAutoUpdateEnabled = ::std::option::Option::None;
        self.globalAutoUpdateOverWifiOnly = ::std::option::Option::None;
        self.autoUpdateCleanupDialogNumTimesShown = ::std::option::Option::None;
        self.networkType = ::std::option::Option::None;
        self.networkSubType = ::std::option::Option::None;
        self.numAccountsOnDevice = ::std::option::Option::None;
        self.numInstalledApps = ::std::option::Option::None;
        self.numAutoUpdatingInstalledApps = ::std::option::Option::None;
        self.numInstalledAppsNotAutoUpdating = ::std::option::Option::None;
        self.gaiaPasswordAuthOptedOut = ::std::option::Option::None;
        self.contentFilterLevel = ::std::option::Option::None;
        self.allowUnknownSources = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreSessionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreSessionData {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreUiElement {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub clientLogsCookie: ::protobuf::SingularPtrField<PlayStoreUiElementInfo>,
    pub child: ::protobuf::RepeatedField<PlayStoreUiElement>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreUiElement {
    pub fn new() -> PlayStoreUiElement {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional bytes serverLogsCookie = 2;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for PlayStoreUiElement {
    fn is_initialized(&self) -> bool {
        for v in &self.clientLogsCookie {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreUiElementInfo, _>(wire_type, is, &mut self.clientLogsCookie)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.child)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.clientLogsCookie.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.clientLogsCookie.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.child {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreUiElement {
        PlayStoreUiElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &PlayStoreUiElement| { &m.field_type },
                |m: &mut PlayStoreUiElement| { &mut m.field_type },
                PlayStoreUiElement::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &PlayStoreUiElement| { &m.serverLogsCookie },
                |m: &mut PlayStoreUiElement| { &mut m.serverLogsCookie },
                PlayStoreUiElement::get_serverLogsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElementInfo>, _>(
                "clientLogsCookie",
                |m: &PlayStoreUiElement| { &m.clientLogsCookie },
                |m: &mut PlayStoreUiElement| { &mut m.clientLogsCookie },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElement>>(
                "child",
                |m: &PlayStoreUiElement| { &m.child },
                |m: &mut PlayStoreUiElement| { &mut m.child },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreUiElement>(
                "PlayStoreUiElement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreUiElement {
        static instance: ::protobuf::rt::Lazy<PlayStoreUiElement> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreUiElement::new)
    }
}

impl ::protobuf::Clear for PlayStoreUiElement {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.serverLogsCookie.clear();
        self.clientLogsCookie.clear();
        self.child.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreUiElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreUiElement {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreUiElementInfo {
    // message fields
    pub instrumentInfo: ::protobuf::SingularPtrField<PlayStoreUiElementInfo_InstrumentInfo>,
    pub serialDocid: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreUiElementInfo {
    pub fn new() -> PlayStoreUiElementInfo {
        ::std::default::Default::default()
    }

    // optional string serialDocid = 2;

    pub fn get_serialDocid(&self) -> &str {
        match self.serialDocid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PlayStoreUiElementInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.instrumentInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<PlayStoreUiElementInfo_InstrumentInfo, _>(wire_type, is, &mut self.instrumentInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serialDocid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.serialDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.serialDocid.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreUiElementInfo {
        PlayStoreUiElementInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElementInfo_InstrumentInfo>, _>(
                "instrumentInfo",
                |m: &PlayStoreUiElementInfo| { &m.instrumentInfo },
                |m: &mut PlayStoreUiElementInfo| { &mut m.instrumentInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "serialDocid",
                |m: &PlayStoreUiElementInfo| { &m.serialDocid },
                |m: &mut PlayStoreUiElementInfo| { &mut m.serialDocid },
                PlayStoreUiElementInfo::get_serialDocid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreUiElementInfo>(
                "PlayStoreUiElementInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreUiElementInfo {
        static instance: ::protobuf::rt::Lazy<PlayStoreUiElementInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreUiElementInfo::new)
    }
}

impl ::protobuf::Clear for PlayStoreUiElementInfo {
    fn clear(&mut self) {
        self.instrumentInfo.clear();
        self.serialDocid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreUiElementInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreUiElementInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlayStoreUiElementInfo_InstrumentInfo {
    // message fields
    pub instrumentFamily: ::std::option::Option<i32>,
    pub isDefault: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlayStoreUiElementInfo_InstrumentInfo {
    pub fn new() -> PlayStoreUiElementInfo_InstrumentInfo {
        ::std::default::Default::default()
    }

    // optional int32 instrumentFamily = 1;

    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }

    // optional bool isDefault = 2;

    pub fn get_isDefault(&self) -> bool {
        self.isDefault.unwrap_or(false)
    }
}

impl ::protobuf::Message for PlayStoreUiElementInfo_InstrumentInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isDefault = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isDefault {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentFamily {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.isDefault {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreUiElementInfo_InstrumentInfo {
        PlayStoreUiElementInfo_InstrumentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "instrumentFamily",
                |m: &PlayStoreUiElementInfo_InstrumentInfo| { &m.instrumentFamily },
                |m: &mut PlayStoreUiElementInfo_InstrumentInfo| { &mut m.instrumentFamily },
                PlayStoreUiElementInfo_InstrumentInfo::get_instrumentFamily,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "isDefault",
                |m: &PlayStoreUiElementInfo_InstrumentInfo| { &m.isDefault },
                |m: &mut PlayStoreUiElementInfo_InstrumentInfo| { &mut m.isDefault },
                PlayStoreUiElementInfo_InstrumentInfo::get_isDefault,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlayStoreUiElementInfo_InstrumentInfo>(
                "PlayStoreUiElementInfo_InstrumentInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreUiElementInfo_InstrumentInfo {
        static instance: ::protobuf::rt::Lazy<PlayStoreUiElementInfo_InstrumentInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlayStoreUiElementInfo_InstrumentInfo::new)
    }
}

impl ::protobuf::Clear for PlayStoreUiElementInfo_InstrumentInfo {
    fn clear(&mut self) {
        self.instrumentFamily = ::std::option::Option::None;
        self.isDefault = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreUiElementInfo_InstrumentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreUiElementInfo_InstrumentInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlusProfile {
    // message fields
    pub displayName: ::protobuf::SingularField<::std::string::String>,
    pub profileImageUrl: ::protobuf::SingularField<::std::string::String>,
    pub profileImage: ::protobuf::SingularPtrField<Image>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlusProfile {
    pub fn new() -> PlusProfile {
        ::std::default::Default::default()
    }

    // optional string displayName = 2;

    pub fn get_displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string profileImageUrl = 4;

    pub fn get_profileImageUrl(&self) -> &str {
        match self.profileImageUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PlusProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.profileImage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.profileImageUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<Image, _>(wire_type, is, &mut self.profileImage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.profileImageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.profileImage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.profileImageUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.profileImage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusProfile {
        PlusProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "displayName",
                |m: &PlusProfile| { &m.displayName },
                |m: &mut PlusProfile| { &mut m.displayName },
                PlusProfile::get_displayName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "profileImageUrl",
                |m: &PlusProfile| { &m.profileImageUrl },
                |m: &mut PlusProfile| { &mut m.profileImageUrl },
                PlusProfile::get_profileImageUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>, _>(
                "profileImage",
                |m: &PlusProfile| { &m.profileImage },
                |m: &mut PlusProfile| { &mut m.profileImage },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlusProfile>(
                "PlusProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusProfile {
        static instance: ::protobuf::rt::Lazy<PlusProfile> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlusProfile::new)
    }
}

impl ::protobuf::Clear for PlusProfile {
    fn clear(&mut self) {
        self.displayName.clear();
        self.profileImageUrl.clear();
        self.profileImage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusProfile {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlusOneResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlusOneResponse {
    pub fn new() -> PlusOneResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PlusOneResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusOneResponse {
        PlusOneResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<PlusOneResponse>(
                "PlusOneResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusOneResponse {
        static instance: ::protobuf::rt::Lazy<PlusOneResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlusOneResponse::new)
    }
}

impl ::protobuf::Clear for PlusOneResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusOneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusOneResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PlusProfileResponse {
    // message fields
    pub plusProfile: ::protobuf::SingularPtrField<PlusProfile>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PlusProfileResponse {
    pub fn new() -> PlusProfileResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PlusProfileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.plusProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<PlusProfile, _>(wire_type, is, &mut self.plusProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.plusProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.plusProfile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusProfileResponse {
        PlusProfileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfile>, _>(
                "plusProfile",
                |m: &PlusProfileResponse| { &m.plusProfile },
                |m: &mut PlusProfileResponse| { &mut m.plusProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PlusProfileResponse>(
                "PlusProfileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusProfileResponse {
        static instance: ::protobuf::rt::Lazy<PlusProfileResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(PlusProfileResponse::new)
    }
}

impl ::protobuf::Clear for PlusProfileResponse {
    fn clear(&mut self) {
        self.plusProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusProfileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusProfileResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ClientCart {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub formattedPrice: ::protobuf::SingularField<::std::string::String>,
    pub purchaseContextToken: ::protobuf::SingularField<::std::string::String>,
    pub instrument: ::protobuf::SingularPtrField<Instrument>,
    pub extendedDetailHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub footerHtml: ::protobuf::SingularField<::std::string::String>,
    pub addInstrumentPromptHtml: ::protobuf::SingularField<::std::string::String>,
    pub buttonText: ::protobuf::SingularField<::std::string::String>,
    pub completePurchaseChallenge: ::protobuf::SingularPtrField<Challenge>,
    pub priceByline: ::protobuf::SingularField<::std::string::String>,
    pub detailHtml: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ClientCart {
    pub fn new() -> ClientCart {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string formattedPrice = 2;

    pub fn get_formattedPrice(&self) -> &str {
        match self.formattedPrice.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string purchaseContextToken = 3;

    pub fn get_purchaseContextToken(&self) -> &str {
        match self.purchaseContextToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string footerHtml = 6;

    pub fn get_footerHtml(&self) -> &str {
        match self.footerHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string addInstrumentPromptHtml = 7;

    pub fn get_addInstrumentPromptHtml(&self) -> &str {
        match self.addInstrumentPromptHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string buttonText = 8;

    pub fn get_buttonText(&self) -> &str {
        match self.buttonText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string priceByline = 10;

    pub fn get_priceByline(&self) -> &str {
        match self.priceByline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClientCart {
    fn is_initialized(&self) -> bool {
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.completePurchaseChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedPrice)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseContextToken)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<Instrument, _>(wire_type, is, &mut self.instrument)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.extendedDetailHtml)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addInstrumentPromptHtml)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.buttonText)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<Challenge, _>(wire_type, is, &mut self.completePurchaseChallenge)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.priceByline)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.detailHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.formattedPrice.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.purchaseContextToken.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.instrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extendedDetailHtml {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.footerHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.addInstrumentPromptHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.buttonText.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.completePurchaseChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.priceByline.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.detailHtml {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.formattedPrice.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.purchaseContextToken.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.instrument.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.extendedDetailHtml {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.footerHtml.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.addInstrumentPromptHtml.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.buttonText.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.completePurchaseChallenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.priceByline.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.detailHtml {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientCart {
        ClientCart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &ClientCart| { &m.title },
                |m: &mut ClientCart| { &mut m.title },
                ClientCart::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "formattedPrice",
                |m: &ClientCart| { &m.formattedPrice },
                |m: &mut ClientCart| { &mut m.formattedPrice },
                ClientCart::get_formattedPrice,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "purchaseContextToken",
                |m: &ClientCart| { &m.purchaseContextToken },
                |m: &mut ClientCart| { &mut m.purchaseContextToken },
                ClientCart::get_purchaseContextToken,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>, _>(
                "instrument",
                |m: &ClientCart| { &m.instrument },
                |m: &mut ClientCart| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extendedDetailHtml",
                |m: &ClientCart| { &m.extendedDetailHtml },
                |m: &mut ClientCart| { &mut m.extendedDetailHtml },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "footerHtml",
                |m: &ClientCart| { &m.footerHtml },
                |m: &mut ClientCart| { &mut m.footerHtml },
                ClientCart::get_footerHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "addInstrumentPromptHtml",
                |m: &ClientCart| { &m.addInstrumentPromptHtml },
                |m: &mut ClientCart| { &mut m.addInstrumentPromptHtml },
                ClientCart::get_addInstrumentPromptHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "buttonText",
                |m: &ClientCart| { &m.buttonText },
                |m: &mut ClientCart| { &mut m.buttonText },
                ClientCart::get_buttonText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>, _>(
                "completePurchaseChallenge",
                |m: &ClientCart| { &m.completePurchaseChallenge },
                |m: &mut ClientCart| { &mut m.completePurchaseChallenge },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "priceByline",
                |m: &ClientCart| { &m.priceByline },
                |m: &mut ClientCart| { &mut m.priceByline },
                ClientCart::get_priceByline,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailHtml",
                |m: &ClientCart| { &m.detailHtml },
                |m: &mut ClientCart| { &mut m.detailHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ClientCart>(
                "ClientCart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientCart {
        static instance: ::protobuf::rt::Lazy<ClientCart> = ::protobuf::rt::Lazy::INIT;
        instance.get(ClientCart::new)
    }
}

impl ::protobuf::Clear for ClientCart {
    fn clear(&mut self) {
        self.title.clear();
        self.formattedPrice.clear();
        self.purchaseContextToken.clear();
        self.instrument.clear();
        self.extendedDetailHtml.clear();
        self.footerHtml.clear();
        self.addInstrumentPromptHtml.clear();
        self.buttonText.clear();
        self.completePurchaseChallenge.clear();
        self.priceByline.clear();
        self.detailHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientCart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientCart {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CommitPurchaseResponse {
    // message fields
    pub purchaseStatus: ::protobuf::SingularPtrField<PurchaseStatus>,
    pub challenge: ::protobuf::SingularPtrField<Challenge>,
    pub libraryUpdate: ::protobuf::RepeatedField<LibraryUpdate>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CommitPurchaseResponse {
    pub fn new() -> CommitPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional bytes serverLogsCookie = 5;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CommitPurchaseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseStatus, _>(wire_type, is, &mut self.purchaseStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Challenge, _>(wire_type, is, &mut self.challenge)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.libraryUpdate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<AndroidAppDeliveryData, _>(wire_type, is, &mut self.appDeliveryData)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.purchaseStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.libraryUpdate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.purchaseStatus.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.libraryUpdate {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.appDeliveryData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitPurchaseResponse {
        CommitPurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatus>, _>(
                "purchaseStatus",
                |m: &CommitPurchaseResponse| { &m.purchaseStatus },
                |m: &mut CommitPurchaseResponse| { &mut m.purchaseStatus },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>, _>(
                "challenge",
                |m: &CommitPurchaseResponse| { &m.challenge },
                |m: &mut CommitPurchaseResponse| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &CommitPurchaseResponse| { &m.libraryUpdate },
                |m: &mut CommitPurchaseResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>, _>(
                "appDeliveryData",
                |m: &CommitPurchaseResponse| { &m.appDeliveryData },
                |m: &mut CommitPurchaseResponse| { &mut m.appDeliveryData },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &CommitPurchaseResponse| { &m.serverLogsCookie },
                |m: &mut CommitPurchaseResponse| { &mut m.serverLogsCookie },
                CommitPurchaseResponse::get_serverLogsCookie,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CommitPurchaseResponse>(
                "CommitPurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitPurchaseResponse {
        static instance: ::protobuf::rt::Lazy<CommitPurchaseResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CommitPurchaseResponse::new)
    }
}

impl ::protobuf::Clear for CommitPurchaseResponse {
    fn clear(&mut self) {
        self.purchaseStatus.clear();
        self.challenge.clear();
        self.libraryUpdate.clear();
        self.appDeliveryData.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitPurchaseResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PreparePurchaseResponse {
    // message fields
    pub purchaseStatus: ::protobuf::SingularPtrField<PurchaseStatus>,
    pub challenge: ::protobuf::SingularPtrField<Challenge>,
    pub cart: ::protobuf::SingularPtrField<ClientCart>,
    pub libraryUpdate: ::protobuf::RepeatedField<LibraryUpdate>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PreparePurchaseResponse {
    pub fn new() -> PreparePurchaseResponse {
        ::std::default::Default::default()
    }

    // optional bytes serverLogsCookie = 5;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for PreparePurchaseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseStatus, _>(wire_type, is, &mut self.purchaseStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Challenge, _>(wire_type, is, &mut self.challenge)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<ClientCart, _>(wire_type, is, &mut self.cart)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.libraryUpdate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.purchaseStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.libraryUpdate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.purchaseStatus.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.cart.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.libraryUpdate {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreparePurchaseResponse {
        PreparePurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatus>, _>(
                "purchaseStatus",
                |m: &PreparePurchaseResponse| { &m.purchaseStatus },
                |m: &mut PreparePurchaseResponse| { &mut m.purchaseStatus },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>, _>(
                "challenge",
                |m: &PreparePurchaseResponse| { &m.challenge },
                |m: &mut PreparePurchaseResponse| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientCart>, _>(
                "cart",
                |m: &PreparePurchaseResponse| { &m.cart },
                |m: &mut PreparePurchaseResponse| { &mut m.cart },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &PreparePurchaseResponse| { &m.libraryUpdate },
                |m: &mut PreparePurchaseResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &PreparePurchaseResponse| { &m.serverLogsCookie },
                |m: &mut PreparePurchaseResponse| { &mut m.serverLogsCookie },
                PreparePurchaseResponse::get_serverLogsCookie,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PreparePurchaseResponse>(
                "PreparePurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreparePurchaseResponse {
        static instance: ::protobuf::rt::Lazy<PreparePurchaseResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(PreparePurchaseResponse::new)
    }
}

impl ::protobuf::Clear for PreparePurchaseResponse {
    fn clear(&mut self) {
        self.purchaseStatus.clear();
        self.challenge.clear();
        self.cart.clear();
        self.libraryUpdate.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreparePurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreparePurchaseResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseStatus {
    // message fields
    pub statusCode: ::std::option::Option<i32>,
    pub errorMessageHtml: ::protobuf::SingularField<::std::string::String>,
    pub permissionError: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseStatus {
    pub fn new() -> PurchaseStatus {
        ::std::default::Default::default()
    }

    // optional int32 statusCode = 1;

    pub fn get_statusCode(&self) -> i32 {
        self.statusCode.unwrap_or(0)
    }

    // optional string errorMessageHtml = 2;

    pub fn get_errorMessageHtml(&self) -> &str {
        match self.errorMessageHtml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 permissionError = 3;

    pub fn get_permissionError(&self) -> i32 {
        self.permissionError.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.statusCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessageHtml)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permissionError = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.statusCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.errorMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.permissionError {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.statusCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.errorMessageHtml.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.permissionError {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseStatus {
        PurchaseStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "statusCode",
                |m: &PurchaseStatus| { &m.statusCode },
                |m: &mut PurchaseStatus| { &mut m.statusCode },
                PurchaseStatus::get_statusCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "errorMessageHtml",
                |m: &PurchaseStatus| { &m.errorMessageHtml },
                |m: &mut PurchaseStatus| { &mut m.errorMessageHtml },
                PurchaseStatus::get_errorMessageHtml,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "permissionError",
                |m: &PurchaseStatus| { &m.permissionError },
                |m: &mut PurchaseStatus| { &mut m.permissionError },
                PurchaseStatus::get_permissionError,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseStatus>(
                "PurchaseStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseStatus {
        static instance: ::protobuf::rt::Lazy<PurchaseStatus> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseStatus::new)
    }
}

impl ::protobuf::Clear for PurchaseStatus {
    fn clear(&mut self) {
        self.statusCode = ::std::option::Option::None;
        self.errorMessageHtml.clear();
        self.permissionError = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseStatus {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RateSuggestedContentResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RateSuggestedContentResponse {
    pub fn new() -> RateSuggestedContentResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateSuggestedContentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateSuggestedContentResponse {
        RateSuggestedContentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<RateSuggestedContentResponse>(
                "RateSuggestedContentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateSuggestedContentResponse {
        static instance: ::protobuf::rt::Lazy<RateSuggestedContentResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(RateSuggestedContentResponse::new)
    }
}

impl ::protobuf::Clear for RateSuggestedContentResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateSuggestedContentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateSuggestedContentResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AggregateRating {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub starRating: ::std::option::Option<f32>,
    pub ratingsCount: ::std::option::Option<u64>,
    pub oneStarRatings: ::std::option::Option<u64>,
    pub twoStarRatings: ::std::option::Option<u64>,
    pub threeStarRatings: ::std::option::Option<u64>,
    pub fourStarRatings: ::std::option::Option<u64>,
    pub fiveStarRatings: ::std::option::Option<u64>,
    pub thumbsUpCount: ::std::option::Option<u64>,
    pub thumbsDownCount: ::std::option::Option<u64>,
    pub commentCount: ::std::option::Option<u64>,
    pub bayesianMeanRating: ::std::option::Option<f64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AggregateRating {
    pub fn new() -> AggregateRating {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional float starRating = 2;

    pub fn get_starRating(&self) -> f32 {
        self.starRating.unwrap_or(0.)
    }

    // optional uint64 ratingsCount = 3;

    pub fn get_ratingsCount(&self) -> u64 {
        self.ratingsCount.unwrap_or(0)
    }

    // optional uint64 oneStarRatings = 4;

    pub fn get_oneStarRatings(&self) -> u64 {
        self.oneStarRatings.unwrap_or(0)
    }

    // optional uint64 twoStarRatings = 5;

    pub fn get_twoStarRatings(&self) -> u64 {
        self.twoStarRatings.unwrap_or(0)
    }

    // optional uint64 threeStarRatings = 6;

    pub fn get_threeStarRatings(&self) -> u64 {
        self.threeStarRatings.unwrap_or(0)
    }

    // optional uint64 fourStarRatings = 7;

    pub fn get_fourStarRatings(&self) -> u64 {
        self.fourStarRatings.unwrap_or(0)
    }

    // optional uint64 fiveStarRatings = 8;

    pub fn get_fiveStarRatings(&self) -> u64 {
        self.fiveStarRatings.unwrap_or(0)
    }

    // optional uint64 thumbsUpCount = 9;

    pub fn get_thumbsUpCount(&self) -> u64 {
        self.thumbsUpCount.unwrap_or(0)
    }

    // optional uint64 thumbsDownCount = 10;

    pub fn get_thumbsDownCount(&self) -> u64 {
        self.thumbsDownCount.unwrap_or(0)
    }

    // optional uint64 commentCount = 11;

    pub fn get_commentCount(&self) -> u64 {
        self.commentCount.unwrap_or(0)
    }

    // optional double bayesianMeanRating = 12;

    pub fn get_bayesianMeanRating(&self) -> f64 {
        self.bayesianMeanRating.unwrap_or(0.)
    }
}

impl ::protobuf::Message for AggregateRating {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.starRating = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ratingsCount = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.oneStarRatings = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.twoStarRatings = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.threeStarRatings = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fourStarRatings = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fiveStarRatings = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.thumbsUpCount = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.thumbsDownCount = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commentCount = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bayesianMeanRating = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.starRating {
            my_size += 5;
        }
        if let Some(v) = self.ratingsCount {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.oneStarRatings {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twoStarRatings {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.threeStarRatings {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fourStarRatings {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fiveStarRatings {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thumbsUpCount {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thumbsDownCount {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.commentCount {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bayesianMeanRating {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.starRating {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.ratingsCount {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.oneStarRatings {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.twoStarRatings {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.threeStarRatings {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.fourStarRatings {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.fiveStarRatings {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.thumbsUpCount {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.thumbsDownCount {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.commentCount {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.bayesianMeanRating {
            os.write_double(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AggregateRating {
        AggregateRating::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "type",
                |m: &AggregateRating| { &m.field_type },
                |m: &mut AggregateRating| { &mut m.field_type },
                AggregateRating::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeFloat, _>(
                "starRating",
                |m: &AggregateRating| { &m.starRating },
                |m: &mut AggregateRating| { &mut m.starRating },
                AggregateRating::get_starRating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "ratingsCount",
                |m: &AggregateRating| { &m.ratingsCount },
                |m: &mut AggregateRating| { &mut m.ratingsCount },
                AggregateRating::get_ratingsCount,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "oneStarRatings",
                |m: &AggregateRating| { &m.oneStarRatings },
                |m: &mut AggregateRating| { &mut m.oneStarRatings },
                AggregateRating::get_oneStarRatings,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "twoStarRatings",
                |m: &AggregateRating| { &m.twoStarRatings },
                |m: &mut AggregateRating| { &mut m.twoStarRatings },
                AggregateRating::get_twoStarRatings,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "threeStarRatings",
                |m: &AggregateRating| { &m.threeStarRatings },
                |m: &mut AggregateRating| { &mut m.threeStarRatings },
                AggregateRating::get_threeStarRatings,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "fourStarRatings",
                |m: &AggregateRating| { &m.fourStarRatings },
                |m: &mut AggregateRating| { &mut m.fourStarRatings },
                AggregateRating::get_fourStarRatings,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "fiveStarRatings",
                |m: &AggregateRating| { &m.fiveStarRatings },
                |m: &mut AggregateRating| { &mut m.fiveStarRatings },
                AggregateRating::get_fiveStarRatings,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "thumbsUpCount",
                |m: &AggregateRating| { &m.thumbsUpCount },
                |m: &mut AggregateRating| { &mut m.thumbsUpCount },
                AggregateRating::get_thumbsUpCount,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "thumbsDownCount",
                |m: &AggregateRating| { &m.thumbsDownCount },
                |m: &mut AggregateRating| { &mut m.thumbsDownCount },
                AggregateRating::get_thumbsDownCount,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "commentCount",
                |m: &AggregateRating| { &m.commentCount },
                |m: &mut AggregateRating| { &mut m.commentCount },
                AggregateRating::get_commentCount,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeDouble, _>(
                "bayesianMeanRating",
                |m: &AggregateRating| { &m.bayesianMeanRating },
                |m: &mut AggregateRating| { &mut m.bayesianMeanRating },
                AggregateRating::get_bayesianMeanRating,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AggregateRating>(
                "AggregateRating",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AggregateRating {
        static instance: ::protobuf::rt::Lazy<AggregateRating> = ::protobuf::rt::Lazy::INIT;
        instance.get(AggregateRating::new)
    }
}

impl ::protobuf::Clear for AggregateRating {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.starRating = ::std::option::Option::None;
        self.ratingsCount = ::std::option::Option::None;
        self.oneStarRatings = ::std::option::Option::None;
        self.twoStarRatings = ::std::option::Option::None;
        self.threeStarRatings = ::std::option::Option::None;
        self.fourStarRatings = ::std::option::Option::None;
        self.fiveStarRatings = ::std::option::Option::None;
        self.thumbsUpCount = ::std::option::Option::None;
        self.thumbsDownCount = ::std::option::Option::None;
        self.commentCount = ::std::option::Option::None;
        self.bayesianMeanRating = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AggregateRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregateRating {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DirectPurchase {
    // message fields
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub purchaseDocid: ::protobuf::SingularField<::std::string::String>,
    pub parentDocid: ::protobuf::SingularField<::std::string::String>,
    pub offerType: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DirectPurchase {
    pub fn new() -> DirectPurchase {
        ::std::default::Default::default()
    }

    // optional string detailsUrl = 1;

    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string purchaseDocid = 2;

    pub fn get_purchaseDocid(&self) -> &str {
        match self.purchaseDocid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string parentDocid = 3;

    pub fn get_parentDocid(&self) -> &str {
        match self.parentDocid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 offerType = 4;

    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }
}

impl ::protobuf::Message for DirectPurchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseDocid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDocid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.purchaseDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.parentDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.detailsUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.purchaseDocid.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.parentDocid.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectPurchase {
        DirectPurchase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "detailsUrl",
                |m: &DirectPurchase| { &m.detailsUrl },
                |m: &mut DirectPurchase| { &mut m.detailsUrl },
                DirectPurchase::get_detailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "purchaseDocid",
                |m: &DirectPurchase| { &m.purchaseDocid },
                |m: &mut DirectPurchase| { &mut m.purchaseDocid },
                DirectPurchase::get_purchaseDocid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "parentDocid",
                |m: &DirectPurchase| { &m.parentDocid },
                |m: &mut DirectPurchase| { &mut m.parentDocid },
                DirectPurchase::get_parentDocid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "offerType",
                |m: &DirectPurchase| { &m.offerType },
                |m: &mut DirectPurchase| { &mut m.offerType },
                DirectPurchase::get_offerType,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DirectPurchase>(
                "DirectPurchase",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectPurchase {
        static instance: ::protobuf::rt::Lazy<DirectPurchase> = ::protobuf::rt::Lazy::INIT;
        instance.get(DirectPurchase::new)
    }
}

impl ::protobuf::Clear for DirectPurchase {
    fn clear(&mut self) {
        self.detailsUrl.clear();
        self.purchaseDocid.clear();
        self.parentDocid.clear();
        self.offerType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectPurchase {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RedeemGiftCard {
    // message fields
    pub prefillCode: ::protobuf::SingularField<::std::string::String>,
    pub partnerPayload: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RedeemGiftCard {
    pub fn new() -> RedeemGiftCard {
        ::std::default::Default::default()
    }

    // optional string prefillCode = 1;

    pub fn get_prefillCode(&self) -> &str {
        match self.prefillCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string partnerPayload = 2;

    pub fn get_partnerPayload(&self) -> &str {
        match self.partnerPayload.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RedeemGiftCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prefillCode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.partnerPayload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prefillCode.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.partnerPayload.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prefillCode.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.partnerPayload.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemGiftCard {
        RedeemGiftCard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "prefillCode",
                |m: &RedeemGiftCard| { &m.prefillCode },
                |m: &mut RedeemGiftCard| { &mut m.prefillCode },
                RedeemGiftCard::get_prefillCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "partnerPayload",
                |m: &RedeemGiftCard| { &m.partnerPayload },
                |m: &mut RedeemGiftCard| { &mut m.partnerPayload },
                RedeemGiftCard::get_partnerPayload,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RedeemGiftCard>(
                "RedeemGiftCard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemGiftCard {
        static instance: ::protobuf::rt::Lazy<RedeemGiftCard> = ::protobuf::rt::Lazy::INIT;
        instance.get(RedeemGiftCard::new)
    }
}

impl ::protobuf::Clear for RedeemGiftCard {
    fn clear(&mut self) {
        self.prefillCode.clear();
        self.partnerPayload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemGiftCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemGiftCard {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ResolvedLink {
    // message fields
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub searchUrl: ::protobuf::SingularField<::std::string::String>,
    pub directPurchase: ::protobuf::SingularPtrField<DirectPurchase>,
    pub homeUrl: ::protobuf::SingularField<::std::string::String>,
    pub redeemGiftCard: ::protobuf::SingularPtrField<RedeemGiftCard>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub wishlistUrl: ::protobuf::SingularField<::std::string::String>,
    pub backend: ::std::option::Option<i32>,
    pub query: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ResolvedLink {
    pub fn new() -> ResolvedLink {
        ::std::default::Default::default()
    }

    // optional string detailsUrl = 1;

    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string browseUrl = 2;

    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string searchUrl = 3;

    pub fn get_searchUrl(&self) -> &str {
        match self.searchUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string homeUrl = 5;

    pub fn get_homeUrl(&self) -> &str {
        match self.homeUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 7;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional string wishlistUrl = 9;

    pub fn get_wishlistUrl(&self) -> &str {
        match self.wishlistUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 backend = 10;

    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }

    // optional string query = 11;

    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ResolvedLink {
    fn is_initialized(&self) -> bool {
        for v in &self.directPurchase {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemGiftCard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.searchUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<DirectPurchase, _>(wire_type, is, &mut self.directPurchase)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.homeUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<RedeemGiftCard, _>(wire_type, is, &mut self.redeemGiftCard)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<Docid, _>(wire_type, is, &mut self.docid)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.wishlistUrl)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.searchUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.directPurchase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.homeUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.redeemGiftCard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.wishlistUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.detailsUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.browseUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.searchUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.directPurchase.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.homeUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.redeemGiftCard.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.docid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.wishlistUrl.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.backend {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.query.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResolvedLink {
        ResolvedLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "detailsUrl",
                |m: &ResolvedLink| { &m.detailsUrl },
                |m: &mut ResolvedLink| { &mut m.detailsUrl },
                ResolvedLink::get_detailsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "browseUrl",
                |m: &ResolvedLink| { &m.browseUrl },
                |m: &mut ResolvedLink| { &mut m.browseUrl },
                ResolvedLink::get_browseUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "searchUrl",
                |m: &ResolvedLink| { &m.searchUrl },
                |m: &mut ResolvedLink| { &mut m.searchUrl },
                ResolvedLink::get_searchUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirectPurchase>, _>(
                "directPurchase",
                |m: &ResolvedLink| { &m.directPurchase },
                |m: &mut ResolvedLink| { &mut m.directPurchase },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "homeUrl",
                |m: &ResolvedLink| { &m.homeUrl },
                |m: &mut ResolvedLink| { &mut m.homeUrl },
                ResolvedLink::get_homeUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemGiftCard>, _>(
                "redeemGiftCard",
                |m: &ResolvedLink| { &m.redeemGiftCard },
                |m: &mut ResolvedLink| { &mut m.redeemGiftCard },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &ResolvedLink| { &m.serverLogsCookie },
                |m: &mut ResolvedLink| { &mut m.serverLogsCookie },
                ResolvedLink::get_serverLogsCookie,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>, _>(
                "docid",
                |m: &ResolvedLink| { &m.docid },
                |m: &mut ResolvedLink| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "wishlistUrl",
                |m: &ResolvedLink| { &m.wishlistUrl },
                |m: &mut ResolvedLink| { &mut m.wishlistUrl },
                ResolvedLink::get_wishlistUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "backend",
                |m: &ResolvedLink| { &m.backend },
                |m: &mut ResolvedLink| { &mut m.backend },
                ResolvedLink::get_backend,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "query",
                |m: &ResolvedLink| { &m.query },
                |m: &mut ResolvedLink| { &mut m.query },
                ResolvedLink::get_query,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ResolvedLink>(
                "ResolvedLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResolvedLink {
        static instance: ::protobuf::rt::Lazy<ResolvedLink> = ::protobuf::rt::Lazy::INIT;
        instance.get(ResolvedLink::new)
    }
}

impl ::protobuf::Clear for ResolvedLink {
    fn clear(&mut self) {
        self.detailsUrl.clear();
        self.browseUrl.clear();
        self.searchUrl.clear();
        self.directPurchase.clear();
        self.homeUrl.clear();
        self.redeemGiftCard.clear();
        self.serverLogsCookie.clear();
        self.docid.clear();
        self.wishlistUrl.clear();
        self.backend = ::std::option::Option::None;
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResolvedLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolvedLink {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Payload {
    // message fields
    pub listResponse: ::protobuf::SingularPtrField<ListResponse>,
    pub detailsResponse: ::protobuf::SingularPtrField<DetailsResponse>,
    pub reviewResponse: ::protobuf::SingularPtrField<ReviewResponse>,
    pub buyResponse: ::protobuf::SingularPtrField<BuyResponse>,
    pub searchResponse: ::protobuf::SingularPtrField<SearchResponse>,
    pub tocResponse: ::protobuf::SingularPtrField<TocResponse>,
    pub browseResponse: ::protobuf::SingularPtrField<BrowseResponse>,
    pub purchaseStatusResponse: ::protobuf::SingularPtrField<PurchaseStatusResponse>,
    pub updateInstrumentResponse: ::protobuf::SingularPtrField<UpdateInstrumentResponse>,
    pub logResponse: ::protobuf::SingularPtrField<LogResponse>,
    pub checkInstrumentResponse: ::protobuf::SingularPtrField<CheckInstrumentResponse>,
    pub plusOneResponse: ::protobuf::SingularPtrField<PlusOneResponse>,
    pub flagContentResponse: ::protobuf::SingularPtrField<FlagContentResponse>,
    pub ackNotificationResponse: ::protobuf::SingularPtrField<AckNotificationResponse>,
    pub initiateAssociationResponse: ::protobuf::SingularPtrField<InitiateAssociationResponse>,
    pub verifyAssociationResponse: ::protobuf::SingularPtrField<VerifyAssociationResponse>,
    pub libraryReplicationResponse: ::protobuf::SingularPtrField<LibraryReplicationResponse>,
    pub revokeResponse: ::protobuf::SingularPtrField<RevokeResponse>,
    pub bulkDetailsResponse: ::protobuf::SingularPtrField<BulkDetailsResponse>,
    pub resolveLinkResponse: ::protobuf::SingularPtrField<ResolvedLink>,
    pub deliveryResponse: ::protobuf::SingularPtrField<DeliveryResponse>,
    pub acceptTosResponse: ::protobuf::SingularPtrField<AcceptTosResponse>,
    pub rateSuggestedContentResponse: ::protobuf::SingularPtrField<RateSuggestedContentResponse>,
    pub checkPromoOfferResponse: ::protobuf::SingularPtrField<CheckPromoOfferResponse>,
    pub instrumentSetupInfoResponse: ::protobuf::SingularPtrField<InstrumentSetupInfoResponse>,
    pub redeemGiftCardResponse: ::protobuf::SingularPtrField<RedeemGiftCardResponse>,
    pub modifyLibraryResponse: ::protobuf::SingularPtrField<ModifyLibraryResponse>,
    pub uploadDeviceConfigResponse: ::protobuf::SingularPtrField<UploadDeviceConfigResponse>,
    pub plusProfileResponse: ::protobuf::SingularPtrField<PlusProfileResponse>,
    pub consumePurchaseResponse: ::protobuf::SingularPtrField<ConsumePurchaseResponse>,
    pub billingProfileResponse: ::protobuf::SingularPtrField<BillingProfileResponse>,
    pub preparePurchaseResponse: ::protobuf::SingularPtrField<PreparePurchaseResponse>,
    pub commitPurchaseResponse: ::protobuf::SingularPtrField<CommitPurchaseResponse>,
    pub debugSettingsResponse: ::protobuf::SingularPtrField<DebugSettingsResponse>,
    pub checkIabPromoResponse: ::protobuf::SingularPtrField<CheckIabPromoResponse>,
    pub userActivitySettingsResponse: ::protobuf::SingularPtrField<UserActivitySettingsResponse>,
    pub recordUserActivityResponse: ::protobuf::SingularPtrField<RecordUserActivityResponse>,
    pub redeemCodeResponse: ::protobuf::SingularPtrField<RedeemCodeResponse>,
    pub selfUpdateResponse: ::protobuf::SingularPtrField<SelfUpdateResponse>,
    pub searchSuggestResponse: ::protobuf::SingularPtrField<searchSuggestResponse>,
    pub getInitialInstrumentFlowStateResponse: ::protobuf::SingularPtrField<GetInitialInstrumentFlowStateResponse>,
    pub createInstrumentResponse: ::protobuf::SingularPtrField<CreateInstrumentResponse>,
    pub challengeResponse: ::protobuf::SingularPtrField<ChallengeResponse>,
    pub backupDeviceChoicesResponse: ::protobuf::SingularPtrField<BackDeviceChoicesResponse>,
    pub backupDocumentChoicesResponse: ::protobuf::SingularPtrField<BackupDocumentChoicesResponse>,
    pub earlyUpdateResponse: ::protobuf::SingularPtrField<EarlyUpdateResponse>,
    pub preloadsResponse: ::protobuf::SingularPtrField<PreloadsResponse>,
    pub myAccountsResponse: ::protobuf::SingularPtrField<MyAccountsResponse>,
    pub contentFilterResponse: ::protobuf::SingularPtrField<ContentFilterResponse>,
    pub experimentsResponse: ::protobuf::SingularPtrField<ExperimentsResponse>,
    pub surveyResponse: ::protobuf::SingularPtrField<SurveyResponse>,
    pub pingResponse: ::protobuf::SingularPtrField<PingResponse>,
    pub updateUserSettingResponse: ::protobuf::SingularPtrField<UpdateUserSettingResponse>,
    pub getUserSettingsREsponse: ::protobuf::SingularPtrField<GetUserSettingsResponse>,
    pub getSharingSettingsResponse: ::protobuf::SingularPtrField<GetSharingSettingsResponse>,
    pub updateSharingSettingsResponse: ::protobuf::SingularPtrField<UpdateSharingSettingsResponse>,
    pub reviewSnippetsResponse: ::protobuf::SingularPtrField<ReviewSnippetsResponse>,
    pub documentSharingStateResponse: ::protobuf::SingularPtrField<DocumentSharingStateResponse>,
    pub moduleDeliveryResponse: ::protobuf::SingularPtrField<ModuleDeliveryResponse>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Payload {
    pub fn new() -> Payload {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Payload {
    fn is_initialized(&self) -> bool {
        for v in &self.listResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.detailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reviewResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buyResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searchResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tocResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.browseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseStatusResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updateInstrumentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkInstrumentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusOneResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flagContentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initiateAssociationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.verifyAssociationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryReplicationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.revokeResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bulkDetailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resolveLinkResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deliveryResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acceptTosResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateSuggestedContentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkPromoOfferResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instrumentSetupInfoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemGiftCardResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyLibraryResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uploadDeviceConfigResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusProfileResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumePurchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingProfileResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparePurchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commitPurchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.debugSettingsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkIabPromoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userActivitySettingsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recordUserActivityResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemCodeResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selfUpdateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searchSuggestResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getInitialInstrumentFlowStateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.createInstrumentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challengeResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.backupDeviceChoicesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.backupDocumentChoicesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.earlyUpdateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preloadsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.myAccountsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentFilterResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.experimentsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.surveyResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pingResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updateUserSettingResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getUserSettingsREsponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSharingSettingsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updateSharingSettingsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reviewSnippetsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.documentSharingStateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.moduleDeliveryResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<ListResponse, _>(wire_type, is, &mut self.listResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<DetailsResponse, _>(wire_type, is, &mut self.detailsResponse)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<ReviewResponse, _>(wire_type, is, &mut self.reviewResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<BuyResponse, _>(wire_type, is, &mut self.buyResponse)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<SearchResponse, _>(wire_type, is, &mut self.searchResponse)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<TocResponse, _>(wire_type, is, &mut self.tocResponse)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<BrowseResponse, _>(wire_type, is, &mut self.browseResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseStatusResponse, _>(wire_type, is, &mut self.purchaseStatusResponse)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<UpdateInstrumentResponse, _>(wire_type, is, &mut self.updateInstrumentResponse)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<LogResponse, _>(wire_type, is, &mut self.logResponse)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<CheckInstrumentResponse, _>(wire_type, is, &mut self.checkInstrumentResponse)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<PlusOneResponse, _>(wire_type, is, &mut self.plusOneResponse)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<FlagContentResponse, _>(wire_type, is, &mut self.flagContentResponse)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into::<AckNotificationResponse, _>(wire_type, is, &mut self.ackNotificationResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into::<InitiateAssociationResponse, _>(wire_type, is, &mut self.initiateAssociationResponse)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into::<VerifyAssociationResponse, _>(wire_type, is, &mut self.verifyAssociationResponse)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryReplicationResponse, _>(wire_type, is, &mut self.libraryReplicationResponse)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into::<RevokeResponse, _>(wire_type, is, &mut self.revokeResponse)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into::<BulkDetailsResponse, _>(wire_type, is, &mut self.bulkDetailsResponse)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into::<ResolvedLink, _>(wire_type, is, &mut self.resolveLinkResponse)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into::<DeliveryResponse, _>(wire_type, is, &mut self.deliveryResponse)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into::<AcceptTosResponse, _>(wire_type, is, &mut self.acceptTosResponse)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into::<RateSuggestedContentResponse, _>(wire_type, is, &mut self.rateSuggestedContentResponse)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into::<CheckPromoOfferResponse, _>(wire_type, is, &mut self.checkPromoOfferResponse)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into::<InstrumentSetupInfoResponse, _>(wire_type, is, &mut self.instrumentSetupInfoResponse)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into::<RedeemGiftCardResponse, _>(wire_type, is, &mut self.redeemGiftCardResponse)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into::<ModifyLibraryResponse, _>(wire_type, is, &mut self.modifyLibraryResponse)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into::<UploadDeviceConfigResponse, _>(wire_type, is, &mut self.uploadDeviceConfigResponse)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into::<PlusProfileResponse, _>(wire_type, is, &mut self.plusProfileResponse)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into::<ConsumePurchaseResponse, _>(wire_type, is, &mut self.consumePurchaseResponse)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into::<BillingProfileResponse, _>(wire_type, is, &mut self.billingProfileResponse)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into::<PreparePurchaseResponse, _>(wire_type, is, &mut self.preparePurchaseResponse)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into::<CommitPurchaseResponse, _>(wire_type, is, &mut self.commitPurchaseResponse)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into::<DebugSettingsResponse, _>(wire_type, is, &mut self.debugSettingsResponse)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into::<CheckIabPromoResponse, _>(wire_type, is, &mut self.checkIabPromoResponse)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into::<UserActivitySettingsResponse, _>(wire_type, is, &mut self.userActivitySettingsResponse)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into::<RecordUserActivityResponse, _>(wire_type, is, &mut self.recordUserActivityResponse)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into::<RedeemCodeResponse, _>(wire_type, is, &mut self.redeemCodeResponse)?;
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into::<SelfUpdateResponse, _>(wire_type, is, &mut self.selfUpdateResponse)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_message_into::<searchSuggestResponse, _>(wire_type, is, &mut self.searchSuggestResponse)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into::<GetInitialInstrumentFlowStateResponse, _>(wire_type, is, &mut self.getInitialInstrumentFlowStateResponse)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into::<CreateInstrumentResponse, _>(wire_type, is, &mut self.createInstrumentResponse)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_message_into::<ChallengeResponse, _>(wire_type, is, &mut self.challengeResponse)?;
                },
                44 => {
                    ::protobuf::rt::read_singular_message_into::<BackDeviceChoicesResponse, _>(wire_type, is, &mut self.backupDeviceChoicesResponse)?;
                },
                45 => {
                    ::protobuf::rt::read_singular_message_into::<BackupDocumentChoicesResponse, _>(wire_type, is, &mut self.backupDocumentChoicesResponse)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_message_into::<EarlyUpdateResponse, _>(wire_type, is, &mut self.earlyUpdateResponse)?;
                },
                47 => {
                    ::protobuf::rt::read_singular_message_into::<PreloadsResponse, _>(wire_type, is, &mut self.preloadsResponse)?;
                },
                48 => {
                    ::protobuf::rt::read_singular_message_into::<MyAccountsResponse, _>(wire_type, is, &mut self.myAccountsResponse)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_message_into::<ContentFilterResponse, _>(wire_type, is, &mut self.contentFilterResponse)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into::<ExperimentsResponse, _>(wire_type, is, &mut self.experimentsResponse)?;
                },
                51 => {
                    ::protobuf::rt::read_singular_message_into::<SurveyResponse, _>(wire_type, is, &mut self.surveyResponse)?;
                },
                52 => {
                    ::protobuf::rt::read_singular_message_into::<PingResponse, _>(wire_type, is, &mut self.pingResponse)?;
                },
                53 => {
                    ::protobuf::rt::read_singular_message_into::<UpdateUserSettingResponse, _>(wire_type, is, &mut self.updateUserSettingResponse)?;
                },
                54 => {
                    ::protobuf::rt::read_singular_message_into::<GetUserSettingsResponse, _>(wire_type, is, &mut self.getUserSettingsREsponse)?;
                },
                56 => {
                    ::protobuf::rt::read_singular_message_into::<GetSharingSettingsResponse, _>(wire_type, is, &mut self.getSharingSettingsResponse)?;
                },
                57 => {
                    ::protobuf::rt::read_singular_message_into::<UpdateSharingSettingsResponse, _>(wire_type, is, &mut self.updateSharingSettingsResponse)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into::<ReviewSnippetsResponse, _>(wire_type, is, &mut self.reviewSnippetsResponse)?;
                },
                59 => {
                    ::protobuf::rt::read_singular_message_into::<DocumentSharingStateResponse, _>(wire_type, is, &mut self.documentSharingStateResponse)?;
                },
                70 => {
                    ::protobuf::rt::read_singular_message_into::<ModuleDeliveryResponse, _>(wire_type, is, &mut self.moduleDeliveryResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.listResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.detailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reviewResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.buyResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.searchResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tocResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.browseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseStatusResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.updateInstrumentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.logResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkInstrumentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.plusOneResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flagContentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ackNotificationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.initiateAssociationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.verifyAssociationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.libraryReplicationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.revokeResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.bulkDetailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.resolveLinkResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deliveryResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.acceptTosResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rateSuggestedContentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkPromoOfferResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.instrumentSetupInfoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.redeemGiftCardResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.modifyLibraryResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.uploadDeviceConfigResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.plusProfileResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.consumePurchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.billingProfileResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.preparePurchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.commitPurchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.debugSettingsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkIabPromoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.userActivitySettingsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.recordUserActivityResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.redeemCodeResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.selfUpdateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.searchSuggestResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getInitialInstrumentFlowStateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createInstrumentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.challengeResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.backupDeviceChoicesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.backupDocumentChoicesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.earlyUpdateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.preloadsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.myAccountsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.contentFilterResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.experimentsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.surveyResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.pingResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.updateUserSettingResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getUserSettingsREsponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getSharingSettingsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.updateSharingSettingsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reviewSnippetsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.documentSharingStateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.moduleDeliveryResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.listResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.detailsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.reviewResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.buyResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.searchResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.tocResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.browseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.purchaseStatusResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.updateInstrumentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.logResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.checkInstrumentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.plusOneResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.flagContentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.ackNotificationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.initiateAssociationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.verifyAssociationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.libraryReplicationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.revokeResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.bulkDetailsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.resolveLinkResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.deliveryResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.acceptTosResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.rateSuggestedContentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.checkPromoOfferResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.instrumentSetupInfoResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.redeemGiftCardResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.modifyLibraryResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.uploadDeviceConfigResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.plusProfileResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.consumePurchaseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.billingProfileResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.preparePurchaseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.commitPurchaseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.debugSettingsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.checkIabPromoResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.userActivitySettingsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.recordUserActivityResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.redeemCodeResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        if let Some(v) = self.selfUpdateResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        }
        if let Some(v) = self.searchSuggestResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.getInitialInstrumentFlowStateResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.createInstrumentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.challengeResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        }
        if let Some(v) = self.backupDeviceChoicesResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        if let Some(v) = self.backupDocumentChoicesResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        }
        if let Some(v) = self.earlyUpdateResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
        }
        if let Some(v) = self.preloadsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        }
        if let Some(v) = self.myAccountsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
        }
        if let Some(v) = self.contentFilterResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        }
        if let Some(v) = self.experimentsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        if let Some(v) = self.surveyResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        }
        if let Some(v) = self.pingResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(52, v, os)?;
        }
        if let Some(v) = self.updateUserSettingResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(53, v, os)?;
        }
        if let Some(v) = self.getUserSettingsREsponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        }
        if let Some(v) = self.getSharingSettingsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(56, v, os)?;
        }
        if let Some(v) = self.updateSharingSettingsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
        }
        if let Some(v) = self.reviewSnippetsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(58, v, os)?;
        }
        if let Some(v) = self.documentSharingStateResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(59, v, os)?;
        }
        if let Some(v) = self.moduleDeliveryResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(70, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload {
        Payload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListResponse>, _>(
                "listResponse",
                |m: &Payload| { &m.listResponse },
                |m: &mut Payload| { &mut m.listResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DetailsResponse>, _>(
                "detailsResponse",
                |m: &Payload| { &m.detailsResponse },
                |m: &mut Payload| { &mut m.detailsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReviewResponse>, _>(
                "reviewResponse",
                |m: &Payload| { &m.reviewResponse },
                |m: &mut Payload| { &mut m.reviewResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuyResponse>, _>(
                "buyResponse",
                |m: &Payload| { &m.buyResponse },
                |m: &mut Payload| { &mut m.buyResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SearchResponse>, _>(
                "searchResponse",
                |m: &Payload| { &m.searchResponse },
                |m: &mut Payload| { &mut m.searchResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TocResponse>, _>(
                "tocResponse",
                |m: &Payload| { &m.tocResponse },
                |m: &mut Payload| { &mut m.tocResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseResponse>, _>(
                "browseResponse",
                |m: &Payload| { &m.browseResponse },
                |m: &mut Payload| { &mut m.browseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatusResponse>, _>(
                "purchaseStatusResponse",
                |m: &Payload| { &m.purchaseStatusResponse },
                |m: &mut Payload| { &mut m.purchaseStatusResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateInstrumentResponse>, _>(
                "updateInstrumentResponse",
                |m: &Payload| { &m.updateInstrumentResponse },
                |m: &mut Payload| { &mut m.updateInstrumentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogResponse>, _>(
                "logResponse",
                |m: &Payload| { &m.logResponse },
                |m: &mut Payload| { &mut m.logResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckInstrumentResponse>, _>(
                "checkInstrumentResponse",
                |m: &Payload| { &m.checkInstrumentResponse },
                |m: &mut Payload| { &mut m.checkInstrumentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusOneResponse>, _>(
                "plusOneResponse",
                |m: &Payload| { &m.plusOneResponse },
                |m: &mut Payload| { &mut m.plusOneResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlagContentResponse>, _>(
                "flagContentResponse",
                |m: &Payload| { &m.flagContentResponse },
                |m: &mut Payload| { &mut m.flagContentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationResponse>, _>(
                "ackNotificationResponse",
                |m: &Payload| { &m.ackNotificationResponse },
                |m: &mut Payload| { &mut m.ackNotificationResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InitiateAssociationResponse>, _>(
                "initiateAssociationResponse",
                |m: &Payload| { &m.initiateAssociationResponse },
                |m: &mut Payload| { &mut m.initiateAssociationResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VerifyAssociationResponse>, _>(
                "verifyAssociationResponse",
                |m: &Payload| { &m.verifyAssociationResponse },
                |m: &mut Payload| { &mut m.verifyAssociationResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryReplicationResponse>, _>(
                "libraryReplicationResponse",
                |m: &Payload| { &m.libraryReplicationResponse },
                |m: &mut Payload| { &mut m.libraryReplicationResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RevokeResponse>, _>(
                "revokeResponse",
                |m: &Payload| { &m.revokeResponse },
                |m: &mut Payload| { &mut m.revokeResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulkDetailsResponse>, _>(
                "bulkDetailsResponse",
                |m: &Payload| { &m.bulkDetailsResponse },
                |m: &mut Payload| { &mut m.bulkDetailsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedLink>, _>(
                "resolveLinkResponse",
                |m: &Payload| { &m.resolveLinkResponse },
                |m: &mut Payload| { &mut m.resolveLinkResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeliveryResponse>, _>(
                "deliveryResponse",
                |m: &Payload| { &m.deliveryResponse },
                |m: &mut Payload| { &mut m.deliveryResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AcceptTosResponse>, _>(
                "acceptTosResponse",
                |m: &Payload| { &m.acceptTosResponse },
                |m: &mut Payload| { &mut m.acceptTosResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateSuggestedContentResponse>, _>(
                "rateSuggestedContentResponse",
                |m: &Payload| { &m.rateSuggestedContentResponse },
                |m: &mut Payload| { &mut m.rateSuggestedContentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckPromoOfferResponse>, _>(
                "checkPromoOfferResponse",
                |m: &Payload| { &m.checkPromoOfferResponse },
                |m: &mut Payload| { &mut m.checkPromoOfferResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstrumentSetupInfoResponse>, _>(
                "instrumentSetupInfoResponse",
                |m: &Payload| { &m.instrumentSetupInfoResponse },
                |m: &mut Payload| { &mut m.instrumentSetupInfoResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemGiftCardResponse>, _>(
                "redeemGiftCardResponse",
                |m: &Payload| { &m.redeemGiftCardResponse },
                |m: &mut Payload| { &mut m.redeemGiftCardResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyLibraryResponse>, _>(
                "modifyLibraryResponse",
                |m: &Payload| { &m.modifyLibraryResponse },
                |m: &mut Payload| { &mut m.modifyLibraryResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UploadDeviceConfigResponse>, _>(
                "uploadDeviceConfigResponse",
                |m: &Payload| { &m.uploadDeviceConfigResponse },
                |m: &mut Payload| { &mut m.uploadDeviceConfigResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfileResponse>, _>(
                "plusProfileResponse",
                |m: &Payload| { &m.plusProfileResponse },
                |m: &mut Payload| { &mut m.plusProfileResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumePurchaseResponse>, _>(
                "consumePurchaseResponse",
                |m: &Payload| { &m.consumePurchaseResponse },
                |m: &mut Payload| { &mut m.consumePurchaseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingProfileResponse>, _>(
                "billingProfileResponse",
                |m: &Payload| { &m.billingProfileResponse },
                |m: &mut Payload| { &mut m.billingProfileResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreparePurchaseResponse>, _>(
                "preparePurchaseResponse",
                |m: &Payload| { &m.preparePurchaseResponse },
                |m: &mut Payload| { &mut m.preparePurchaseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommitPurchaseResponse>, _>(
                "commitPurchaseResponse",
                |m: &Payload| { &m.commitPurchaseResponse },
                |m: &mut Payload| { &mut m.commitPurchaseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugSettingsResponse>, _>(
                "debugSettingsResponse",
                |m: &Payload| { &m.debugSettingsResponse },
                |m: &mut Payload| { &mut m.debugSettingsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckIabPromoResponse>, _>(
                "checkIabPromoResponse",
                |m: &Payload| { &m.checkIabPromoResponse },
                |m: &mut Payload| { &mut m.checkIabPromoResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserActivitySettingsResponse>, _>(
                "userActivitySettingsResponse",
                |m: &Payload| { &m.userActivitySettingsResponse },
                |m: &mut Payload| { &mut m.userActivitySettingsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecordUserActivityResponse>, _>(
                "recordUserActivityResponse",
                |m: &Payload| { &m.recordUserActivityResponse },
                |m: &mut Payload| { &mut m.recordUserActivityResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemCodeResponse>, _>(
                "redeemCodeResponse",
                |m: &Payload| { &m.redeemCodeResponse },
                |m: &mut Payload| { &mut m.redeemCodeResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfUpdateResponse>, _>(
                "selfUpdateResponse",
                |m: &Payload| { &m.selfUpdateResponse },
                |m: &mut Payload| { &mut m.selfUpdateResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<searchSuggestResponse>, _>(
                "searchSuggestResponse",
                |m: &Payload| { &m.searchSuggestResponse },
                |m: &mut Payload| { &mut m.searchSuggestResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetInitialInstrumentFlowStateResponse>, _>(
                "getInitialInstrumentFlowStateResponse",
                |m: &Payload| { &m.getInitialInstrumentFlowStateResponse },
                |m: &mut Payload| { &mut m.getInitialInstrumentFlowStateResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateInstrumentResponse>, _>(
                "createInstrumentResponse",
                |m: &Payload| { &m.createInstrumentResponse },
                |m: &mut Payload| { &mut m.createInstrumentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChallengeResponse>, _>(
                "challengeResponse",
                |m: &Payload| { &m.challengeResponse },
                |m: &mut Payload| { &mut m.challengeResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BackDeviceChoicesResponse>, _>(
                "backupDeviceChoicesResponse",
                |m: &Payload| { &m.backupDeviceChoicesResponse },
                |m: &mut Payload| { &mut m.backupDeviceChoicesResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BackupDocumentChoicesResponse>, _>(
                "backupDocumentChoicesResponse",
                |m: &Payload| { &m.backupDocumentChoicesResponse },
                |m: &mut Payload| { &mut m.backupDocumentChoicesResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EarlyUpdateResponse>, _>(
                "earlyUpdateResponse",
                |m: &Payload| { &m.earlyUpdateResponse },
                |m: &mut Payload| { &mut m.earlyUpdateResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreloadsResponse>, _>(
                "preloadsResponse",
                |m: &Payload| { &m.preloadsResponse },
                |m: &mut Payload| { &mut m.preloadsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MyAccountsResponse>, _>(
                "myAccountsResponse",
                |m: &Payload| { &m.myAccountsResponse },
                |m: &mut Payload| { &mut m.myAccountsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentFilterResponse>, _>(
                "contentFilterResponse",
                |m: &Payload| { &m.contentFilterResponse },
                |m: &mut Payload| { &mut m.contentFilterResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExperimentsResponse>, _>(
                "experimentsResponse",
                |m: &Payload| { &m.experimentsResponse },
                |m: &mut Payload| { &mut m.experimentsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SurveyResponse>, _>(
                "surveyResponse",
                |m: &Payload| { &m.surveyResponse },
                |m: &mut Payload| { &mut m.surveyResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PingResponse>, _>(
                "pingResponse",
                |m: &Payload| { &m.pingResponse },
                |m: &mut Payload| { &mut m.pingResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateUserSettingResponse>, _>(
                "updateUserSettingResponse",
                |m: &Payload| { &m.updateUserSettingResponse },
                |m: &mut Payload| { &mut m.updateUserSettingResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetUserSettingsResponse>, _>(
                "getUserSettingsREsponse",
                |m: &Payload| { &m.getUserSettingsREsponse },
                |m: &mut Payload| { &mut m.getUserSettingsREsponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSharingSettingsResponse>, _>(
                "getSharingSettingsResponse",
                |m: &Payload| { &m.getSharingSettingsResponse },
                |m: &mut Payload| { &mut m.getSharingSettingsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateSharingSettingsResponse>, _>(
                "updateSharingSettingsResponse",
                |m: &Payload| { &m.updateSharingSettingsResponse },
                |m: &mut Payload| { &mut m.updateSharingSettingsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReviewSnippetsResponse>, _>(
                "reviewSnippetsResponse",
                |m: &Payload| { &m.reviewSnippetsResponse },
                |m: &mut Payload| { &mut m.reviewSnippetsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentSharingStateResponse>, _>(
                "documentSharingStateResponse",
                |m: &Payload| { &m.documentSharingStateResponse },
                |m: &mut Payload| { &mut m.documentSharingStateResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModuleDeliveryResponse>, _>(
                "moduleDeliveryResponse",
                |m: &Payload| { &m.moduleDeliveryResponse },
                |m: &mut Payload| { &mut m.moduleDeliveryResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Payload>(
                "Payload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload {
        static instance: ::protobuf::rt::Lazy<Payload> = ::protobuf::rt::Lazy::INIT;
        instance.get(Payload::new)
    }
}

impl ::protobuf::Clear for Payload {
    fn clear(&mut self) {
        self.listResponse.clear();
        self.detailsResponse.clear();
        self.reviewResponse.clear();
        self.buyResponse.clear();
        self.searchResponse.clear();
        self.tocResponse.clear();
        self.browseResponse.clear();
        self.purchaseStatusResponse.clear();
        self.updateInstrumentResponse.clear();
        self.logResponse.clear();
        self.checkInstrumentResponse.clear();
        self.plusOneResponse.clear();
        self.flagContentResponse.clear();
        self.ackNotificationResponse.clear();
        self.initiateAssociationResponse.clear();
        self.verifyAssociationResponse.clear();
        self.libraryReplicationResponse.clear();
        self.revokeResponse.clear();
        self.bulkDetailsResponse.clear();
        self.resolveLinkResponse.clear();
        self.deliveryResponse.clear();
        self.acceptTosResponse.clear();
        self.rateSuggestedContentResponse.clear();
        self.checkPromoOfferResponse.clear();
        self.instrumentSetupInfoResponse.clear();
        self.redeemGiftCardResponse.clear();
        self.modifyLibraryResponse.clear();
        self.uploadDeviceConfigResponse.clear();
        self.plusProfileResponse.clear();
        self.consumePurchaseResponse.clear();
        self.billingProfileResponse.clear();
        self.preparePurchaseResponse.clear();
        self.commitPurchaseResponse.clear();
        self.debugSettingsResponse.clear();
        self.checkIabPromoResponse.clear();
        self.userActivitySettingsResponse.clear();
        self.recordUserActivityResponse.clear();
        self.redeemCodeResponse.clear();
        self.selfUpdateResponse.clear();
        self.searchSuggestResponse.clear();
        self.getInitialInstrumentFlowStateResponse.clear();
        self.createInstrumentResponse.clear();
        self.challengeResponse.clear();
        self.backupDeviceChoicesResponse.clear();
        self.backupDocumentChoicesResponse.clear();
        self.earlyUpdateResponse.clear();
        self.preloadsResponse.clear();
        self.myAccountsResponse.clear();
        self.contentFilterResponse.clear();
        self.experimentsResponse.clear();
        self.surveyResponse.clear();
        self.pingResponse.clear();
        self.updateUserSettingResponse.clear();
        self.getUserSettingsREsponse.clear();
        self.getSharingSettingsResponse.clear();
        self.updateSharingSettingsResponse.clear();
        self.reviewSnippetsResponse.clear();
        self.documentSharingStateResponse.clear();
        self.moduleDeliveryResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CheckIabPromoResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CheckIabPromoResponse {
    pub fn new() -> CheckIabPromoResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckIabPromoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckIabPromoResponse {
        CheckIabPromoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CheckIabPromoResponse>(
                "CheckIabPromoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckIabPromoResponse {
        static instance: ::protobuf::rt::Lazy<CheckIabPromoResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CheckIabPromoResponse::new)
    }
}

impl ::protobuf::Clear for CheckIabPromoResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckIabPromoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckIabPromoResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UserActivitySettingsResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UserActivitySettingsResponse {
    pub fn new() -> UserActivitySettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UserActivitySettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserActivitySettingsResponse {
        UserActivitySettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<UserActivitySettingsResponse>(
                "UserActivitySettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserActivitySettingsResponse {
        static instance: ::protobuf::rt::Lazy<UserActivitySettingsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(UserActivitySettingsResponse::new)
    }
}

impl ::protobuf::Clear for UserActivitySettingsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserActivitySettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserActivitySettingsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RecordUserActivityResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RecordUserActivityResponse {
    pub fn new() -> RecordUserActivityResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RecordUserActivityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecordUserActivityResponse {
        RecordUserActivityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<RecordUserActivityResponse>(
                "RecordUserActivityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecordUserActivityResponse {
        static instance: ::protobuf::rt::Lazy<RecordUserActivityResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(RecordUserActivityResponse::new)
    }
}

impl ::protobuf::Clear for RecordUserActivityResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecordUserActivityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecordUserActivityResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RedeemCodeResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RedeemCodeResponse {
    pub fn new() -> RedeemCodeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RedeemCodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemCodeResponse {
        RedeemCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<RedeemCodeResponse>(
                "RedeemCodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemCodeResponse {
        static instance: ::protobuf::rt::Lazy<RedeemCodeResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(RedeemCodeResponse::new)
    }
}

impl ::protobuf::Clear for RedeemCodeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemCodeResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SelfUpdateResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SelfUpdateResponse {
    pub fn new() -> SelfUpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SelfUpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfUpdateResponse {
        SelfUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<SelfUpdateResponse>(
                "SelfUpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelfUpdateResponse {
        static instance: ::protobuf::rt::Lazy<SelfUpdateResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(SelfUpdateResponse::new)
    }
}

impl ::protobuf::Clear for SelfUpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfUpdateResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct searchSuggestResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl searchSuggestResponse {
    pub fn new() -> searchSuggestResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for searchSuggestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> searchSuggestResponse {
        searchSuggestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<searchSuggestResponse>(
                "searchSuggestResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static searchSuggestResponse {
        static instance: ::protobuf::rt::Lazy<searchSuggestResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(searchSuggestResponse::new)
    }
}

impl ::protobuf::Clear for searchSuggestResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for searchSuggestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for searchSuggestResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetInitialInstrumentFlowStateResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetInitialInstrumentFlowStateResponse {
    pub fn new() -> GetInitialInstrumentFlowStateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetInitialInstrumentFlowStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInitialInstrumentFlowStateResponse {
        GetInitialInstrumentFlowStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<GetInitialInstrumentFlowStateResponse>(
                "GetInitialInstrumentFlowStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInitialInstrumentFlowStateResponse {
        static instance: ::protobuf::rt::Lazy<GetInitialInstrumentFlowStateResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetInitialInstrumentFlowStateResponse::new)
    }
}

impl ::protobuf::Clear for GetInitialInstrumentFlowStateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInitialInstrumentFlowStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInitialInstrumentFlowStateResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CreateInstrumentResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CreateInstrumentResponse {
    pub fn new() -> CreateInstrumentResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateInstrumentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateInstrumentResponse {
        CreateInstrumentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CreateInstrumentResponse>(
                "CreateInstrumentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateInstrumentResponse {
        static instance: ::protobuf::rt::Lazy<CreateInstrumentResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CreateInstrumentResponse::new)
    }
}

impl ::protobuf::Clear for CreateInstrumentResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateInstrumentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateInstrumentResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ChallengeResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ChallengeResponse {
    pub fn new() -> ChallengeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChallengeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChallengeResponse {
        ChallengeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<ChallengeResponse>(
                "ChallengeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChallengeResponse {
        static instance: ::protobuf::rt::Lazy<ChallengeResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ChallengeResponse::new)
    }
}

impl ::protobuf::Clear for ChallengeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChallengeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BackDeviceChoicesResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BackDeviceChoicesResponse {
    pub fn new() -> BackDeviceChoicesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BackDeviceChoicesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackDeviceChoicesResponse {
        BackDeviceChoicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<BackDeviceChoicesResponse>(
                "BackDeviceChoicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackDeviceChoicesResponse {
        static instance: ::protobuf::rt::Lazy<BackDeviceChoicesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(BackDeviceChoicesResponse::new)
    }
}

impl ::protobuf::Clear for BackDeviceChoicesResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackDeviceChoicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackDeviceChoicesResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BackupDocumentChoicesResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BackupDocumentChoicesResponse {
    pub fn new() -> BackupDocumentChoicesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BackupDocumentChoicesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackupDocumentChoicesResponse {
        BackupDocumentChoicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<BackupDocumentChoicesResponse>(
                "BackupDocumentChoicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackupDocumentChoicesResponse {
        static instance: ::protobuf::rt::Lazy<BackupDocumentChoicesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(BackupDocumentChoicesResponse::new)
    }
}

impl ::protobuf::Clear for BackupDocumentChoicesResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackupDocumentChoicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupDocumentChoicesResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct EarlyUpdateResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl EarlyUpdateResponse {
    pub fn new() -> EarlyUpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EarlyUpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EarlyUpdateResponse {
        EarlyUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<EarlyUpdateResponse>(
                "EarlyUpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EarlyUpdateResponse {
        static instance: ::protobuf::rt::Lazy<EarlyUpdateResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(EarlyUpdateResponse::new)
    }
}

impl ::protobuf::Clear for EarlyUpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EarlyUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EarlyUpdateResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PreloadsResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PreloadsResponse {
    pub fn new() -> PreloadsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PreloadsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreloadsResponse {
        PreloadsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<PreloadsResponse>(
                "PreloadsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreloadsResponse {
        static instance: ::protobuf::rt::Lazy<PreloadsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(PreloadsResponse::new)
    }
}

impl ::protobuf::Clear for PreloadsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreloadsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreloadsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct MyAccountsResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl MyAccountsResponse {
    pub fn new() -> MyAccountsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MyAccountsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyAccountsResponse {
        MyAccountsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<MyAccountsResponse>(
                "MyAccountsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MyAccountsResponse {
        static instance: ::protobuf::rt::Lazy<MyAccountsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(MyAccountsResponse::new)
    }
}

impl ::protobuf::Clear for MyAccountsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyAccountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyAccountsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ContentFilterResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ContentFilterResponse {
    pub fn new() -> ContentFilterResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ContentFilterResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentFilterResponse {
        ContentFilterResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<ContentFilterResponse>(
                "ContentFilterResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentFilterResponse {
        static instance: ::protobuf::rt::Lazy<ContentFilterResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ContentFilterResponse::new)
    }
}

impl ::protobuf::Clear for ContentFilterResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentFilterResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExperimentsResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExperimentsResponse {
    pub fn new() -> ExperimentsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ExperimentsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExperimentsResponse {
        ExperimentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<ExperimentsResponse>(
                "ExperimentsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExperimentsResponse {
        static instance: ::protobuf::rt::Lazy<ExperimentsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExperimentsResponse::new)
    }
}

impl ::protobuf::Clear for ExperimentsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExperimentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExperimentsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SurveyResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SurveyResponse {
    pub fn new() -> SurveyResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SurveyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SurveyResponse {
        SurveyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<SurveyResponse>(
                "SurveyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SurveyResponse {
        static instance: ::protobuf::rt::Lazy<SurveyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(SurveyResponse::new)
    }
}

impl ::protobuf::Clear for SurveyResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SurveyResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PingResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<PingResponse>(
                "PingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PingResponse {
        static instance: ::protobuf::rt::Lazy<PingResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(PingResponse::new)
    }
}

impl ::protobuf::Clear for PingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UpdateUserSettingResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UpdateUserSettingResponse {
    pub fn new() -> UpdateUserSettingResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateUserSettingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateUserSettingResponse {
        UpdateUserSettingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<UpdateUserSettingResponse>(
                "UpdateUserSettingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateUserSettingResponse {
        static instance: ::protobuf::rt::Lazy<UpdateUserSettingResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(UpdateUserSettingResponse::new)
    }
}

impl ::protobuf::Clear for UpdateUserSettingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateUserSettingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserSettingResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetUserSettingsResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetUserSettingsResponse {
    pub fn new() -> GetUserSettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetUserSettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUserSettingsResponse {
        GetUserSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<GetUserSettingsResponse>(
                "GetUserSettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetUserSettingsResponse {
        static instance: ::protobuf::rt::Lazy<GetUserSettingsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetUserSettingsResponse::new)
    }
}

impl ::protobuf::Clear for GetUserSettingsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUserSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserSettingsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetSharingSettingsResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetSharingSettingsResponse {
    pub fn new() -> GetSharingSettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSharingSettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSharingSettingsResponse {
        GetSharingSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<GetSharingSettingsResponse>(
                "GetSharingSettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSharingSettingsResponse {
        static instance: ::protobuf::rt::Lazy<GetSharingSettingsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetSharingSettingsResponse::new)
    }
}

impl ::protobuf::Clear for GetSharingSettingsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSharingSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSharingSettingsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UpdateSharingSettingsResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UpdateSharingSettingsResponse {
    pub fn new() -> UpdateSharingSettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateSharingSettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSharingSettingsResponse {
        UpdateSharingSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<UpdateSharingSettingsResponse>(
                "UpdateSharingSettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSharingSettingsResponse {
        static instance: ::protobuf::rt::Lazy<UpdateSharingSettingsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(UpdateSharingSettingsResponse::new)
    }
}

impl ::protobuf::Clear for UpdateSharingSettingsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSharingSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSharingSettingsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ReviewSnippetsResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ReviewSnippetsResponse {
    pub fn new() -> ReviewSnippetsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReviewSnippetsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReviewSnippetsResponse {
        ReviewSnippetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<ReviewSnippetsResponse>(
                "ReviewSnippetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReviewSnippetsResponse {
        static instance: ::protobuf::rt::Lazy<ReviewSnippetsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ReviewSnippetsResponse::new)
    }
}

impl ::protobuf::Clear for ReviewSnippetsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReviewSnippetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewSnippetsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DocumentSharingStateResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DocumentSharingStateResponse {
    pub fn new() -> DocumentSharingStateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DocumentSharingStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentSharingStateResponse {
        DocumentSharingStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<DocumentSharingStateResponse>(
                "DocumentSharingStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentSharingStateResponse {
        static instance: ::protobuf::rt::Lazy<DocumentSharingStateResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(DocumentSharingStateResponse::new)
    }
}

impl ::protobuf::Clear for DocumentSharingStateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentSharingStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentSharingStateResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ModuleDeliveryResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ModuleDeliveryResponse {
    pub fn new() -> ModuleDeliveryResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModuleDeliveryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModuleDeliveryResponse {
        ModuleDeliveryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<ModuleDeliveryResponse>(
                "ModuleDeliveryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModuleDeliveryResponse {
        static instance: ::protobuf::rt::Lazy<ModuleDeliveryResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ModuleDeliveryResponse::new)
    }
}

impl ::protobuf::Clear for ModuleDeliveryResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModuleDeliveryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleDeliveryResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PreFetch {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub response: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub etag: ::protobuf::SingularField<::std::string::String>,
    pub ttl: ::std::option::Option<i64>,
    pub softTtl: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PreFetch {
    pub fn new() -> PreFetch {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bytes response = 2;

    pub fn get_response(&self) -> &[u8] {
        match self.response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional string etag = 3;

    pub fn get_etag(&self) -> &str {
        match self.etag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 ttl = 4;

    pub fn get_ttl(&self) -> i64 {
        self.ttl.unwrap_or(0)
    }

    // optional int64 softTtl = 5;

    pub fn get_softTtl(&self) -> i64 {
        self.softTtl.unwrap_or(0)
    }
}

impl ::protobuf::Message for PreFetch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.response)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.etag)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ttl = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.softTtl = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.etag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ttl {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.softTtl {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.response.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.etag.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ttl {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.softTtl {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreFetch {
        PreFetch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &PreFetch| { &m.url },
                |m: &mut PreFetch| { &mut m.url },
                PreFetch::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "response",
                |m: &PreFetch| { &m.response },
                |m: &mut PreFetch| { &mut m.response },
                PreFetch::get_response,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "etag",
                |m: &PreFetch| { &m.etag },
                |m: &mut PreFetch| { &mut m.etag },
                PreFetch::get_etag,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "ttl",
                |m: &PreFetch| { &m.ttl },
                |m: &mut PreFetch| { &mut m.ttl },
                PreFetch::get_ttl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "softTtl",
                |m: &PreFetch| { &m.softTtl },
                |m: &mut PreFetch| { &mut m.softTtl },
                PreFetch::get_softTtl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PreFetch>(
                "PreFetch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreFetch {
        static instance: ::protobuf::rt::Lazy<PreFetch> = ::protobuf::rt::Lazy::INIT;
        instance.get(PreFetch::new)
    }
}

impl ::protobuf::Clear for PreFetch {
    fn clear(&mut self) {
        self.url.clear();
        self.response.clear();
        self.etag.clear();
        self.ttl = ::std::option::Option::None;
        self.softTtl = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreFetch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreFetch {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ResponseWrapper {
    // message fields
    pub payload: ::protobuf::SingularPtrField<Payload>,
    pub commands: ::protobuf::SingularPtrField<ServerCommands>,
    pub preFetch: ::protobuf::RepeatedField<PreFetch>,
    pub notification: ::protobuf::RepeatedField<Notification>,
    pub serverMetadata: ::protobuf::SingularPtrField<ServerMetadata>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ResponseWrapper {
    pub fn new() -> ResponseWrapper {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseWrapper {
    fn is_initialized(&self) -> bool {
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commands {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preFetch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.serverMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<Payload, _>(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ServerCommands, _>(wire_type, is, &mut self.commands)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.preFetch)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.notification)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<ServerMetadata, _>(wire_type, is, &mut self.serverMetadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.commands.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.preFetch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.notification {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.serverMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.payload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.commands.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.preFetch {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.notification {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.serverMetadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseWrapper {
        ResponseWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload>, _>(
                "payload",
                |m: &ResponseWrapper| { &m.payload },
                |m: &mut ResponseWrapper| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerCommands>, _>(
                "commands",
                |m: &ResponseWrapper| { &m.commands },
                |m: &mut ResponseWrapper| { &mut m.commands },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreFetch>>(
                "preFetch",
                |m: &ResponseWrapper| { &m.preFetch },
                |m: &mut ResponseWrapper| { &mut m.preFetch },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Notification>>(
                "notification",
                |m: &ResponseWrapper| { &m.notification },
                |m: &mut ResponseWrapper| { &mut m.notification },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerMetadata>, _>(
                "serverMetadata",
                |m: &ResponseWrapper| { &m.serverMetadata },
                |m: &mut ResponseWrapper| { &mut m.serverMetadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ResponseWrapper>(
                "ResponseWrapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseWrapper {
        static instance: ::protobuf::rt::Lazy<ResponseWrapper> = ::protobuf::rt::Lazy::INIT;
        instance.get(ResponseWrapper::new)
    }
}

impl ::protobuf::Clear for ResponseWrapper {
    fn clear(&mut self) {
        self.payload.clear();
        self.commands.clear();
        self.preFetch.clear();
        self.notification.clear();
        self.serverMetadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseWrapper {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ServerCommands {
    // message fields
    pub clearCache: ::std::option::Option<bool>,
    pub displayErrorMessage: ::protobuf::SingularField<::std::string::String>,
    pub logErrorStacktrace: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ServerCommands {
    pub fn new() -> ServerCommands {
        ::std::default::Default::default()
    }

    // optional bool clearCache = 1;

    pub fn get_clearCache(&self) -> bool {
        self.clearCache.unwrap_or(false)
    }

    // optional string displayErrorMessage = 2;

    pub fn get_displayErrorMessage(&self) -> &str {
        match self.displayErrorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string logErrorStacktrace = 3;

    pub fn get_logErrorStacktrace(&self) -> &str {
        match self.logErrorStacktrace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ServerCommands {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clearCache = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayErrorMessage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.logErrorStacktrace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clearCache {
            my_size += 2;
        }
        if let Some(v) = self.displayErrorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.logErrorStacktrace.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clearCache {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.displayErrorMessage.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.logErrorStacktrace.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerCommands {
        ServerCommands::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "clearCache",
                |m: &ServerCommands| { &m.clearCache },
                |m: &mut ServerCommands| { &mut m.clearCache },
                ServerCommands::get_clearCache,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "displayErrorMessage",
                |m: &ServerCommands| { &m.displayErrorMessage },
                |m: &mut ServerCommands| { &mut m.displayErrorMessage },
                ServerCommands::get_displayErrorMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "logErrorStacktrace",
                |m: &ServerCommands| { &m.logErrorStacktrace },
                |m: &mut ServerCommands| { &mut m.logErrorStacktrace },
                ServerCommands::get_logErrorStacktrace,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ServerCommands>(
                "ServerCommands",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerCommands {
        static instance: ::protobuf::rt::Lazy<ServerCommands> = ::protobuf::rt::Lazy::INIT;
        instance.get(ServerCommands::new)
    }
}

impl ::protobuf::Clear for ServerCommands {
    fn clear(&mut self) {
        self.clearCache = ::std::option::Option::None;
        self.displayErrorMessage.clear();
        self.logErrorStacktrace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerCommands {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerCommands {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ServerMetadata {
    // message fields
    pub latencyMillis: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ServerMetadata {
    pub fn new() -> ServerMetadata {
        ::std::default::Default::default()
    }

    // optional int64 latencyMillis = 1;

    pub fn get_latencyMillis(&self) -> i64 {
        self.latencyMillis.unwrap_or(0)
    }
}

impl ::protobuf::Message for ServerMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latencyMillis = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.latencyMillis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.latencyMillis {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerMetadata {
        ServerMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "latencyMillis",
                |m: &ServerMetadata| { &m.latencyMillis },
                |m: &mut ServerMetadata| { &mut m.latencyMillis },
                ServerMetadata::get_latencyMillis,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ServerMetadata>(
                "ServerMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerMetadata {
        static instance: ::protobuf::rt::Lazy<ServerMetadata> = ::protobuf::rt::Lazy::INIT;
        instance.get(ServerMetadata::new)
    }
}

impl ::protobuf::Clear for ServerMetadata {
    fn clear(&mut self) {
        self.latencyMillis = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMetadata {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetReviewsResponse {
    // message fields
    pub review: ::protobuf::RepeatedField<Review>,
    pub matchingCount: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetReviewsResponse {
    pub fn new() -> GetReviewsResponse {
        ::std::default::Default::default()
    }

    // optional int64 matchingCount = 2;

    pub fn get_matchingCount(&self) -> i64 {
        self.matchingCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetReviewsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.review {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.review)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.matchingCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.review {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.matchingCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.review {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.matchingCount {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetReviewsResponse {
        GetReviewsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "review",
                |m: &GetReviewsResponse| { &m.review },
                |m: &mut GetReviewsResponse| { &mut m.review },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "matchingCount",
                |m: &GetReviewsResponse| { &m.matchingCount },
                |m: &mut GetReviewsResponse| { &mut m.matchingCount },
                GetReviewsResponse::get_matchingCount,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetReviewsResponse>(
                "GetReviewsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetReviewsResponse {
        static instance: ::protobuf::rt::Lazy<GetReviewsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetReviewsResponse::new)
    }
}

impl ::protobuf::Clear for GetReviewsResponse {
    fn clear(&mut self) {
        self.review.clear();
        self.matchingCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetReviewsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetReviewsResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Review {
    // message fields
    pub authorName: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub source: ::protobuf::SingularField<::std::string::String>,
    pub documentVersion: ::protobuf::SingularField<::std::string::String>,
    pub timestampMsec: ::std::option::Option<i64>,
    pub starRating: ::std::option::Option<i32>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub comment: ::protobuf::SingularField<::std::string::String>,
    pub commentId: ::protobuf::SingularField<::std::string::String>,
    pub deviceName: ::protobuf::SingularField<::std::string::String>,
    pub replyText: ::protobuf::SingularField<::std::string::String>,
    pub replyTimestampMsec: ::std::option::Option<i64>,
    pub plusProfile: ::protobuf::SingularPtrField<PlusProfile>,
    pub author: ::protobuf::SingularPtrField<DocV2>,
    pub sentiment: ::protobuf::SingularPtrField<Image>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Review {
    pub fn new() -> Review {
        ::std::default::Default::default()
    }

    // optional string authorName = 1;

    pub fn get_authorName(&self) -> &str {
        match self.authorName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string url = 2;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string source = 3;

    pub fn get_source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string documentVersion = 4;

    pub fn get_documentVersion(&self) -> &str {
        match self.documentVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 timestampMsec = 5;

    pub fn get_timestampMsec(&self) -> i64 {
        self.timestampMsec.unwrap_or(0)
    }

    // optional int32 starRating = 6;

    pub fn get_starRating(&self) -> i32 {
        self.starRating.unwrap_or(0)
    }

    // optional string title = 7;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string comment = 8;

    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string commentId = 9;

    pub fn get_commentId(&self) -> &str {
        match self.commentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string deviceName = 19;

    pub fn get_deviceName(&self) -> &str {
        match self.deviceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string replyText = 29;

    pub fn get_replyText(&self) -> &str {
        match self.replyText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 replyTimestampMsec = 30;

    pub fn get_replyTimestampMsec(&self) -> i64 {
        self.replyTimestampMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for Review {
    fn is_initialized(&self) -> bool {
        for v in &self.plusProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.author {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.authorName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.documentVersion)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestampMsec = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.starRating = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.commentId)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceName)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.replyText)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replyTimestampMsec = ::std::option::Option::Some(tmp);
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into::<PlusProfile, _>(wire_type, is, &mut self.plusProfile)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into::<DocV2, _>(wire_type, is, &mut self.author)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into::<Image, _>(wire_type, is, &mut self.sentiment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.authorName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.documentVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.timestampMsec {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.starRating {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.commentId.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.deviceName.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.replyText.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.replyTimestampMsec {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.plusProfile.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.author.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sentiment.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.authorName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.documentVersion.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.timestampMsec {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.starRating {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.commentId.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.deviceName.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.replyText.as_ref() {
            os.write_string(29, v)?;
        }
        if let Some(v) = self.replyTimestampMsec {
            os.write_int64(30, v)?;
        }
        if let Some(v) = self.plusProfile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.author.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.sentiment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Review {
        Review::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "authorName",
                |m: &Review| { &m.authorName },
                |m: &mut Review| { &mut m.authorName },
                Review::get_authorName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &Review| { &m.url },
                |m: &mut Review| { &mut m.url },
                Review::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "source",
                |m: &Review| { &m.source },
                |m: &mut Review| { &mut m.source },
                Review::get_source,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "documentVersion",
                |m: &Review| { &m.documentVersion },
                |m: &mut Review| { &mut m.documentVersion },
                Review::get_documentVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "timestampMsec",
                |m: &Review| { &m.timestampMsec },
                |m: &mut Review| { &mut m.timestampMsec },
                Review::get_timestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "starRating",
                |m: &Review| { &m.starRating },
                |m: &mut Review| { &mut m.starRating },
                Review::get_starRating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &Review| { &m.title },
                |m: &mut Review| { &mut m.title },
                Review::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "comment",
                |m: &Review| { &m.comment },
                |m: &mut Review| { &mut m.comment },
                Review::get_comment,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "commentId",
                |m: &Review| { &m.commentId },
                |m: &mut Review| { &mut m.commentId },
                Review::get_commentId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "deviceName",
                |m: &Review| { &m.deviceName },
                |m: &mut Review| { &mut m.deviceName },
                Review::get_deviceName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "replyText",
                |m: &Review| { &m.replyText },
                |m: &mut Review| { &mut m.replyText },
                Review::get_replyText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "replyTimestampMsec",
                |m: &Review| { &m.replyTimestampMsec },
                |m: &mut Review| { &mut m.replyTimestampMsec },
                Review::get_replyTimestampMsec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfile>, _>(
                "plusProfile",
                |m: &Review| { &m.plusProfile },
                |m: &mut Review| { &mut m.plusProfile },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>, _>(
                "author",
                |m: &Review| { &m.author },
                |m: &mut Review| { &mut m.author },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>, _>(
                "sentiment",
                |m: &Review| { &m.sentiment },
                |m: &mut Review| { &mut m.sentiment },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Review>(
                "Review",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Review {
        static instance: ::protobuf::rt::Lazy<Review> = ::protobuf::rt::Lazy::INIT;
        instance.get(Review::new)
    }
}

impl ::protobuf::Clear for Review {
    fn clear(&mut self) {
        self.authorName.clear();
        self.url.clear();
        self.source.clear();
        self.documentVersion.clear();
        self.timestampMsec = ::std::option::Option::None;
        self.starRating = ::std::option::Option::None;
        self.title.clear();
        self.comment.clear();
        self.commentId.clear();
        self.deviceName.clear();
        self.replyText.clear();
        self.replyTimestampMsec = ::std::option::Option::None;
        self.plusProfile.clear();
        self.author.clear();
        self.sentiment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Review {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Review {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ReviewResponse {
    // message fields
    pub getResponse: ::protobuf::SingularPtrField<GetReviewsResponse>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub updatedReview: ::protobuf::SingularPtrField<Review>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ReviewResponse {
    pub fn new() -> ReviewResponse {
        ::std::default::Default::default()
    }

    // optional string nextPageUrl = 2;

    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ReviewResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.getResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updatedReview {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<GetReviewsResponse, _>(wire_type, is, &mut self.getResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<Review, _>(wire_type, is, &mut self.updatedReview)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.getResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.updatedReview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.getResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.nextPageUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.updatedReview.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReviewResponse {
        ReviewResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetReviewsResponse>, _>(
                "getResponse",
                |m: &ReviewResponse| { &m.getResponse },
                |m: &mut ReviewResponse| { &mut m.getResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "nextPageUrl",
                |m: &ReviewResponse| { &m.nextPageUrl },
                |m: &mut ReviewResponse| { &mut m.nextPageUrl },
                ReviewResponse::get_nextPageUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>, _>(
                "updatedReview",
                |m: &ReviewResponse| { &m.updatedReview },
                |m: &mut ReviewResponse| { &mut m.updatedReview },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ReviewResponse>(
                "ReviewResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReviewResponse {
        static instance: ::protobuf::rt::Lazy<ReviewResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(ReviewResponse::new)
    }
}

impl ::protobuf::Clear for ReviewResponse {
    fn clear(&mut self) {
        self.getResponse.clear();
        self.nextPageUrl.clear();
        self.updatedReview.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReviewResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RevokeResponse {
    // message fields
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RevokeResponse {
    pub fn new() -> RevokeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RevokeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<LibraryUpdate, _>(wire_type, is, &mut self.libraryUpdate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.libraryUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RevokeResponse {
        RevokeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>, _>(
                "libraryUpdate",
                |m: &RevokeResponse| { &m.libraryUpdate },
                |m: &mut RevokeResponse| { &mut m.libraryUpdate },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RevokeResponse>(
                "RevokeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RevokeResponse {
        static instance: ::protobuf::rt::Lazy<RevokeResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(RevokeResponse::new)
    }
}

impl ::protobuf::Clear for RevokeResponse {
    fn clear(&mut self) {
        self.libraryUpdate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RevokeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RevokeResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RelatedSearch {
    // message fields
    pub searchUrl: ::protobuf::SingularField<::std::string::String>,
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub backendId: ::std::option::Option<i32>,
    pub docType: ::std::option::Option<i32>,
    pub current: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RelatedSearch {
    pub fn new() -> RelatedSearch {
        ::std::default::Default::default()
    }

    // optional string searchUrl = 1;

    pub fn get_searchUrl(&self) -> &str {
        match self.searchUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string header = 2;

    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 backendId = 3;

    pub fn get_backendId(&self) -> i32 {
        self.backendId.unwrap_or(0)
    }

    // optional int32 docType = 4;

    pub fn get_docType(&self) -> i32 {
        self.docType.unwrap_or(0)
    }

    // optional bool current = 5;

    pub fn get_current(&self) -> bool {
        self.current.unwrap_or(false)
    }
}

impl ::protobuf::Message for RelatedSearch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.searchUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backendId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.docType = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.current = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.searchUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.backendId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.docType {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.searchUrl.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.header.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.backendId {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.docType {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.current {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelatedSearch {
        RelatedSearch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "searchUrl",
                |m: &RelatedSearch| { &m.searchUrl },
                |m: &mut RelatedSearch| { &mut m.searchUrl },
                RelatedSearch::get_searchUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "header",
                |m: &RelatedSearch| { &m.header },
                |m: &mut RelatedSearch| { &mut m.header },
                RelatedSearch::get_header,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "backendId",
                |m: &RelatedSearch| { &m.backendId },
                |m: &mut RelatedSearch| { &mut m.backendId },
                RelatedSearch::get_backendId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "docType",
                |m: &RelatedSearch| { &m.docType },
                |m: &mut RelatedSearch| { &mut m.docType },
                RelatedSearch::get_docType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "current",
                |m: &RelatedSearch| { &m.current },
                |m: &mut RelatedSearch| { &mut m.current },
                RelatedSearch::get_current,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RelatedSearch>(
                "RelatedSearch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelatedSearch {
        static instance: ::protobuf::rt::Lazy<RelatedSearch> = ::protobuf::rt::Lazy::INIT;
        instance.get(RelatedSearch::new)
    }
}

impl ::protobuf::Clear for RelatedSearch {
    fn clear(&mut self) {
        self.searchUrl.clear();
        self.header.clear();
        self.backendId = ::std::option::Option::None;
        self.docType = ::std::option::Option::None;
        self.current = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelatedSearch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedSearch {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SearchResponse {
    // message fields
    pub originalQuery: ::protobuf::SingularField<::std::string::String>,
    pub suggestedQuery: ::protobuf::SingularField<::std::string::String>,
    pub aggregateQuery: ::std::option::Option<bool>,
    pub bucket: ::protobuf::RepeatedField<Bucket>,
    pub doc: ::protobuf::RepeatedField<DocV2>,
    pub relatedSearch: ::protobuf::RepeatedField<RelatedSearch>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SearchResponse {
    pub fn new() -> SearchResponse {
        ::std::default::Default::default()
    }

    // optional string originalQuery = 1;

    pub fn get_originalQuery(&self) -> &str {
        match self.originalQuery.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string suggestedQuery = 2;

    pub fn get_suggestedQuery(&self) -> &str {
        match self.suggestedQuery.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool aggregateQuery = 3;

    pub fn get_aggregateQuery(&self) -> bool {
        self.aggregateQuery.unwrap_or(false)
    }

    // optional bytes serverLogsCookie = 7;

    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for SearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relatedSearch {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.originalQuery)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.suggestedQuery)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.aggregateQuery = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.bucket)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.doc)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.relatedSearch)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.originalQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.suggestedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.aggregateQuery {
            my_size += 2;
        }
        for value in &self.bucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.doc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.relatedSearch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.originalQuery.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.suggestedQuery.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.aggregateQuery {
            os.write_bool(3, v)?;
        }
        for v in &self.bucket {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.doc {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.relatedSearch {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchResponse {
        SearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "originalQuery",
                |m: &SearchResponse| { &m.originalQuery },
                |m: &mut SearchResponse| { &mut m.originalQuery },
                SearchResponse::get_originalQuery,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "suggestedQuery",
                |m: &SearchResponse| { &m.suggestedQuery },
                |m: &mut SearchResponse| { &mut m.suggestedQuery },
                SearchResponse::get_suggestedQuery,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "aggregateQuery",
                |m: &SearchResponse| { &m.aggregateQuery },
                |m: &mut SearchResponse| { &mut m.aggregateQuery },
                SearchResponse::get_aggregateQuery,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket>>(
                "bucket",
                |m: &SearchResponse| { &m.bucket },
                |m: &mut SearchResponse| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "doc",
                |m: &SearchResponse| { &m.doc },
                |m: &mut SearchResponse| { &mut m.doc },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelatedSearch>>(
                "relatedSearch",
                |m: &SearchResponse| { &m.relatedSearch },
                |m: &mut SearchResponse| { &mut m.relatedSearch },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "serverLogsCookie",
                |m: &SearchResponse| { &m.serverLogsCookie },
                |m: &mut SearchResponse| { &mut m.serverLogsCookie },
                SearchResponse::get_serverLogsCookie,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SearchResponse>(
                "SearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchResponse {
        static instance: ::protobuf::rt::Lazy<SearchResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(SearchResponse::new)
    }
}

impl ::protobuf::Clear for SearchResponse {
    fn clear(&mut self) {
        self.originalQuery.clear();
        self.suggestedQuery.clear();
        self.aggregateQuery = ::std::option::Option::None;
        self.bucket.clear();
        self.doc.clear();
        self.relatedSearch.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BillingConfig {
    // message fields
    pub carrierBillingConfig: ::protobuf::SingularPtrField<CarrierBillingConfig>,
    pub maxIabApiVersion: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BillingConfig {
    pub fn new() -> BillingConfig {
        ::std::default::Default::default()
    }

    // optional int32 maxIabApiVersion = 2;

    pub fn get_maxIabApiVersion(&self) -> i32 {
        self.maxIabApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for BillingConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierBillingConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierBillingConfig, _>(wire_type, is, &mut self.carrierBillingConfig)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxIabApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.carrierBillingConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.maxIabApiVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.carrierBillingConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxIabApiVersion {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingConfig {
        BillingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingConfig>, _>(
                "carrierBillingConfig",
                |m: &BillingConfig| { &m.carrierBillingConfig },
                |m: &mut BillingConfig| { &mut m.carrierBillingConfig },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "maxIabApiVersion",
                |m: &BillingConfig| { &m.maxIabApiVersion },
                |m: &mut BillingConfig| { &mut m.maxIabApiVersion },
                BillingConfig::get_maxIabApiVersion,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BillingConfig>(
                "BillingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingConfig {
        static instance: ::protobuf::rt::Lazy<BillingConfig> = ::protobuf::rt::Lazy::INIT;
        instance.get(BillingConfig::new)
    }
}

impl ::protobuf::Clear for BillingConfig {
    fn clear(&mut self) {
        self.carrierBillingConfig.clear();
        self.maxIabApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingConfig {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CarrierBillingConfig {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub apiVersion: ::std::option::Option<i32>,
    pub provisioningUrl: ::protobuf::SingularField<::std::string::String>,
    pub credentialsUrl: ::protobuf::SingularField<::std::string::String>,
    pub tosRequired: ::std::option::Option<bool>,
    pub perTransactionCredentialsRequired: ::std::option::Option<bool>,
    pub sendSubscriberIdWithCarrierBillingRequests: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CarrierBillingConfig {
    pub fn new() -> CarrierBillingConfig {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string name = 2;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 apiVersion = 3;

    pub fn get_apiVersion(&self) -> i32 {
        self.apiVersion.unwrap_or(0)
    }

    // optional string provisioningUrl = 4;

    pub fn get_provisioningUrl(&self) -> &str {
        match self.provisioningUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string credentialsUrl = 5;

    pub fn get_credentialsUrl(&self) -> &str {
        match self.credentialsUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool tosRequired = 6;

    pub fn get_tosRequired(&self) -> bool {
        self.tosRequired.unwrap_or(false)
    }

    // optional bool perTransactionCredentialsRequired = 7;

    pub fn get_perTransactionCredentialsRequired(&self) -> bool {
        self.perTransactionCredentialsRequired.unwrap_or(false)
    }

    // optional bool sendSubscriberIdWithCarrierBillingRequests = 8;

    pub fn get_sendSubscriberIdWithCarrierBillingRequests(&self) -> bool {
        self.sendSubscriberIdWithCarrierBillingRequests.unwrap_or(false)
    }
}

impl ::protobuf::Message for CarrierBillingConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.apiVersion = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.provisioningUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.credentialsUrl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosRequired = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perTransactionCredentialsRequired = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.apiVersion {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.provisioningUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.credentialsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.tosRequired {
            my_size += 2;
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            my_size += 2;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.apiVersion {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.provisioningUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.credentialsUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.tosRequired {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingConfig {
        CarrierBillingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "id",
                |m: &CarrierBillingConfig| { &m.id },
                |m: &mut CarrierBillingConfig| { &mut m.id },
                CarrierBillingConfig::get_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &CarrierBillingConfig| { &m.name },
                |m: &mut CarrierBillingConfig| { &mut m.name },
                CarrierBillingConfig::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "apiVersion",
                |m: &CarrierBillingConfig| { &m.apiVersion },
                |m: &mut CarrierBillingConfig| { &mut m.apiVersion },
                CarrierBillingConfig::get_apiVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "provisioningUrl",
                |m: &CarrierBillingConfig| { &m.provisioningUrl },
                |m: &mut CarrierBillingConfig| { &mut m.provisioningUrl },
                CarrierBillingConfig::get_provisioningUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "credentialsUrl",
                |m: &CarrierBillingConfig| { &m.credentialsUrl },
                |m: &mut CarrierBillingConfig| { &mut m.credentialsUrl },
                CarrierBillingConfig::get_credentialsUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "tosRequired",
                |m: &CarrierBillingConfig| { &m.tosRequired },
                |m: &mut CarrierBillingConfig| { &mut m.tosRequired },
                CarrierBillingConfig::get_tosRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "perTransactionCredentialsRequired",
                |m: &CarrierBillingConfig| { &m.perTransactionCredentialsRequired },
                |m: &mut CarrierBillingConfig| { &mut m.perTransactionCredentialsRequired },
                CarrierBillingConfig::get_perTransactionCredentialsRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "sendSubscriberIdWithCarrierBillingRequests",
                |m: &CarrierBillingConfig| { &m.sendSubscriberIdWithCarrierBillingRequests },
                |m: &mut CarrierBillingConfig| { &mut m.sendSubscriberIdWithCarrierBillingRequests },
                CarrierBillingConfig::get_sendSubscriberIdWithCarrierBillingRequests,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CarrierBillingConfig>(
                "CarrierBillingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingConfig {
        static instance: ::protobuf::rt::Lazy<CarrierBillingConfig> = ::protobuf::rt::Lazy::INIT;
        instance.get(CarrierBillingConfig::new)
    }
}

impl ::protobuf::Clear for CarrierBillingConfig {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.apiVersion = ::std::option::Option::None;
        self.provisioningUrl.clear();
        self.credentialsUrl.clear();
        self.tosRequired = ::std::option::Option::None;
        self.perTransactionCredentialsRequired = ::std::option::Option::None;
        self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingConfig {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CorpusMetadata {
    // message fields
    pub backend: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub landingUrl: ::protobuf::SingularField<::std::string::String>,
    pub libraryName: ::protobuf::SingularField<::std::string::String>,
    pub recsWidgetUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CorpusMetadata {
    pub fn new() -> CorpusMetadata {
        ::std::default::Default::default()
    }

    // optional int32 backend = 1;

    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }

    // optional string name = 2;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string landingUrl = 3;

    pub fn get_landingUrl(&self) -> &str {
        match self.landingUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string libraryName = 4;

    pub fn get_libraryName(&self) -> &str {
        match self.libraryName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string recsWidgetUrl = 6;

    pub fn get_recsWidgetUrl(&self) -> &str {
        match self.recsWidgetUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CorpusMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.landingUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recsWidgetUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.landingUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.libraryName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.recsWidgetUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.backend {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.landingUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.libraryName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.recsWidgetUrl.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CorpusMetadata {
        CorpusMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "backend",
                |m: &CorpusMetadata| { &m.backend },
                |m: &mut CorpusMetadata| { &mut m.backend },
                CorpusMetadata::get_backend,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &CorpusMetadata| { &m.name },
                |m: &mut CorpusMetadata| { &mut m.name },
                CorpusMetadata::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "landingUrl",
                |m: &CorpusMetadata| { &m.landingUrl },
                |m: &mut CorpusMetadata| { &mut m.landingUrl },
                CorpusMetadata::get_landingUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "libraryName",
                |m: &CorpusMetadata| { &m.libraryName },
                |m: &mut CorpusMetadata| { &mut m.libraryName },
                CorpusMetadata::get_libraryName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "recsWidgetUrl",
                |m: &CorpusMetadata| { &m.recsWidgetUrl },
                |m: &mut CorpusMetadata| { &mut m.recsWidgetUrl },
                CorpusMetadata::get_recsWidgetUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CorpusMetadata>(
                "CorpusMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CorpusMetadata {
        static instance: ::protobuf::rt::Lazy<CorpusMetadata> = ::protobuf::rt::Lazy::INIT;
        instance.get(CorpusMetadata::new)
    }
}

impl ::protobuf::Clear for CorpusMetadata {
    fn clear(&mut self) {
        self.backend = ::std::option::Option::None;
        self.name.clear();
        self.landingUrl.clear();
        self.libraryName.clear();
        self.recsWidgetUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CorpusMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CorpusMetadata {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct Experiments {
    // message fields
    pub experimentId: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl Experiments {
    pub fn new() -> Experiments {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Experiments {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.experimentId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.experimentId {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.experimentId {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Experiments {
        Experiments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "experimentId",
                |m: &Experiments| { &m.experimentId },
                |m: &mut Experiments| { &mut m.experimentId },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Experiments>(
                "Experiments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Experiments {
        static instance: ::protobuf::rt::Lazy<Experiments> = ::protobuf::rt::Lazy::INIT;
        instance.get(Experiments::new)
    }
}

impl ::protobuf::Clear for Experiments {
    fn clear(&mut self) {
        self.experimentId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Experiments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Experiments {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SelfUpdateConfig {
    // message fields
    pub latestClientVersionCode: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SelfUpdateConfig {
    pub fn new() -> SelfUpdateConfig {
        ::std::default::Default::default()
    }

    // optional int32 latestClientVersionCode = 1;

    pub fn get_latestClientVersionCode(&self) -> i32 {
        self.latestClientVersionCode.unwrap_or(0)
    }
}

impl ::protobuf::Message for SelfUpdateConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.latestClientVersionCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.latestClientVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.latestClientVersionCode {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfUpdateConfig {
        SelfUpdateConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "latestClientVersionCode",
                |m: &SelfUpdateConfig| { &m.latestClientVersionCode },
                |m: &mut SelfUpdateConfig| { &mut m.latestClientVersionCode },
                SelfUpdateConfig::get_latestClientVersionCode,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SelfUpdateConfig>(
                "SelfUpdateConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelfUpdateConfig {
        static instance: ::protobuf::rt::Lazy<SelfUpdateConfig> = ::protobuf::rt::Lazy::INIT;
        instance.get(SelfUpdateConfig::new)
    }
}

impl ::protobuf::Clear for SelfUpdateConfig {
    fn clear(&mut self) {
        self.latestClientVersionCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfUpdateConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfUpdateConfig {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct TocResponse {
    // message fields
    pub corpus: ::protobuf::RepeatedField<CorpusMetadata>,
    pub tosVersionDeprecated: ::std::option::Option<i32>,
    pub tosContent: ::protobuf::SingularField<::std::string::String>,
    pub homeUrl: ::protobuf::SingularField<::std::string::String>,
    pub experiments: ::protobuf::SingularPtrField<Experiments>,
    pub tosCheckboxTextMarketingEmails: ::protobuf::SingularField<::std::string::String>,
    pub tosToken: ::protobuf::SingularField<::std::string::String>,
    pub userSettings: ::protobuf::SingularPtrField<UserSettings>,
    pub iconOverrideUrl: ::protobuf::SingularField<::std::string::String>,
    pub selfUpdateConfig: ::protobuf::SingularPtrField<SelfUpdateConfig>,
    pub requiresUploadDeviceConfig: ::std::option::Option<bool>,
    pub billingConfig: ::protobuf::SingularPtrField<BillingConfig>,
    pub recsWidgetUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl TocResponse {
    pub fn new() -> TocResponse {
        ::std::default::Default::default()
    }

    // optional int32 tosVersionDeprecated = 2;

    pub fn get_tosVersionDeprecated(&self) -> i32 {
        self.tosVersionDeprecated.unwrap_or(0)
    }

    // optional string tosContent = 3;

    pub fn get_tosContent(&self) -> &str {
        match self.tosContent.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string homeUrl = 4;

    pub fn get_homeUrl(&self) -> &str {
        match self.homeUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string tosCheckboxTextMarketingEmails = 6;

    pub fn get_tosCheckboxTextMarketingEmails(&self) -> &str {
        match self.tosCheckboxTextMarketingEmails.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string tosToken = 7;

    pub fn get_tosToken(&self) -> &str {
        match self.tosToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string iconOverrideUrl = 9;

    pub fn get_iconOverrideUrl(&self) -> &str {
        match self.iconOverrideUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool requiresUploadDeviceConfig = 11;

    pub fn get_requiresUploadDeviceConfig(&self) -> bool {
        self.requiresUploadDeviceConfig.unwrap_or(false)
    }

    // optional string recsWidgetUrl = 13;

    pub fn get_recsWidgetUrl(&self) -> &str {
        match self.recsWidgetUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TocResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.corpus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.experiments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userSettings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selfUpdateConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.corpus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tosVersionDeprecated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosContent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.homeUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<Experiments, _>(wire_type, is, &mut self.experiments)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosCheckboxTextMarketingEmails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosToken)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<UserSettings, _>(wire_type, is, &mut self.userSettings)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iconOverrideUrl)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<SelfUpdateConfig, _>(wire_type, is, &mut self.selfUpdateConfig)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requiresUploadDeviceConfig = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<BillingConfig, _>(wire_type, is, &mut self.billingConfig)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recsWidgetUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.corpus {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.tosVersionDeprecated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tosContent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.homeUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.experiments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tosCheckboxTextMarketingEmails.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.tosToken.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.userSettings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.iconOverrideUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.selfUpdateConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.requiresUploadDeviceConfig {
            my_size += 2;
        }
        if let Some(v) = self.billingConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.recsWidgetUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.corpus {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.tosVersionDeprecated {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.tosContent.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.homeUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.experiments.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.tosCheckboxTextMarketingEmails.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.tosToken.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.userSettings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.iconOverrideUrl.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.selfUpdateConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.requiresUploadDeviceConfig {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.billingConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.recsWidgetUrl.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TocResponse {
        TocResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CorpusMetadata>>(
                "corpus",
                |m: &TocResponse| { &m.corpus },
                |m: &mut TocResponse| { &mut m.corpus },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "tosVersionDeprecated",
                |m: &TocResponse| { &m.tosVersionDeprecated },
                |m: &mut TocResponse| { &mut m.tosVersionDeprecated },
                TocResponse::get_tosVersionDeprecated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tosContent",
                |m: &TocResponse| { &m.tosContent },
                |m: &mut TocResponse| { &mut m.tosContent },
                TocResponse::get_tosContent,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "homeUrl",
                |m: &TocResponse| { &m.homeUrl },
                |m: &mut TocResponse| { &mut m.homeUrl },
                TocResponse::get_homeUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Experiments>, _>(
                "experiments",
                |m: &TocResponse| { &m.experiments },
                |m: &mut TocResponse| { &mut m.experiments },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tosCheckboxTextMarketingEmails",
                |m: &TocResponse| { &m.tosCheckboxTextMarketingEmails },
                |m: &mut TocResponse| { &mut m.tosCheckboxTextMarketingEmails },
                TocResponse::get_tosCheckboxTextMarketingEmails,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tosToken",
                |m: &TocResponse| { &m.tosToken },
                |m: &mut TocResponse| { &mut m.tosToken },
                TocResponse::get_tosToken,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserSettings>, _>(
                "userSettings",
                |m: &TocResponse| { &m.userSettings },
                |m: &mut TocResponse| { &mut m.userSettings },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "iconOverrideUrl",
                |m: &TocResponse| { &m.iconOverrideUrl },
                |m: &mut TocResponse| { &mut m.iconOverrideUrl },
                TocResponse::get_iconOverrideUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfUpdateConfig>, _>(
                "selfUpdateConfig",
                |m: &TocResponse| { &m.selfUpdateConfig },
                |m: &mut TocResponse| { &mut m.selfUpdateConfig },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "requiresUploadDeviceConfig",
                |m: &TocResponse| { &m.requiresUploadDeviceConfig },
                |m: &mut TocResponse| { &mut m.requiresUploadDeviceConfig },
                TocResponse::get_requiresUploadDeviceConfig,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingConfig>, _>(
                "billingConfig",
                |m: &TocResponse| { &m.billingConfig },
                |m: &mut TocResponse| { &mut m.billingConfig },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "recsWidgetUrl",
                |m: &TocResponse| { &m.recsWidgetUrl },
                |m: &mut TocResponse| { &mut m.recsWidgetUrl },
                TocResponse::get_recsWidgetUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<TocResponse>(
                "TocResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TocResponse {
        static instance: ::protobuf::rt::Lazy<TocResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(TocResponse::new)
    }
}

impl ::protobuf::Clear for TocResponse {
    fn clear(&mut self) {
        self.corpus.clear();
        self.tosVersionDeprecated = ::std::option::Option::None;
        self.tosContent.clear();
        self.homeUrl.clear();
        self.experiments.clear();
        self.tosCheckboxTextMarketingEmails.clear();
        self.tosToken.clear();
        self.userSettings.clear();
        self.iconOverrideUrl.clear();
        self.selfUpdateConfig.clear();
        self.requiresUploadDeviceConfig = ::std::option::Option::None;
        self.billingConfig.clear();
        self.recsWidgetUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TocResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TocResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UserSettings {
    // message fields
    pub tosCheckboxMarketingEmailsOptedIn: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UserSettings {
    pub fn new() -> UserSettings {
        ::std::default::Default::default()
    }

    // optional bool tosCheckboxMarketingEmailsOptedIn = 1;

    pub fn get_tosCheckboxMarketingEmailsOptedIn(&self) -> bool {
        self.tosCheckboxMarketingEmailsOptedIn.unwrap_or(false)
    }
}

impl ::protobuf::Message for UserSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosCheckboxMarketingEmailsOptedIn = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tosCheckboxMarketingEmailsOptedIn {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tosCheckboxMarketingEmailsOptedIn {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSettings {
        UserSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "tosCheckboxMarketingEmailsOptedIn",
                |m: &UserSettings| { &m.tosCheckboxMarketingEmailsOptedIn },
                |m: &mut UserSettings| { &mut m.tosCheckboxMarketingEmailsOptedIn },
                UserSettings::get_tosCheckboxMarketingEmailsOptedIn,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<UserSettings>(
                "UserSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserSettings {
        static instance: ::protobuf::rt::Lazy<UserSettings> = ::protobuf::rt::Lazy::INIT;
        instance.get(UserSettings::new)
    }
}

impl ::protobuf::Clear for UserSettings {
    fn clear(&mut self) {
        self.tosCheckboxMarketingEmailsOptedIn = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSettings {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AcceptTosResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AcceptTosResponse {
    pub fn new() -> AcceptTosResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AcceptTosResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptTosResponse {
        AcceptTosResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<AcceptTosResponse>(
                "AcceptTosResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcceptTosResponse {
        static instance: ::protobuf::rt::Lazy<AcceptTosResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(AcceptTosResponse::new)
    }
}

impl ::protobuf::Clear for AcceptTosResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptTosResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptTosResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UploadDeviceConfigRequest {
    // message fields
    pub deviceConfiguration: ::protobuf::SingularPtrField<DeviceConfigurationProto>,
    pub manufacturer: ::protobuf::SingularField<::std::string::String>,
    pub gcmRegistrationId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UploadDeviceConfigRequest {
    pub fn new() -> UploadDeviceConfigRequest {
        ::std::default::Default::default()
    }

    // optional string manufacturer = 2;

    pub fn get_manufacturer(&self) -> &str {
        match self.manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string gcmRegistrationId = 3;

    pub fn get_gcmRegistrationId(&self) -> &str {
        match self.gcmRegistrationId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UploadDeviceConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.deviceConfiguration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<DeviceConfigurationProto, _>(wire_type, is, &mut self.deviceConfiguration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.manufacturer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gcmRegistrationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.gcmRegistrationId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.manufacturer.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.gcmRegistrationId.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadDeviceConfigRequest {
        UploadDeviceConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfigurationProto>, _>(
                "deviceConfiguration",
                |m: &UploadDeviceConfigRequest| { &m.deviceConfiguration },
                |m: &mut UploadDeviceConfigRequest| { &mut m.deviceConfiguration },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "manufacturer",
                |m: &UploadDeviceConfigRequest| { &m.manufacturer },
                |m: &mut UploadDeviceConfigRequest| { &mut m.manufacturer },
                UploadDeviceConfigRequest::get_manufacturer,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gcmRegistrationId",
                |m: &UploadDeviceConfigRequest| { &m.gcmRegistrationId },
                |m: &mut UploadDeviceConfigRequest| { &mut m.gcmRegistrationId },
                UploadDeviceConfigRequest::get_gcmRegistrationId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<UploadDeviceConfigRequest>(
                "UploadDeviceConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadDeviceConfigRequest {
        static instance: ::protobuf::rt::Lazy<UploadDeviceConfigRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(UploadDeviceConfigRequest::new)
    }
}

impl ::protobuf::Clear for UploadDeviceConfigRequest {
    fn clear(&mut self) {
        self.deviceConfiguration.clear();
        self.manufacturer.clear();
        self.gcmRegistrationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadDeviceConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadDeviceConfigRequest {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UploadDeviceConfigResponse {
    // message fields
    pub uploadDeviceConfigToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UploadDeviceConfigResponse {
    pub fn new() -> UploadDeviceConfigResponse {
        ::std::default::Default::default()
    }

    // optional string uploadDeviceConfigToken = 1;

    pub fn get_uploadDeviceConfigToken(&self) -> &str {
        match self.uploadDeviceConfigToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UploadDeviceConfigResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uploadDeviceConfigToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.uploadDeviceConfigToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.uploadDeviceConfigToken.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadDeviceConfigResponse {
        UploadDeviceConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "uploadDeviceConfigToken",
                |m: &UploadDeviceConfigResponse| { &m.uploadDeviceConfigToken },
                |m: &mut UploadDeviceConfigResponse| { &mut m.uploadDeviceConfigToken },
                UploadDeviceConfigResponse::get_uploadDeviceConfigToken,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<UploadDeviceConfigResponse>(
                "UploadDeviceConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadDeviceConfigResponse {
        static instance: ::protobuf::rt::Lazy<UploadDeviceConfigResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(UploadDeviceConfigResponse::new)
    }
}

impl ::protobuf::Clear for UploadDeviceConfigResponse {
    fn clear(&mut self) {
        self.uploadDeviceConfigToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadDeviceConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadDeviceConfigResponse {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AckNotificationsRequestProto {
    // message fields
    pub notificationId: ::protobuf::RepeatedField<::std::string::String>,
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    pub nackNotificationId: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AckNotificationsRequestProto {
    pub fn new() -> AckNotificationsRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AckNotificationsRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.notificationId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<SignatureHashProto, _>(wire_type, is, &mut self.signatureHash)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.nackNotificationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notificationId {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.nackNotificationId {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notificationId {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.signatureHash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.nackNotificationId {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckNotificationsRequestProto {
        AckNotificationsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationId",
                |m: &AckNotificationsRequestProto| { &m.notificationId },
                |m: &mut AckNotificationsRequestProto| { &mut m.notificationId },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>, _>(
                "signatureHash",
                |m: &AckNotificationsRequestProto| { &m.signatureHash },
                |m: &mut AckNotificationsRequestProto| { &mut m.signatureHash },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nackNotificationId",
                |m: &AckNotificationsRequestProto| { &m.nackNotificationId },
                |m: &mut AckNotificationsRequestProto| { &mut m.nackNotificationId },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AckNotificationsRequestProto>(
                "AckNotificationsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AckNotificationsRequestProto {
        static instance: ::protobuf::rt::Lazy<AckNotificationsRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(AckNotificationsRequestProto::new)
    }
}

impl ::protobuf::Clear for AckNotificationsRequestProto {
    fn clear(&mut self) {
        self.notificationId.clear();
        self.signatureHash.clear();
        self.nackNotificationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckNotificationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckNotificationsRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AckNotificationsResponseProto {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AckNotificationsResponseProto {
    pub fn new() -> AckNotificationsResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AckNotificationsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckNotificationsResponseProto {
        AckNotificationsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<AckNotificationsResponseProto>(
                "AckNotificationsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AckNotificationsResponseProto {
        static instance: ::protobuf::rt::Lazy<AckNotificationsResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(AckNotificationsResponseProto::new)
    }
}

impl ::protobuf::Clear for AckNotificationsResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckNotificationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckNotificationsResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AddressProto {
    // message fields
    pub address1: ::protobuf::SingularField<::std::string::String>,
    pub address2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub country: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub field_type: ::protobuf::SingularField<::std::string::String>,
    pub phone: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AddressProto {
    pub fn new() -> AddressProto {
        ::std::default::Default::default()
    }

    // optional string address1 = 1;

    pub fn get_address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string address2 = 2;

    pub fn get_address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string city = 3;

    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string state = 4;

    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string postalCode = 5;

    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string country = 6;

    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string name = 7;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string type = 8;

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string phone = 9;

    pub fn get_phone(&self) -> &str {
        match self.phone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AddressProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address2)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.phone.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address1.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.address2.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.city.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.postalCode.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.country.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.field_type.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.phone.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressProto {
        AddressProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "address1",
                |m: &AddressProto| { &m.address1 },
                |m: &mut AddressProto| { &mut m.address1 },
                AddressProto::get_address1,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "address2",
                |m: &AddressProto| { &m.address2 },
                |m: &mut AddressProto| { &mut m.address2 },
                AddressProto::get_address2,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "city",
                |m: &AddressProto| { &m.city },
                |m: &mut AddressProto| { &mut m.city },
                AddressProto::get_city,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "state",
                |m: &AddressProto| { &m.state },
                |m: &mut AddressProto| { &mut m.state },
                AddressProto::get_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "postalCode",
                |m: &AddressProto| { &m.postalCode },
                |m: &mut AddressProto| { &mut m.postalCode },
                AddressProto::get_postalCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "country",
                |m: &AddressProto| { &m.country },
                |m: &mut AddressProto| { &mut m.country },
                AddressProto::get_country,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &AddressProto| { &m.name },
                |m: &mut AddressProto| { &mut m.name },
                AddressProto::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "type",
                |m: &AddressProto| { &m.field_type },
                |m: &mut AddressProto| { &mut m.field_type },
                AddressProto::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "phone",
                |m: &AddressProto| { &m.phone },
                |m: &mut AddressProto| { &mut m.phone },
                AddressProto::get_phone,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AddressProto>(
                "AddressProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressProto {
        static instance: ::protobuf::rt::Lazy<AddressProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(AddressProto::new)
    }
}

impl ::protobuf::Clear for AddressProto {
    fn clear(&mut self) {
        self.address1.clear();
        self.address2.clear();
        self.city.clear();
        self.state.clear();
        self.postalCode.clear();
        self.country.clear();
        self.name.clear();
        self.field_type.clear();
        self.phone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AppDataProto {
    // message fields
    pub key: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AppDataProto {
    pub fn new() -> AppDataProto {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string value = 2;

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AppDataProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDataProto {
        AppDataProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "key",
                |m: &AppDataProto| { &m.key },
                |m: &mut AppDataProto| { &mut m.key },
                AppDataProto::get_key,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "value",
                |m: &AppDataProto| { &m.value },
                |m: &mut AppDataProto| { &mut m.value },
                AppDataProto::get_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AppDataProto>(
                "AppDataProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppDataProto {
        static instance: ::protobuf::rt::Lazy<AppDataProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(AppDataProto::new)
    }
}

impl ::protobuf::Clear for AppDataProto {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDataProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDataProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AppSuggestionProto {
    // message fields
    pub assetInfo: ::protobuf::SingularPtrField<ExternalAssetProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AppSuggestionProto {
    pub fn new() -> AppSuggestionProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AppSuggestionProto {
    fn is_initialized(&self) -> bool {
        for v in &self.assetInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalAssetProto, _>(wire_type, is, &mut self.assetInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppSuggestionProto {
        AppSuggestionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>, _>(
                "assetInfo",
                |m: &AppSuggestionProto| { &m.assetInfo },
                |m: &mut AppSuggestionProto| { &mut m.assetInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AppSuggestionProto>(
                "AppSuggestionProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppSuggestionProto {
        static instance: ::protobuf::rt::Lazy<AppSuggestionProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(AppSuggestionProto::new)
    }
}

impl ::protobuf::Clear for AppSuggestionProto {
    fn clear(&mut self) {
        self.assetInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppSuggestionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppSuggestionProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AssetIdentifierProto {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AssetIdentifierProto {
    pub fn new() -> AssetIdentifierProto {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string assetId = 3;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AssetIdentifierProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetIdentifierProto {
        AssetIdentifierProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &AssetIdentifierProto| { &m.packageName },
                |m: &mut AssetIdentifierProto| { &mut m.packageName },
                AssetIdentifierProto::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &AssetIdentifierProto| { &m.versionCode },
                |m: &mut AssetIdentifierProto| { &mut m.versionCode },
                AssetIdentifierProto::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &AssetIdentifierProto| { &m.assetId },
                |m: &mut AssetIdentifierProto| { &mut m.assetId },
                AssetIdentifierProto::get_assetId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AssetIdentifierProto>(
                "AssetIdentifierProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetIdentifierProto {
        static instance: ::protobuf::rt::Lazy<AssetIdentifierProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(AssetIdentifierProto::new)
    }
}

impl ::protobuf::Clear for AssetIdentifierProto {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetIdentifierProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIdentifierProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AssetsRequestProto {
    // message fields
    pub assetType: ::std::option::Option<i32>,
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub categoryId: ::protobuf::SingularField<::std::string::String>,
    pub assetId: ::protobuf::RepeatedField<::std::string::String>,
    pub retrieveVendingHistory: ::std::option::Option<bool>,
    pub retrieveExtendedInfo: ::std::option::Option<bool>,
    pub sortOrder: ::std::option::Option<i32>,
    pub startIndex: ::std::option::Option<i64>,
    pub numEntries: ::std::option::Option<i64>,
    pub viewFilter: ::std::option::Option<i32>,
    pub rankingType: ::protobuf::SingularField<::std::string::String>,
    pub retrieveCarrierChannel: ::std::option::Option<bool>,
    pub pendingDownloadAssetId: ::protobuf::RepeatedField<::std::string::String>,
    pub reconstructVendingHistory: ::std::option::Option<bool>,
    pub unfilteredResults: ::std::option::Option<bool>,
    pub badgeId: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AssetsRequestProto {
    pub fn new() -> AssetsRequestProto {
        ::std::default::Default::default()
    }

    // optional int32 assetType = 1;

    pub fn get_assetType(&self) -> i32 {
        self.assetType.unwrap_or(0)
    }

    // optional string query = 2;

    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string categoryId = 3;

    pub fn get_categoryId(&self) -> &str {
        match self.categoryId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool retrieveVendingHistory = 5;

    pub fn get_retrieveVendingHistory(&self) -> bool {
        self.retrieveVendingHistory.unwrap_or(false)
    }

    // optional bool retrieveExtendedInfo = 6;

    pub fn get_retrieveExtendedInfo(&self) -> bool {
        self.retrieveExtendedInfo.unwrap_or(false)
    }

    // optional int32 sortOrder = 7;

    pub fn get_sortOrder(&self) -> i32 {
        self.sortOrder.unwrap_or(0)
    }

    // optional int64 startIndex = 8;

    pub fn get_startIndex(&self) -> i64 {
        self.startIndex.unwrap_or(0)
    }

    // optional int64 numEntries = 9;

    pub fn get_numEntries(&self) -> i64 {
        self.numEntries.unwrap_or(0)
    }

    // optional int32 viewFilter = 10;

    pub fn get_viewFilter(&self) -> i32 {
        self.viewFilter.unwrap_or(0)
    }

    // optional string rankingType = 11;

    pub fn get_rankingType(&self) -> &str {
        match self.rankingType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool retrieveCarrierChannel = 12;

    pub fn get_retrieveCarrierChannel(&self) -> bool {
        self.retrieveCarrierChannel.unwrap_or(false)
    }

    // optional bool reconstructVendingHistory = 14;

    pub fn get_reconstructVendingHistory(&self) -> bool {
        self.reconstructVendingHistory.unwrap_or(false)
    }

    // optional bool unfilteredResults = 15;

    pub fn get_unfilteredResults(&self) -> bool {
        self.unfilteredResults.unwrap_or(false)
    }
}

impl ::protobuf::Message for AssetsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categoryId)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.assetId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retrieveVendingHistory = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retrieveExtendedInfo = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sortOrder = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startIndex = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numEntries = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.viewFilter = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rankingType)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retrieveCarrierChannel = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.pendingDownloadAssetId)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reconstructVendingHistory = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unfilteredResults = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.badgeId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.categoryId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.assetId {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.retrieveVendingHistory {
            my_size += 2;
        }
        if let Some(v) = self.retrieveExtendedInfo {
            my_size += 2;
        }
        if let Some(v) = self.sortOrder {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startIndex {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numEntries {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.viewFilter {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rankingType.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.retrieveCarrierChannel {
            my_size += 2;
        }
        for value in &self.pendingDownloadAssetId {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(v) = self.reconstructVendingHistory {
            my_size += 2;
        }
        if let Some(v) = self.unfilteredResults {
            my_size += 2;
        }
        for value in &self.badgeId {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.query.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.categoryId.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.assetId {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.retrieveVendingHistory {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.retrieveExtendedInfo {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.sortOrder {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.startIndex {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.numEntries {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.viewFilter {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.rankingType.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.retrieveCarrierChannel {
            os.write_bool(12, v)?;
        }
        for v in &self.pendingDownloadAssetId {
            os.write_string(13, &v)?;
        };
        if let Some(v) = self.reconstructVendingHistory {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.unfilteredResults {
            os.write_bool(15, v)?;
        }
        for v in &self.badgeId {
            os.write_string(16, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetsRequestProto {
        AssetsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "assetType",
                |m: &AssetsRequestProto| { &m.assetType },
                |m: &mut AssetsRequestProto| { &mut m.assetType },
                AssetsRequestProto::get_assetType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "query",
                |m: &AssetsRequestProto| { &m.query },
                |m: &mut AssetsRequestProto| { &mut m.query },
                AssetsRequestProto::get_query,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "categoryId",
                |m: &AssetsRequestProto| { &m.categoryId },
                |m: &mut AssetsRequestProto| { &mut m.categoryId },
                AssetsRequestProto::get_categoryId,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &AssetsRequestProto| { &m.assetId },
                |m: &mut AssetsRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "retrieveVendingHistory",
                |m: &AssetsRequestProto| { &m.retrieveVendingHistory },
                |m: &mut AssetsRequestProto| { &mut m.retrieveVendingHistory },
                AssetsRequestProto::get_retrieveVendingHistory,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "retrieveExtendedInfo",
                |m: &AssetsRequestProto| { &m.retrieveExtendedInfo },
                |m: &mut AssetsRequestProto| { &mut m.retrieveExtendedInfo },
                AssetsRequestProto::get_retrieveExtendedInfo,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "sortOrder",
                |m: &AssetsRequestProto| { &m.sortOrder },
                |m: &mut AssetsRequestProto| { &mut m.sortOrder },
                AssetsRequestProto::get_sortOrder,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "startIndex",
                |m: &AssetsRequestProto| { &m.startIndex },
                |m: &mut AssetsRequestProto| { &mut m.startIndex },
                AssetsRequestProto::get_startIndex,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "numEntries",
                |m: &AssetsRequestProto| { &m.numEntries },
                |m: &mut AssetsRequestProto| { &mut m.numEntries },
                AssetsRequestProto::get_numEntries,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "viewFilter",
                |m: &AssetsRequestProto| { &m.viewFilter },
                |m: &mut AssetsRequestProto| { &mut m.viewFilter },
                AssetsRequestProto::get_viewFilter,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "rankingType",
                |m: &AssetsRequestProto| { &m.rankingType },
                |m: &mut AssetsRequestProto| { &mut m.rankingType },
                AssetsRequestProto::get_rankingType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "retrieveCarrierChannel",
                |m: &AssetsRequestProto| { &m.retrieveCarrierChannel },
                |m: &mut AssetsRequestProto| { &mut m.retrieveCarrierChannel },
                AssetsRequestProto::get_retrieveCarrierChannel,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pendingDownloadAssetId",
                |m: &AssetsRequestProto| { &m.pendingDownloadAssetId },
                |m: &mut AssetsRequestProto| { &mut m.pendingDownloadAssetId },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "reconstructVendingHistory",
                |m: &AssetsRequestProto| { &m.reconstructVendingHistory },
                |m: &mut AssetsRequestProto| { &mut m.reconstructVendingHistory },
                AssetsRequestProto::get_reconstructVendingHistory,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "unfilteredResults",
                |m: &AssetsRequestProto| { &m.unfilteredResults },
                |m: &mut AssetsRequestProto| { &mut m.unfilteredResults },
                AssetsRequestProto::get_unfilteredResults,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "badgeId",
                |m: &AssetsRequestProto| { &m.badgeId },
                |m: &mut AssetsRequestProto| { &mut m.badgeId },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AssetsRequestProto>(
                "AssetsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetsRequestProto {
        static instance: ::protobuf::rt::Lazy<AssetsRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(AssetsRequestProto::new)
    }
}

impl ::protobuf::Clear for AssetsRequestProto {
    fn clear(&mut self) {
        self.assetType = ::std::option::Option::None;
        self.query.clear();
        self.categoryId.clear();
        self.assetId.clear();
        self.retrieveVendingHistory = ::std::option::Option::None;
        self.retrieveExtendedInfo = ::std::option::Option::None;
        self.sortOrder = ::std::option::Option::None;
        self.startIndex = ::std::option::Option::None;
        self.numEntries = ::std::option::Option::None;
        self.viewFilter = ::std::option::Option::None;
        self.rankingType.clear();
        self.retrieveCarrierChannel = ::std::option::Option::None;
        self.pendingDownloadAssetId.clear();
        self.reconstructVendingHistory = ::std::option::Option::None;
        self.unfilteredResults = ::std::option::Option::None;
        self.badgeId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetsRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct AssetsResponseProto {
    // message fields
    pub asset: ::protobuf::RepeatedField<ExternalAssetProto>,
    pub numTotalEntries: ::std::option::Option<i64>,
    pub correctedQuery: ::protobuf::SingularField<::std::string::String>,
    pub altAsset: ::protobuf::RepeatedField<ExternalAssetProto>,
    pub numCorrectedEntries: ::std::option::Option<i64>,
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub listType: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl AssetsResponseProto {
    pub fn new() -> AssetsResponseProto {
        ::std::default::Default::default()
    }

    // optional int64 numTotalEntries = 2;

    pub fn get_numTotalEntries(&self) -> i64 {
        self.numTotalEntries.unwrap_or(0)
    }

    // optional string correctedQuery = 3;

    pub fn get_correctedQuery(&self) -> &str {
        match self.correctedQuery.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 numCorrectedEntries = 5;

    pub fn get_numCorrectedEntries(&self) -> i64 {
        self.numCorrectedEntries.unwrap_or(0)
    }

    // optional string header = 6;

    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 listType = 7;

    pub fn get_listType(&self) -> i32 {
        self.listType.unwrap_or(0)
    }
}

impl ::protobuf::Message for AssetsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.altAsset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.asset)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numTotalEntries = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.correctedQuery)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.altAsset)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numCorrectedEntries = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.listType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.asset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numTotalEntries {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.correctedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.altAsset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numCorrectedEntries {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.listType {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.asset {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.numTotalEntries {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.correctedQuery.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.altAsset {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.numCorrectedEntries {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.header.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.listType {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetsResponseProto {
        AssetsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>>(
                "asset",
                |m: &AssetsResponseProto| { &m.asset },
                |m: &mut AssetsResponseProto| { &mut m.asset },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "numTotalEntries",
                |m: &AssetsResponseProto| { &m.numTotalEntries },
                |m: &mut AssetsResponseProto| { &mut m.numTotalEntries },
                AssetsResponseProto::get_numTotalEntries,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "correctedQuery",
                |m: &AssetsResponseProto| { &m.correctedQuery },
                |m: &mut AssetsResponseProto| { &mut m.correctedQuery },
                AssetsResponseProto::get_correctedQuery,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>>(
                "altAsset",
                |m: &AssetsResponseProto| { &m.altAsset },
                |m: &mut AssetsResponseProto| { &mut m.altAsset },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "numCorrectedEntries",
                |m: &AssetsResponseProto| { &m.numCorrectedEntries },
                |m: &mut AssetsResponseProto| { &mut m.numCorrectedEntries },
                AssetsResponseProto::get_numCorrectedEntries,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "header",
                |m: &AssetsResponseProto| { &m.header },
                |m: &mut AssetsResponseProto| { &mut m.header },
                AssetsResponseProto::get_header,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "listType",
                |m: &AssetsResponseProto| { &m.listType },
                |m: &mut AssetsResponseProto| { &mut m.listType },
                AssetsResponseProto::get_listType,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<AssetsResponseProto>(
                "AssetsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetsResponseProto {
        static instance: ::protobuf::rt::Lazy<AssetsResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(AssetsResponseProto::new)
    }
}

impl ::protobuf::Clear for AssetsResponseProto {
    fn clear(&mut self) {
        self.asset.clear();
        self.numTotalEntries = ::std::option::Option::None;
        self.correctedQuery.clear();
        self.altAsset.clear();
        self.numCorrectedEntries = ::std::option::Option::None;
        self.header.clear();
        self.listType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetsResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BillingEventRequestProto {
    // message fields
    pub eventType: ::std::option::Option<i32>,
    pub billingParametersId: ::protobuf::SingularField<::std::string::String>,
    pub resultSuccess: ::std::option::Option<bool>,
    pub clientMessage: ::protobuf::SingularField<::std::string::String>,
    pub carrierInstrument: ::protobuf::SingularPtrField<ExternalCarrierBillingInstrumentProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BillingEventRequestProto {
    pub fn new() -> BillingEventRequestProto {
        ::std::default::Default::default()
    }

    // optional int32 eventType = 1;

    pub fn get_eventType(&self) -> i32 {
        self.eventType.unwrap_or(0)
    }

    // optional string billingParametersId = 2;

    pub fn get_billingParametersId(&self) -> &str {
        match self.billingParametersId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool resultSuccess = 3;

    pub fn get_resultSuccess(&self) -> bool {
        self.resultSuccess.unwrap_or(false)
    }

    // optional string clientMessage = 4;

    pub fn get_clientMessage(&self) -> &str {
        match self.clientMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BillingEventRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eventType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingParametersId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resultSuccess = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientMessage)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalCarrierBillingInstrumentProto, _>(wire_type, is, &mut self.carrierInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.billingParametersId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.resultSuccess {
            my_size += 2;
        }
        if let Some(v) = self.clientMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.carrierInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.billingParametersId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.resultSuccess {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.clientMessage.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.carrierInstrument.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingEventRequestProto {
        BillingEventRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "eventType",
                |m: &BillingEventRequestProto| { &m.eventType },
                |m: &mut BillingEventRequestProto| { &mut m.eventType },
                BillingEventRequestProto::get_eventType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "billingParametersId",
                |m: &BillingEventRequestProto| { &m.billingParametersId },
                |m: &mut BillingEventRequestProto| { &mut m.billingParametersId },
                BillingEventRequestProto::get_billingParametersId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "resultSuccess",
                |m: &BillingEventRequestProto| { &m.resultSuccess },
                |m: &mut BillingEventRequestProto| { &mut m.resultSuccess },
                BillingEventRequestProto::get_resultSuccess,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "clientMessage",
                |m: &BillingEventRequestProto| { &m.clientMessage },
                |m: &mut BillingEventRequestProto| { &mut m.clientMessage },
                BillingEventRequestProto::get_clientMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCarrierBillingInstrumentProto>, _>(
                "carrierInstrument",
                |m: &BillingEventRequestProto| { &m.carrierInstrument },
                |m: &mut BillingEventRequestProto| { &mut m.carrierInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BillingEventRequestProto>(
                "BillingEventRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingEventRequestProto {
        static instance: ::protobuf::rt::Lazy<BillingEventRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(BillingEventRequestProto::new)
    }
}

impl ::protobuf::Clear for BillingEventRequestProto {
    fn clear(&mut self) {
        self.eventType = ::std::option::Option::None;
        self.billingParametersId.clear();
        self.resultSuccess = ::std::option::Option::None;
        self.clientMessage.clear();
        self.carrierInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingEventRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingEventRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BillingEventResponseProto {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BillingEventResponseProto {
    pub fn new() -> BillingEventResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BillingEventResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingEventResponseProto {
        BillingEventResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<BillingEventResponseProto>(
                "BillingEventResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingEventResponseProto {
        static instance: ::protobuf::rt::Lazy<BillingEventResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(BillingEventResponseProto::new)
    }
}

impl ::protobuf::Clear for BillingEventResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingEventResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingEventResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct BillingParameterProto {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub mncMcc: ::protobuf::RepeatedField<::std::string::String>,
    pub backendUrl: ::protobuf::RepeatedField<::std::string::String>,
    pub iconId: ::protobuf::SingularField<::std::string::String>,
    pub billingInstrumentType: ::std::option::Option<i32>,
    pub applicationId: ::protobuf::SingularField<::std::string::String>,
    pub tosUrl: ::protobuf::SingularField<::std::string::String>,
    pub instrumentTosRequired: ::std::option::Option<bool>,
    pub apiVersion: ::std::option::Option<i32>,
    pub perTransactionCredentialsRequired: ::std::option::Option<bool>,
    pub sendSubscriberIdWithCarrierBillingRequests: ::std::option::Option<bool>,
    pub deviceAssociationMethod: ::std::option::Option<i32>,
    pub userTokenRequestMessage: ::protobuf::SingularField<::std::string::String>,
    pub userTokenRequestAddress: ::protobuf::SingularField<::std::string::String>,
    pub passphraseRequired: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl BillingParameterProto {
    pub fn new() -> BillingParameterProto {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string name = 2;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string iconId = 5;

    pub fn get_iconId(&self) -> &str {
        match self.iconId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 billingInstrumentType = 6;

    pub fn get_billingInstrumentType(&self) -> i32 {
        self.billingInstrumentType.unwrap_or(0)
    }

    // optional string applicationId = 7;

    pub fn get_applicationId(&self) -> &str {
        match self.applicationId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string tosUrl = 8;

    pub fn get_tosUrl(&self) -> &str {
        match self.tosUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool instrumentTosRequired = 9;

    pub fn get_instrumentTosRequired(&self) -> bool {
        self.instrumentTosRequired.unwrap_or(false)
    }

    // optional int32 apiVersion = 10;

    pub fn get_apiVersion(&self) -> i32 {
        self.apiVersion.unwrap_or(0)
    }

    // optional bool perTransactionCredentialsRequired = 11;

    pub fn get_perTransactionCredentialsRequired(&self) -> bool {
        self.perTransactionCredentialsRequired.unwrap_or(false)
    }

    // optional bool sendSubscriberIdWithCarrierBillingRequests = 12;

    pub fn get_sendSubscriberIdWithCarrierBillingRequests(&self) -> bool {
        self.sendSubscriberIdWithCarrierBillingRequests.unwrap_or(false)
    }

    // optional int32 deviceAssociationMethod = 13;

    pub fn get_deviceAssociationMethod(&self) -> i32 {
        self.deviceAssociationMethod.unwrap_or(0)
    }

    // optional string userTokenRequestMessage = 14;

    pub fn get_userTokenRequestMessage(&self) -> &str {
        match self.userTokenRequestMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string userTokenRequestAddress = 15;

    pub fn get_userTokenRequestAddress(&self) -> &str {
        match self.userTokenRequestAddress.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool passphraseRequired = 16;

    pub fn get_passphraseRequired(&self) -> bool {
        self.passphraseRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for BillingParameterProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mncMcc)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.backendUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iconId)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingInstrumentType = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.applicationId)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosUrl)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.instrumentTosRequired = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.apiVersion = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perTransactionCredentialsRequired = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceAssociationMethod = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userTokenRequestMessage)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userTokenRequestAddress)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphraseRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.mncMcc {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.backendUrl {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.iconId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.billingInstrumentType {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.applicationId.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.tosUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.instrumentTosRequired {
            my_size += 2;
        }
        if let Some(v) = self.apiVersion {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            my_size += 2;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            my_size += 2;
        }
        if let Some(v) = self.deviceAssociationMethod {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.userTokenRequestMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.userTokenRequestAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.passphraseRequired {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.mncMcc {
            os.write_string(3, &v)?;
        };
        for v in &self.backendUrl {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.iconId.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.billingInstrumentType {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.applicationId.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.tosUrl.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.instrumentTosRequired {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.apiVersion {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.deviceAssociationMethod {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.userTokenRequestMessage.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.userTokenRequestAddress.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.passphraseRequired {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingParameterProto {
        BillingParameterProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "id",
                |m: &BillingParameterProto| { &m.id },
                |m: &mut BillingParameterProto| { &mut m.id },
                BillingParameterProto::get_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &BillingParameterProto| { &m.name },
                |m: &mut BillingParameterProto| { &mut m.name },
                BillingParameterProto::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mncMcc",
                |m: &BillingParameterProto| { &m.mncMcc },
                |m: &mut BillingParameterProto| { &mut m.mncMcc },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backendUrl",
                |m: &BillingParameterProto| { &m.backendUrl },
                |m: &mut BillingParameterProto| { &mut m.backendUrl },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "iconId",
                |m: &BillingParameterProto| { &m.iconId },
                |m: &mut BillingParameterProto| { &mut m.iconId },
                BillingParameterProto::get_iconId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "billingInstrumentType",
                |m: &BillingParameterProto| { &m.billingInstrumentType },
                |m: &mut BillingParameterProto| { &mut m.billingInstrumentType },
                BillingParameterProto::get_billingInstrumentType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "applicationId",
                |m: &BillingParameterProto| { &m.applicationId },
                |m: &mut BillingParameterProto| { &mut m.applicationId },
                BillingParameterProto::get_applicationId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tosUrl",
                |m: &BillingParameterProto| { &m.tosUrl },
                |m: &mut BillingParameterProto| { &mut m.tosUrl },
                BillingParameterProto::get_tosUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "instrumentTosRequired",
                |m: &BillingParameterProto| { &m.instrumentTosRequired },
                |m: &mut BillingParameterProto| { &mut m.instrumentTosRequired },
                BillingParameterProto::get_instrumentTosRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "apiVersion",
                |m: &BillingParameterProto| { &m.apiVersion },
                |m: &mut BillingParameterProto| { &mut m.apiVersion },
                BillingParameterProto::get_apiVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "perTransactionCredentialsRequired",
                |m: &BillingParameterProto| { &m.perTransactionCredentialsRequired },
                |m: &mut BillingParameterProto| { &mut m.perTransactionCredentialsRequired },
                BillingParameterProto::get_perTransactionCredentialsRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "sendSubscriberIdWithCarrierBillingRequests",
                |m: &BillingParameterProto| { &m.sendSubscriberIdWithCarrierBillingRequests },
                |m: &mut BillingParameterProto| { &mut m.sendSubscriberIdWithCarrierBillingRequests },
                BillingParameterProto::get_sendSubscriberIdWithCarrierBillingRequests,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "deviceAssociationMethod",
                |m: &BillingParameterProto| { &m.deviceAssociationMethod },
                |m: &mut BillingParameterProto| { &mut m.deviceAssociationMethod },
                BillingParameterProto::get_deviceAssociationMethod,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userTokenRequestMessage",
                |m: &BillingParameterProto| { &m.userTokenRequestMessage },
                |m: &mut BillingParameterProto| { &mut m.userTokenRequestMessage },
                BillingParameterProto::get_userTokenRequestMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userTokenRequestAddress",
                |m: &BillingParameterProto| { &m.userTokenRequestAddress },
                |m: &mut BillingParameterProto| { &mut m.userTokenRequestAddress },
                BillingParameterProto::get_userTokenRequestAddress,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "passphraseRequired",
                |m: &BillingParameterProto| { &m.passphraseRequired },
                |m: &mut BillingParameterProto| { &mut m.passphraseRequired },
                BillingParameterProto::get_passphraseRequired,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<BillingParameterProto>(
                "BillingParameterProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingParameterProto {
        static instance: ::protobuf::rt::Lazy<BillingParameterProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(BillingParameterProto::new)
    }
}

impl ::protobuf::Clear for BillingParameterProto {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.mncMcc.clear();
        self.backendUrl.clear();
        self.iconId.clear();
        self.billingInstrumentType = ::std::option::Option::None;
        self.applicationId.clear();
        self.tosUrl.clear();
        self.instrumentTosRequired = ::std::option::Option::None;
        self.apiVersion = ::std::option::Option::None;
        self.perTransactionCredentialsRequired = ::std::option::Option::None;
        self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::None;
        self.deviceAssociationMethod = ::std::option::Option::None;
        self.userTokenRequestMessage.clear();
        self.userTokenRequestAddress.clear();
        self.passphraseRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingParameterProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingParameterProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CarrierBillingCredentialsProto {
    // message fields
    pub credentials: ::protobuf::SingularField<::std::string::String>,
    pub credentialsTimeout: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CarrierBillingCredentialsProto {
    pub fn new() -> CarrierBillingCredentialsProto {
        ::std::default::Default::default()
    }

    // optional string credentials = 1;

    pub fn get_credentials(&self) -> &str {
        match self.credentials.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 credentialsTimeout = 2;

    pub fn get_credentialsTimeout(&self) -> i64 {
        self.credentialsTimeout.unwrap_or(0)
    }
}

impl ::protobuf::Message for CarrierBillingCredentialsProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.credentials)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.credentialsTimeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.credentials.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.credentialsTimeout {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.credentials.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.credentialsTimeout {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingCredentialsProto {
        CarrierBillingCredentialsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "credentials",
                |m: &CarrierBillingCredentialsProto| { &m.credentials },
                |m: &mut CarrierBillingCredentialsProto| { &mut m.credentials },
                CarrierBillingCredentialsProto::get_credentials,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "credentialsTimeout",
                |m: &CarrierBillingCredentialsProto| { &m.credentialsTimeout },
                |m: &mut CarrierBillingCredentialsProto| { &mut m.credentialsTimeout },
                CarrierBillingCredentialsProto::get_credentialsTimeout,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CarrierBillingCredentialsProto>(
                "CarrierBillingCredentialsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingCredentialsProto {
        static instance: ::protobuf::rt::Lazy<CarrierBillingCredentialsProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(CarrierBillingCredentialsProto::new)
    }
}

impl ::protobuf::Clear for CarrierBillingCredentialsProto {
    fn clear(&mut self) {
        self.credentials.clear();
        self.credentialsTimeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingCredentialsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingCredentialsProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CategoryProto {
    // message fields
    pub assetType: ::std::option::Option<i32>,
    pub categoryId: ::protobuf::SingularField<::std::string::String>,
    pub categoryDisplay: ::protobuf::SingularField<::std::string::String>,
    pub categorySubtitle: ::protobuf::SingularField<::std::string::String>,
    pub promotedAssetsNew: ::protobuf::RepeatedField<::std::string::String>,
    pub promotedAssetsHome: ::protobuf::RepeatedField<::std::string::String>,
    pub subCategories: ::protobuf::RepeatedField<CategoryProto>,
    pub promotedAssetsPaid: ::protobuf::RepeatedField<::std::string::String>,
    pub promotedAssetsFree: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CategoryProto {
    pub fn new() -> CategoryProto {
        ::std::default::Default::default()
    }

    // optional int32 assetType = 2;

    pub fn get_assetType(&self) -> i32 {
        self.assetType.unwrap_or(0)
    }

    // optional string categoryId = 3;

    pub fn get_categoryId(&self) -> &str {
        match self.categoryId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string categoryDisplay = 4;

    pub fn get_categoryDisplay(&self) -> &str {
        match self.categoryDisplay.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string categorySubtitle = 5;

    pub fn get_categorySubtitle(&self) -> &str {
        match self.categorySubtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CategoryProto {
    fn is_initialized(&self) -> bool {
        for v in &self.subCategories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetType = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categoryId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categoryDisplay)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categorySubtitle)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotedAssetsNew)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotedAssetsHome)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.subCategories)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotedAssetsPaid)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotedAssetsFree)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.categoryId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.categoryDisplay.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.categorySubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.promotedAssetsNew {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.promotedAssetsHome {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.subCategories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.promotedAssetsPaid {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.promotedAssetsFree {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetType {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.categoryId.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.categoryDisplay.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.categorySubtitle.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.promotedAssetsNew {
            os.write_string(6, &v)?;
        };
        for v in &self.promotedAssetsHome {
            os.write_string(7, &v)?;
        };
        for v in &self.subCategories {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.promotedAssetsPaid {
            os.write_string(9, &v)?;
        };
        for v in &self.promotedAssetsFree {
            os.write_string(10, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CategoryProto {
        CategoryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "assetType",
                |m: &CategoryProto| { &m.assetType },
                |m: &mut CategoryProto| { &mut m.assetType },
                CategoryProto::get_assetType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "categoryId",
                |m: &CategoryProto| { &m.categoryId },
                |m: &mut CategoryProto| { &mut m.categoryId },
                CategoryProto::get_categoryId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "categoryDisplay",
                |m: &CategoryProto| { &m.categoryDisplay },
                |m: &mut CategoryProto| { &mut m.categoryDisplay },
                CategoryProto::get_categoryDisplay,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "categorySubtitle",
                |m: &CategoryProto| { &m.categorySubtitle },
                |m: &mut CategoryProto| { &mut m.categorySubtitle },
                CategoryProto::get_categorySubtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotedAssetsNew",
                |m: &CategoryProto| { &m.promotedAssetsNew },
                |m: &mut CategoryProto| { &mut m.promotedAssetsNew },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotedAssetsHome",
                |m: &CategoryProto| { &m.promotedAssetsHome },
                |m: &mut CategoryProto| { &mut m.promotedAssetsHome },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CategoryProto>>(
                "subCategories",
                |m: &CategoryProto| { &m.subCategories },
                |m: &mut CategoryProto| { &mut m.subCategories },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotedAssetsPaid",
                |m: &CategoryProto| { &m.promotedAssetsPaid },
                |m: &mut CategoryProto| { &mut m.promotedAssetsPaid },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotedAssetsFree",
                |m: &CategoryProto| { &m.promotedAssetsFree },
                |m: &mut CategoryProto| { &mut m.promotedAssetsFree },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CategoryProto>(
                "CategoryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CategoryProto {
        static instance: ::protobuf::rt::Lazy<CategoryProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(CategoryProto::new)
    }
}

impl ::protobuf::Clear for CategoryProto {
    fn clear(&mut self) {
        self.assetType = ::std::option::Option::None;
        self.categoryId.clear();
        self.categoryDisplay.clear();
        self.categorySubtitle.clear();
        self.promotedAssetsNew.clear();
        self.promotedAssetsHome.clear();
        self.subCategories.clear();
        self.promotedAssetsPaid.clear();
        self.promotedAssetsFree.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CategoryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CheckForNotificationsRequestProto {
    // message fields
    pub alarmDuration: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CheckForNotificationsRequestProto {
    pub fn new() -> CheckForNotificationsRequestProto {
        ::std::default::Default::default()
    }

    // optional int64 alarmDuration = 1;

    pub fn get_alarmDuration(&self) -> i64 {
        self.alarmDuration.unwrap_or(0)
    }
}

impl ::protobuf::Message for CheckForNotificationsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.alarmDuration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.alarmDuration {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.alarmDuration {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckForNotificationsRequestProto {
        CheckForNotificationsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "alarmDuration",
                |m: &CheckForNotificationsRequestProto| { &m.alarmDuration },
                |m: &mut CheckForNotificationsRequestProto| { &mut m.alarmDuration },
                CheckForNotificationsRequestProto::get_alarmDuration,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CheckForNotificationsRequestProto>(
                "CheckForNotificationsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckForNotificationsRequestProto {
        static instance: ::protobuf::rt::Lazy<CheckForNotificationsRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(CheckForNotificationsRequestProto::new)
    }
}

impl ::protobuf::Clear for CheckForNotificationsRequestProto {
    fn clear(&mut self) {
        self.alarmDuration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckForNotificationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckForNotificationsRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CheckForNotificationsResponseProto {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CheckForNotificationsResponseProto {
    pub fn new() -> CheckForNotificationsResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckForNotificationsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckForNotificationsResponseProto {
        CheckForNotificationsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CheckForNotificationsResponseProto>(
                "CheckForNotificationsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckForNotificationsResponseProto {
        static instance: ::protobuf::rt::Lazy<CheckForNotificationsResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(CheckForNotificationsResponseProto::new)
    }
}

impl ::protobuf::Clear for CheckForNotificationsResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckForNotificationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckForNotificationsResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CheckLicenseRequestProto {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub nonce: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CheckLicenseRequestProto {
    pub fn new() -> CheckLicenseRequestProto {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 nonce = 3;

    pub fn get_nonce(&self) -> i64 {
        self.nonce.unwrap_or(0)
    }
}

impl ::protobuf::Message for CheckLicenseRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nonce {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.nonce {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckLicenseRequestProto {
        CheckLicenseRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &CheckLicenseRequestProto| { &m.packageName },
                |m: &mut CheckLicenseRequestProto| { &mut m.packageName },
                CheckLicenseRequestProto::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &CheckLicenseRequestProto| { &m.versionCode },
                |m: &mut CheckLicenseRequestProto| { &mut m.versionCode },
                CheckLicenseRequestProto::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "nonce",
                |m: &CheckLicenseRequestProto| { &m.nonce },
                |m: &mut CheckLicenseRequestProto| { &mut m.nonce },
                CheckLicenseRequestProto::get_nonce,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CheckLicenseRequestProto>(
                "CheckLicenseRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckLicenseRequestProto {
        static instance: ::protobuf::rt::Lazy<CheckLicenseRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(CheckLicenseRequestProto::new)
    }
}

impl ::protobuf::Clear for CheckLicenseRequestProto {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckLicenseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckLicenseRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CheckLicenseResponseProto {
    // message fields
    pub responseCode: ::std::option::Option<i32>,
    pub signedData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CheckLicenseResponseProto {
    pub fn new() -> CheckLicenseResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 responseCode = 1;

    pub fn get_responseCode(&self) -> i32 {
        self.responseCode.unwrap_or(0)
    }

    // optional string signedData = 2;

    pub fn get_signedData(&self) -> &str {
        match self.signedData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string signature = 3;

    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CheckLicenseResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.responseCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedData)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.responseCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signedData.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.responseCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.signedData.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckLicenseResponseProto {
        CheckLicenseResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "responseCode",
                |m: &CheckLicenseResponseProto| { &m.responseCode },
                |m: &mut CheckLicenseResponseProto| { &mut m.responseCode },
                CheckLicenseResponseProto::get_responseCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signedData",
                |m: &CheckLicenseResponseProto| { &m.signedData },
                |m: &mut CheckLicenseResponseProto| { &mut m.signedData },
                CheckLicenseResponseProto::get_signedData,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signature",
                |m: &CheckLicenseResponseProto| { &m.signature },
                |m: &mut CheckLicenseResponseProto| { &mut m.signature },
                CheckLicenseResponseProto::get_signature,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CheckLicenseResponseProto>(
                "CheckLicenseResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckLicenseResponseProto {
        static instance: ::protobuf::rt::Lazy<CheckLicenseResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(CheckLicenseResponseProto::new)
    }
}

impl ::protobuf::Clear for CheckLicenseResponseProto {
    fn clear(&mut self) {
        self.responseCode = ::std::option::Option::None;
        self.signedData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckLicenseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckLicenseResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CommentsRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub startIndex: ::std::option::Option<i64>,
    pub numEntries: ::std::option::Option<i64>,
    pub shouldReturnSelfComment: ::std::option::Option<bool>,
    pub assetReferrer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CommentsRequestProto {
    pub fn new() -> CommentsRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 startIndex = 2;

    pub fn get_startIndex(&self) -> i64 {
        self.startIndex.unwrap_or(0)
    }

    // optional int64 numEntries = 3;

    pub fn get_numEntries(&self) -> i64 {
        self.numEntries.unwrap_or(0)
    }

    // optional bool shouldReturnSelfComment = 4;

    pub fn get_shouldReturnSelfComment(&self) -> bool {
        self.shouldReturnSelfComment.unwrap_or(false)
    }

    // optional string assetReferrer = 5;

    pub fn get_assetReferrer(&self) -> &str {
        match self.assetReferrer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommentsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numEntries = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shouldReturnSelfComment = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetReferrer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.startIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numEntries {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shouldReturnSelfComment {
            my_size += 2;
        }
        if let Some(v) = self.assetReferrer.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.startIndex {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.numEntries {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.shouldReturnSelfComment {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.assetReferrer.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommentsRequestProto {
        CommentsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &CommentsRequestProto| { &m.assetId },
                |m: &mut CommentsRequestProto| { &mut m.assetId },
                CommentsRequestProto::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "startIndex",
                |m: &CommentsRequestProto| { &m.startIndex },
                |m: &mut CommentsRequestProto| { &mut m.startIndex },
                CommentsRequestProto::get_startIndex,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "numEntries",
                |m: &CommentsRequestProto| { &m.numEntries },
                |m: &mut CommentsRequestProto| { &mut m.numEntries },
                CommentsRequestProto::get_numEntries,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "shouldReturnSelfComment",
                |m: &CommentsRequestProto| { &m.shouldReturnSelfComment },
                |m: &mut CommentsRequestProto| { &mut m.shouldReturnSelfComment },
                CommentsRequestProto::get_shouldReturnSelfComment,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetReferrer",
                |m: &CommentsRequestProto| { &m.assetReferrer },
                |m: &mut CommentsRequestProto| { &mut m.assetReferrer },
                CommentsRequestProto::get_assetReferrer,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CommentsRequestProto>(
                "CommentsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommentsRequestProto {
        static instance: ::protobuf::rt::Lazy<CommentsRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(CommentsRequestProto::new)
    }
}

impl ::protobuf::Clear for CommentsRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.startIndex = ::std::option::Option::None;
        self.numEntries = ::std::option::Option::None;
        self.shouldReturnSelfComment = ::std::option::Option::None;
        self.assetReferrer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommentsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommentsRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CommentsResponseProto {
    // message fields
    pub comment: ::protobuf::RepeatedField<ExternalCommentProto>,
    pub numTotalEntries: ::std::option::Option<i64>,
    pub selfComment: ::protobuf::SingularPtrField<ExternalCommentProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CommentsResponseProto {
    pub fn new() -> CommentsResponseProto {
        ::std::default::Default::default()
    }

    // optional int64 numTotalEntries = 2;

    pub fn get_numTotalEntries(&self) -> i64 {
        self.numTotalEntries.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommentsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.comment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selfComment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.comment)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numTotalEntries = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalCommentProto, _>(wire_type, is, &mut self.selfComment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.comment {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numTotalEntries {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.selfComment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.comment {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.numTotalEntries {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.selfComment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommentsResponseProto {
        CommentsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCommentProto>>(
                "comment",
                |m: &CommentsResponseProto| { &m.comment },
                |m: &mut CommentsResponseProto| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "numTotalEntries",
                |m: &CommentsResponseProto| { &m.numTotalEntries },
                |m: &mut CommentsResponseProto| { &mut m.numTotalEntries },
                CommentsResponseProto::get_numTotalEntries,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCommentProto>, _>(
                "selfComment",
                |m: &CommentsResponseProto| { &m.selfComment },
                |m: &mut CommentsResponseProto| { &mut m.selfComment },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CommentsResponseProto>(
                "CommentsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommentsResponseProto {
        static instance: ::protobuf::rt::Lazy<CommentsResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(CommentsResponseProto::new)
    }
}

impl ::protobuf::Clear for CommentsResponseProto {
    fn clear(&mut self) {
        self.comment.clear();
        self.numTotalEntries = ::std::option::Option::None;
        self.selfComment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommentsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommentsResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ContentSyncRequestProto {
    // message fields
    pub incremental: ::std::option::Option<bool>,
    // assetinstallstate: <group>
    // systemapp: <group>
    pub sideloadedAppCount: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ContentSyncRequestProto {
    pub fn new() -> ContentSyncRequestProto {
        ::std::default::Default::default()
    }

    // optional bool incremental = 1;

    pub fn get_incremental(&self) -> bool {
        self.incremental.unwrap_or(false)
    }

    // optional int32 sideloadedAppCount = 14;

    pub fn get_sideloadedAppCount(&self) -> i32 {
        self.sideloadedAppCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for ContentSyncRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incremental = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sideloadedAppCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.incremental {
            my_size += 2;
        }
        if let Some(v) = self.sideloadedAppCount {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.incremental {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.sideloadedAppCount {
            os.write_int32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSyncRequestProto {
        ContentSyncRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "incremental",
                |m: &ContentSyncRequestProto| { &m.incremental },
                |m: &mut ContentSyncRequestProto| { &mut m.incremental },
                ContentSyncRequestProto::get_incremental,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "sideloadedAppCount",
                |m: &ContentSyncRequestProto| { &m.sideloadedAppCount },
                |m: &mut ContentSyncRequestProto| { &mut m.sideloadedAppCount },
                ContentSyncRequestProto::get_sideloadedAppCount,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ContentSyncRequestProto>(
                "ContentSyncRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSyncRequestProto {
        static instance: ::protobuf::rt::Lazy<ContentSyncRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ContentSyncRequestProto::new)
    }
}

impl ::protobuf::Clear for ContentSyncRequestProto {
    fn clear(&mut self) {
        self.incremental = ::std::option::Option::None;
        self.sideloadedAppCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSyncRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSyncRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ContentSyncRequestProto_AssetInstallState {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub assetState: ::std::option::Option<i32>,
    pub installTime: ::std::option::Option<i64>,
    pub uninstallTime: ::std::option::Option<i64>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub assetReferrer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ContentSyncRequestProto_AssetInstallState {
    pub fn new() -> ContentSyncRequestProto_AssetInstallState {
        ::std::default::Default::default()
    }

    // optional string assetId = 3;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 assetState = 4;

    pub fn get_assetState(&self) -> i32 {
        self.assetState.unwrap_or(0)
    }

    // optional int64 installTime = 5;

    pub fn get_installTime(&self) -> i64 {
        self.installTime.unwrap_or(0)
    }

    // optional int64 uninstallTime = 6;

    pub fn get_uninstallTime(&self) -> i64 {
        self.uninstallTime.unwrap_or(0)
    }

    // optional string packageName = 7;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 versionCode = 8;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string assetReferrer = 9;

    pub fn get_assetReferrer(&self) -> &str {
        match self.assetReferrer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContentSyncRequestProto_AssetInstallState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetState = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.installTime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.uninstallTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetReferrer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.assetState {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.installTime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.uninstallTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assetReferrer.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.assetState {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.installTime {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.uninstallTime {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.assetReferrer.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSyncRequestProto_AssetInstallState {
        ContentSyncRequestProto_AssetInstallState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.assetId },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.assetId },
                ContentSyncRequestProto_AssetInstallState::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "assetState",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.assetState },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.assetState },
                ContentSyncRequestProto_AssetInstallState::get_assetState,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "installTime",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.installTime },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.installTime },
                ContentSyncRequestProto_AssetInstallState::get_installTime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "uninstallTime",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.uninstallTime },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.uninstallTime },
                ContentSyncRequestProto_AssetInstallState::get_uninstallTime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.packageName },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.packageName },
                ContentSyncRequestProto_AssetInstallState::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.versionCode },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.versionCode },
                ContentSyncRequestProto_AssetInstallState::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetReferrer",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.assetReferrer },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.assetReferrer },
                ContentSyncRequestProto_AssetInstallState::get_assetReferrer,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ContentSyncRequestProto_AssetInstallState>(
                "ContentSyncRequestProto_AssetInstallState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSyncRequestProto_AssetInstallState {
        static instance: ::protobuf::rt::Lazy<ContentSyncRequestProto_AssetInstallState> = ::protobuf::rt::Lazy::INIT;
        instance.get(ContentSyncRequestProto_AssetInstallState::new)
    }
}

impl ::protobuf::Clear for ContentSyncRequestProto_AssetInstallState {
    fn clear(&mut self) {
        self.assetId.clear();
        self.assetState = ::std::option::Option::None;
        self.installTime = ::std::option::Option::None;
        self.uninstallTime = ::std::option::Option::None;
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.assetReferrer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSyncRequestProto_AssetInstallState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSyncRequestProto_AssetInstallState {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ContentSyncRequestProto_SystemApp {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub certificateHash: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ContentSyncRequestProto_SystemApp {
    pub fn new() -> ContentSyncRequestProto_SystemApp {
        ::std::default::Default::default()
    }

    // optional string packageName = 11;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 versionCode = 12;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }
}

impl ::protobuf::Message for ContentSyncRequestProto_SystemApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.certificateHash {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(12, v)?;
        }
        for v in &self.certificateHash {
            os.write_string(13, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSyncRequestProto_SystemApp {
        ContentSyncRequestProto_SystemApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &ContentSyncRequestProto_SystemApp| { &m.packageName },
                |m: &mut ContentSyncRequestProto_SystemApp| { &mut m.packageName },
                ContentSyncRequestProto_SystemApp::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &ContentSyncRequestProto_SystemApp| { &m.versionCode },
                |m: &mut ContentSyncRequestProto_SystemApp| { &mut m.versionCode },
                ContentSyncRequestProto_SystemApp::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificateHash",
                |m: &ContentSyncRequestProto_SystemApp| { &m.certificateHash },
                |m: &mut ContentSyncRequestProto_SystemApp| { &mut m.certificateHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ContentSyncRequestProto_SystemApp>(
                "ContentSyncRequestProto_SystemApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSyncRequestProto_SystemApp {
        static instance: ::protobuf::rt::Lazy<ContentSyncRequestProto_SystemApp> = ::protobuf::rt::Lazy::INIT;
        instance.get(ContentSyncRequestProto_SystemApp::new)
    }
}

impl ::protobuf::Clear for ContentSyncRequestProto_SystemApp {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.certificateHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSyncRequestProto_SystemApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSyncRequestProto_SystemApp {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ContentSyncResponseProto {
    // message fields
    pub numUpdatesAvailable: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ContentSyncResponseProto {
    pub fn new() -> ContentSyncResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 numUpdatesAvailable = 1;

    pub fn get_numUpdatesAvailable(&self) -> i32 {
        self.numUpdatesAvailable.unwrap_or(0)
    }
}

impl ::protobuf::Message for ContentSyncResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numUpdatesAvailable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.numUpdatesAvailable {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.numUpdatesAvailable {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSyncResponseProto {
        ContentSyncResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "numUpdatesAvailable",
                |m: &ContentSyncResponseProto| { &m.numUpdatesAvailable },
                |m: &mut ContentSyncResponseProto| { &mut m.numUpdatesAvailable },
                ContentSyncResponseProto::get_numUpdatesAvailable,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ContentSyncResponseProto>(
                "ContentSyncResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSyncResponseProto {
        static instance: ::protobuf::rt::Lazy<ContentSyncResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ContentSyncResponseProto::new)
    }
}

impl ::protobuf::Clear for ContentSyncResponseProto {
    fn clear(&mut self) {
        self.numUpdatesAvailable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSyncResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSyncResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DataMessageProto {
    // message fields
    pub category: ::protobuf::SingularField<::std::string::String>,
    pub appData: ::protobuf::RepeatedField<AppDataProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DataMessageProto {
    pub fn new() -> DataMessageProto {
        ::std::default::Default::default()
    }

    // optional string category = 1;

    pub fn get_category(&self) -> &str {
        match self.category.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DataMessageProto {
    fn is_initialized(&self) -> bool {
        for v in &self.appData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.appData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.category.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.appData {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.category.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.appData {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessageProto {
        DataMessageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "category",
                |m: &DataMessageProto| { &m.category },
                |m: &mut DataMessageProto| { &mut m.category },
                DataMessageProto::get_category,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppDataProto>>(
                "appData",
                |m: &DataMessageProto| { &m.appData },
                |m: &mut DataMessageProto| { &mut m.appData },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DataMessageProto>(
                "DataMessageProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessageProto {
        static instance: ::protobuf::rt::Lazy<DataMessageProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(DataMessageProto::new)
    }
}

impl ::protobuf::Clear for DataMessageProto {
    fn clear(&mut self) {
        self.category.clear();
        self.appData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessageProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct DownloadInfoProto {
    // message fields
    pub apkSize: ::std::option::Option<i64>,
    pub additionalFile: ::protobuf::RepeatedField<FileMetadataProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl DownloadInfoProto {
    pub fn new() -> DownloadInfoProto {
        ::std::default::Default::default()
    }

    // optional int64 apkSize = 1;

    pub fn get_apkSize(&self) -> i64 {
        self.apkSize.unwrap_or(0)
    }
}

impl ::protobuf::Message for DownloadInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.additionalFile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.apkSize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.additionalFile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.apkSize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.additionalFile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.apkSize {
            os.write_int64(1, v)?;
        }
        for v in &self.additionalFile {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadInfoProto {
        DownloadInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "apkSize",
                |m: &DownloadInfoProto| { &m.apkSize },
                |m: &mut DownloadInfoProto| { &mut m.apkSize },
                DownloadInfoProto::get_apkSize,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileMetadataProto>>(
                "additionalFile",
                |m: &DownloadInfoProto| { &m.additionalFile },
                |m: &mut DownloadInfoProto| { &mut m.additionalFile },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<DownloadInfoProto>(
                "DownloadInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownloadInfoProto {
        static instance: ::protobuf::rt::Lazy<DownloadInfoProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(DownloadInfoProto::new)
    }
}

impl ::protobuf::Clear for DownloadInfoProto {
    fn clear(&mut self) {
        self.apkSize = ::std::option::Option::None;
        self.additionalFile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownloadInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadInfoProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalAssetProto {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub assetType: ::std::option::Option<i32>,
    pub owner: ::protobuf::SingularField<::std::string::String>,
    pub version: ::protobuf::SingularField<::std::string::String>,
    pub price: ::protobuf::SingularField<::std::string::String>,
    pub averageRating: ::protobuf::SingularField<::std::string::String>,
    pub numRatings: ::std::option::Option<i64>,
    // purchaseinformation: <group>
    // extendedinfo: <group>
    pub ownerId: ::protobuf::SingularField<::std::string::String>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub bundledAsset: ::std::option::Option<bool>,
    pub priceCurrency: ::protobuf::SingularField<::std::string::String>,
    pub priceMicros: ::std::option::Option<i64>,
    pub filterReason: ::protobuf::SingularField<::std::string::String>,
    pub actualSellerPrice: ::protobuf::SingularField<::std::string::String>,
    pub appBadge: ::protobuf::RepeatedField<ExternalBadgeProto>,
    pub ownerBadge: ::protobuf::RepeatedField<ExternalBadgeProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalAssetProto {
    pub fn new() -> ExternalAssetProto {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string title = 2;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 assetType = 3;

    pub fn get_assetType(&self) -> i32 {
        self.assetType.unwrap_or(0)
    }

    // optional string owner = 4;

    pub fn get_owner(&self) -> &str {
        match self.owner.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string version = 5;

    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string price = 6;

    pub fn get_price(&self) -> &str {
        match self.price.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string averageRating = 7;

    pub fn get_averageRating(&self) -> &str {
        match self.averageRating.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 numRatings = 8;

    pub fn get_numRatings(&self) -> i64 {
        self.numRatings.unwrap_or(0)
    }

    // optional string ownerId = 22;

    pub fn get_ownerId(&self) -> &str {
        match self.ownerId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string packageName = 24;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 versionCode = 25;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional bool bundledAsset = 29;

    pub fn get_bundledAsset(&self) -> bool {
        self.bundledAsset.unwrap_or(false)
    }

    // optional string priceCurrency = 32;

    pub fn get_priceCurrency(&self) -> &str {
        match self.priceCurrency.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 priceMicros = 33;

    pub fn get_priceMicros(&self) -> i64 {
        self.priceMicros.unwrap_or(0)
    }

    // optional string filterReason = 35;

    pub fn get_filterReason(&self) -> &str {
        match self.filterReason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string actualSellerPrice = 40;

    pub fn get_actualSellerPrice(&self) -> &str {
        match self.actualSellerPrice.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalAssetProto {
    fn is_initialized(&self) -> bool {
        for v in &self.appBadge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ownerBadge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetType = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.price)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.averageRating)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numRatings = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ownerId)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bundledAsset = ::std::option::Option::Some(tmp);
                },
                32 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.priceCurrency)?;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.priceMicros = ::std::option::Option::Some(tmp);
                },
                35 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filterReason)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.actualSellerPrice)?;
                },
                47 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.appBadge)?;
                },
                48 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.ownerBadge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.assetType {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.price.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.averageRating.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.numRatings {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ownerId.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bundledAsset {
            my_size += 3;
        }
        if let Some(v) = self.priceCurrency.as_ref() {
            my_size += ::protobuf::rt::string_size(32, &v);
        }
        if let Some(v) = self.priceMicros {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filterReason.as_ref() {
            my_size += ::protobuf::rt::string_size(35, &v);
        }
        if let Some(v) = self.actualSellerPrice.as_ref() {
            my_size += ::protobuf::rt::string_size(40, &v);
        }
        for value in &self.appBadge {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ownerBadge {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.assetType {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.owner.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.price.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.averageRating.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.numRatings {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.ownerId.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(24, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(25, v)?;
        }
        if let Some(v) = self.bundledAsset {
            os.write_bool(29, v)?;
        }
        if let Some(v) = self.priceCurrency.as_ref() {
            os.write_string(32, v)?;
        }
        if let Some(v) = self.priceMicros {
            os.write_int64(33, v)?;
        }
        if let Some(v) = self.filterReason.as_ref() {
            os.write_string(35, v)?;
        }
        if let Some(v) = self.actualSellerPrice.as_ref() {
            os.write_string(40, v)?;
        }
        for v in &self.appBadge {
            ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        };
        for v in &self.ownerBadge {
            ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalAssetProto {
        ExternalAssetProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "id",
                |m: &ExternalAssetProto| { &m.id },
                |m: &mut ExternalAssetProto| { &mut m.id },
                ExternalAssetProto::get_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &ExternalAssetProto| { &m.title },
                |m: &mut ExternalAssetProto| { &mut m.title },
                ExternalAssetProto::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "assetType",
                |m: &ExternalAssetProto| { &m.assetType },
                |m: &mut ExternalAssetProto| { &mut m.assetType },
                ExternalAssetProto::get_assetType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "owner",
                |m: &ExternalAssetProto| { &m.owner },
                |m: &mut ExternalAssetProto| { &mut m.owner },
                ExternalAssetProto::get_owner,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "version",
                |m: &ExternalAssetProto| { &m.version },
                |m: &mut ExternalAssetProto| { &mut m.version },
                ExternalAssetProto::get_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "price",
                |m: &ExternalAssetProto| { &m.price },
                |m: &mut ExternalAssetProto| { &mut m.price },
                ExternalAssetProto::get_price,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "averageRating",
                |m: &ExternalAssetProto| { &m.averageRating },
                |m: &mut ExternalAssetProto| { &mut m.averageRating },
                ExternalAssetProto::get_averageRating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "numRatings",
                |m: &ExternalAssetProto| { &m.numRatings },
                |m: &mut ExternalAssetProto| { &mut m.numRatings },
                ExternalAssetProto::get_numRatings,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "ownerId",
                |m: &ExternalAssetProto| { &m.ownerId },
                |m: &mut ExternalAssetProto| { &mut m.ownerId },
                ExternalAssetProto::get_ownerId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &ExternalAssetProto| { &m.packageName },
                |m: &mut ExternalAssetProto| { &mut m.packageName },
                ExternalAssetProto::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &ExternalAssetProto| { &m.versionCode },
                |m: &mut ExternalAssetProto| { &mut m.versionCode },
                ExternalAssetProto::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "bundledAsset",
                |m: &ExternalAssetProto| { &m.bundledAsset },
                |m: &mut ExternalAssetProto| { &mut m.bundledAsset },
                ExternalAssetProto::get_bundledAsset,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "priceCurrency",
                |m: &ExternalAssetProto| { &m.priceCurrency },
                |m: &mut ExternalAssetProto| { &mut m.priceCurrency },
                ExternalAssetProto::get_priceCurrency,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "priceMicros",
                |m: &ExternalAssetProto| { &m.priceMicros },
                |m: &mut ExternalAssetProto| { &mut m.priceMicros },
                ExternalAssetProto::get_priceMicros,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "filterReason",
                |m: &ExternalAssetProto| { &m.filterReason },
                |m: &mut ExternalAssetProto| { &mut m.filterReason },
                ExternalAssetProto::get_filterReason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "actualSellerPrice",
                |m: &ExternalAssetProto| { &m.actualSellerPrice },
                |m: &mut ExternalAssetProto| { &mut m.actualSellerPrice },
                ExternalAssetProto::get_actualSellerPrice,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalBadgeProto>>(
                "appBadge",
                |m: &ExternalAssetProto| { &m.appBadge },
                |m: &mut ExternalAssetProto| { &mut m.appBadge },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalBadgeProto>>(
                "ownerBadge",
                |m: &ExternalAssetProto| { &m.ownerBadge },
                |m: &mut ExternalAssetProto| { &mut m.ownerBadge },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalAssetProto>(
                "ExternalAssetProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalAssetProto {
        static instance: ::protobuf::rt::Lazy<ExternalAssetProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalAssetProto::new)
    }
}

impl ::protobuf::Clear for ExternalAssetProto {
    fn clear(&mut self) {
        self.id.clear();
        self.title.clear();
        self.assetType = ::std::option::Option::None;
        self.owner.clear();
        self.version.clear();
        self.price.clear();
        self.averageRating.clear();
        self.numRatings = ::std::option::Option::None;
        self.ownerId.clear();
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.bundledAsset = ::std::option::Option::None;
        self.priceCurrency.clear();
        self.priceMicros = ::std::option::Option::None;
        self.filterReason.clear();
        self.actualSellerPrice.clear();
        self.appBadge.clear();
        self.ownerBadge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalAssetProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalAssetProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalAssetProto_PurchaseInformation {
    // message fields
    pub purchaseTime: ::std::option::Option<i64>,
    pub refundTimeoutTime: ::std::option::Option<i64>,
    pub refundStartPolicy: ::std::option::Option<i32>,
    pub refundWindowDuration: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalAssetProto_PurchaseInformation {
    pub fn new() -> ExternalAssetProto_PurchaseInformation {
        ::std::default::Default::default()
    }

    // optional int64 purchaseTime = 10;

    pub fn get_purchaseTime(&self) -> i64 {
        self.purchaseTime.unwrap_or(0)
    }

    // optional int64 refundTimeoutTime = 11;

    pub fn get_refundTimeoutTime(&self) -> i64 {
        self.refundTimeoutTime.unwrap_or(0)
    }

    // optional int32 refundStartPolicy = 45;

    pub fn get_refundStartPolicy(&self) -> i32 {
        self.refundStartPolicy.unwrap_or(0)
    }

    // optional int64 refundWindowDuration = 46;

    pub fn get_refundWindowDuration(&self) -> i64 {
        self.refundWindowDuration.unwrap_or(0)
    }
}

impl ::protobuf::Message for ExternalAssetProto_PurchaseInformation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.purchaseTime = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutTime = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.refundStartPolicy = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundWindowDuration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.purchaseTime {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refundTimeoutTime {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refundStartPolicy {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refundWindowDuration {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.purchaseTime {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.refundTimeoutTime {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.refundStartPolicy {
            os.write_int32(45, v)?;
        }
        if let Some(v) = self.refundWindowDuration {
            os.write_int64(46, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalAssetProto_PurchaseInformation {
        ExternalAssetProto_PurchaseInformation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "purchaseTime",
                |m: &ExternalAssetProto_PurchaseInformation| { &m.purchaseTime },
                |m: &mut ExternalAssetProto_PurchaseInformation| { &mut m.purchaseTime },
                ExternalAssetProto_PurchaseInformation::get_purchaseTime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "refundTimeoutTime",
                |m: &ExternalAssetProto_PurchaseInformation| { &m.refundTimeoutTime },
                |m: &mut ExternalAssetProto_PurchaseInformation| { &mut m.refundTimeoutTime },
                ExternalAssetProto_PurchaseInformation::get_refundTimeoutTime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "refundStartPolicy",
                |m: &ExternalAssetProto_PurchaseInformation| { &m.refundStartPolicy },
                |m: &mut ExternalAssetProto_PurchaseInformation| { &mut m.refundStartPolicy },
                ExternalAssetProto_PurchaseInformation::get_refundStartPolicy,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "refundWindowDuration",
                |m: &ExternalAssetProto_PurchaseInformation| { &m.refundWindowDuration },
                |m: &mut ExternalAssetProto_PurchaseInformation| { &mut m.refundWindowDuration },
                ExternalAssetProto_PurchaseInformation::get_refundWindowDuration,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalAssetProto_PurchaseInformation>(
                "ExternalAssetProto_PurchaseInformation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalAssetProto_PurchaseInformation {
        static instance: ::protobuf::rt::Lazy<ExternalAssetProto_PurchaseInformation> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalAssetProto_PurchaseInformation::new)
    }
}

impl ::protobuf::Clear for ExternalAssetProto_PurchaseInformation {
    fn clear(&mut self) {
        self.purchaseTime = ::std::option::Option::None;
        self.refundTimeoutTime = ::std::option::Option::None;
        self.refundStartPolicy = ::std::option::Option::None;
        self.refundWindowDuration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalAssetProto_PurchaseInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalAssetProto_PurchaseInformation {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalAssetProto_ExtendedInfo {
    // message fields
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub downloadCount: ::std::option::Option<i64>,
    pub applicationPermissionId: ::protobuf::RepeatedField<::std::string::String>,
    pub requiredInstallationSize: ::std::option::Option<i64>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub category: ::protobuf::SingularField<::std::string::String>,
    pub forwardLocked: ::std::option::Option<bool>,
    pub contactEmail: ::protobuf::SingularField<::std::string::String>,
    pub everInstalledByUser: ::std::option::Option<bool>,
    pub downloadCountString: ::protobuf::SingularField<::std::string::String>,
    pub contactPhone: ::protobuf::SingularField<::std::string::String>,
    pub contactWebsite: ::protobuf::SingularField<::std::string::String>,
    pub nextPurchaseRefundable: ::std::option::Option<bool>,
    pub numScreenshots: ::std::option::Option<i32>,
    pub promotionalDescription: ::protobuf::SingularField<::std::string::String>,
    pub serverAssetState: ::std::option::Option<i32>,
    pub contentRatingLevel: ::std::option::Option<i32>,
    pub contentRatingString: ::protobuf::SingularField<::std::string::String>,
    pub recentChanges: ::protobuf::SingularField<::std::string::String>,
    // packagedependency: <group>
    pub videoLink: ::protobuf::SingularField<::std::string::String>,
    pub downloadInfo: ::protobuf::SingularPtrField<DownloadInfoProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalAssetProto_ExtendedInfo {
    pub fn new() -> ExternalAssetProto_ExtendedInfo {
        ::std::default::Default::default()
    }

    // optional string description = 13;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 downloadCount = 14;

    pub fn get_downloadCount(&self) -> i64 {
        self.downloadCount.unwrap_or(0)
    }

    // optional int64 requiredInstallationSize = 16;

    pub fn get_requiredInstallationSize(&self) -> i64 {
        self.requiredInstallationSize.unwrap_or(0)
    }

    // optional string packageName = 17;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string category = 18;

    pub fn get_category(&self) -> &str {
        match self.category.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool forwardLocked = 19;

    pub fn get_forwardLocked(&self) -> bool {
        self.forwardLocked.unwrap_or(false)
    }

    // optional string contactEmail = 20;

    pub fn get_contactEmail(&self) -> &str {
        match self.contactEmail.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool everInstalledByUser = 21;

    pub fn get_everInstalledByUser(&self) -> bool {
        self.everInstalledByUser.unwrap_or(false)
    }

    // optional string downloadCountString = 23;

    pub fn get_downloadCountString(&self) -> &str {
        match self.downloadCountString.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string contactPhone = 26;

    pub fn get_contactPhone(&self) -> &str {
        match self.contactPhone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string contactWebsite = 27;

    pub fn get_contactWebsite(&self) -> &str {
        match self.contactWebsite.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool nextPurchaseRefundable = 28;

    pub fn get_nextPurchaseRefundable(&self) -> bool {
        self.nextPurchaseRefundable.unwrap_or(false)
    }

    // optional int32 numScreenshots = 30;

    pub fn get_numScreenshots(&self) -> i32 {
        self.numScreenshots.unwrap_or(0)
    }

    // optional string promotionalDescription = 31;

    pub fn get_promotionalDescription(&self) -> &str {
        match self.promotionalDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 serverAssetState = 34;

    pub fn get_serverAssetState(&self) -> i32 {
        self.serverAssetState.unwrap_or(0)
    }

    // optional int32 contentRatingLevel = 36;

    pub fn get_contentRatingLevel(&self) -> i32 {
        self.contentRatingLevel.unwrap_or(0)
    }

    // optional string contentRatingString = 37;

    pub fn get_contentRatingString(&self) -> &str {
        match self.contentRatingString.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string recentChanges = 38;

    pub fn get_recentChanges(&self) -> &str {
        match self.recentChanges.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string videoLink = 43;

    pub fn get_videoLink(&self) -> &str {
        match self.videoLink.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalAssetProto_ExtendedInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.downloadInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloadCount = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.applicationPermissionId)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.requiredInstallationSize = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forwardLocked = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contactEmail)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.everInstalledByUser = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadCountString)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contactPhone)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contactWebsite)?;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.nextPurchaseRefundable = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numScreenshots = ::std::option::Option::Some(tmp);
                },
                31 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.promotionalDescription)?;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.serverAssetState = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentRatingLevel = ::std::option::Option::Some(tmp);
                },
                37 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentRatingString)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recentChanges)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.videoLink)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_message_into::<DownloadInfoProto, _>(wire_type, is, &mut self.downloadInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.downloadCount {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.applicationPermissionId {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.requiredInstallationSize {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.category.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.forwardLocked {
            my_size += 3;
        }
        if let Some(v) = self.contactEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.everInstalledByUser {
            my_size += 3;
        }
        if let Some(v) = self.downloadCountString.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.contactPhone.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.contactWebsite.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.nextPurchaseRefundable {
            my_size += 3;
        }
        if let Some(v) = self.numScreenshots {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.promotionalDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        if let Some(v) = self.serverAssetState {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contentRatingLevel {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contentRatingString.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(v) = self.recentChanges.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        if let Some(v) = self.videoLink.as_ref() {
            my_size += ::protobuf::rt::string_size(43, &v);
        }
        if let Some(v) = self.downloadInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.description.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.downloadCount {
            os.write_int64(14, v)?;
        }
        for v in &self.applicationPermissionId {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.requiredInstallationSize {
            os.write_int64(16, v)?;
        }
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.category.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.forwardLocked {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.contactEmail.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.everInstalledByUser {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.downloadCountString.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.contactPhone.as_ref() {
            os.write_string(26, v)?;
        }
        if let Some(v) = self.contactWebsite.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.nextPurchaseRefundable {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.numScreenshots {
            os.write_int32(30, v)?;
        }
        if let Some(v) = self.promotionalDescription.as_ref() {
            os.write_string(31, v)?;
        }
        if let Some(v) = self.serverAssetState {
            os.write_int32(34, v)?;
        }
        if let Some(v) = self.contentRatingLevel {
            os.write_int32(36, v)?;
        }
        if let Some(v) = self.contentRatingString.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.recentChanges.as_ref() {
            os.write_string(38, v)?;
        }
        if let Some(v) = self.videoLink.as_ref() {
            os.write_string(43, v)?;
        }
        if let Some(v) = self.downloadInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalAssetProto_ExtendedInfo {
        ExternalAssetProto_ExtendedInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "description",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.description },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.description },
                ExternalAssetProto_ExtendedInfo::get_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "downloadCount",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.downloadCount },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.downloadCount },
                ExternalAssetProto_ExtendedInfo::get_downloadCount,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "applicationPermissionId",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.applicationPermissionId },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.applicationPermissionId },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "requiredInstallationSize",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.requiredInstallationSize },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.requiredInstallationSize },
                ExternalAssetProto_ExtendedInfo::get_requiredInstallationSize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.packageName },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.packageName },
                ExternalAssetProto_ExtendedInfo::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "category",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.category },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.category },
                ExternalAssetProto_ExtendedInfo::get_category,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "forwardLocked",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.forwardLocked },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.forwardLocked },
                ExternalAssetProto_ExtendedInfo::get_forwardLocked,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contactEmail",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contactEmail },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contactEmail },
                ExternalAssetProto_ExtendedInfo::get_contactEmail,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "everInstalledByUser",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.everInstalledByUser },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.everInstalledByUser },
                ExternalAssetProto_ExtendedInfo::get_everInstalledByUser,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadCountString",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.downloadCountString },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.downloadCountString },
                ExternalAssetProto_ExtendedInfo::get_downloadCountString,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contactPhone",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contactPhone },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contactPhone },
                ExternalAssetProto_ExtendedInfo::get_contactPhone,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contactWebsite",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contactWebsite },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contactWebsite },
                ExternalAssetProto_ExtendedInfo::get_contactWebsite,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "nextPurchaseRefundable",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.nextPurchaseRefundable },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.nextPurchaseRefundable },
                ExternalAssetProto_ExtendedInfo::get_nextPurchaseRefundable,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "numScreenshots",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.numScreenshots },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.numScreenshots },
                ExternalAssetProto_ExtendedInfo::get_numScreenshots,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "promotionalDescription",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.promotionalDescription },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.promotionalDescription },
                ExternalAssetProto_ExtendedInfo::get_promotionalDescription,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "serverAssetState",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.serverAssetState },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.serverAssetState },
                ExternalAssetProto_ExtendedInfo::get_serverAssetState,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "contentRatingLevel",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contentRatingLevel },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contentRatingLevel },
                ExternalAssetProto_ExtendedInfo::get_contentRatingLevel,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contentRatingString",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contentRatingString },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contentRatingString },
                ExternalAssetProto_ExtendedInfo::get_contentRatingString,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "recentChanges",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.recentChanges },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.recentChanges },
                ExternalAssetProto_ExtendedInfo::get_recentChanges,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "videoLink",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.videoLink },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.videoLink },
                ExternalAssetProto_ExtendedInfo::get_videoLink,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownloadInfoProto>, _>(
                "downloadInfo",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.downloadInfo },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.downloadInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalAssetProto_ExtendedInfo>(
                "ExternalAssetProto_ExtendedInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalAssetProto_ExtendedInfo {
        static instance: ::protobuf::rt::Lazy<ExternalAssetProto_ExtendedInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalAssetProto_ExtendedInfo::new)
    }
}

impl ::protobuf::Clear for ExternalAssetProto_ExtendedInfo {
    fn clear(&mut self) {
        self.description.clear();
        self.downloadCount = ::std::option::Option::None;
        self.applicationPermissionId.clear();
        self.requiredInstallationSize = ::std::option::Option::None;
        self.packageName.clear();
        self.category.clear();
        self.forwardLocked = ::std::option::Option::None;
        self.contactEmail.clear();
        self.everInstalledByUser = ::std::option::Option::None;
        self.downloadCountString.clear();
        self.contactPhone.clear();
        self.contactWebsite.clear();
        self.nextPurchaseRefundable = ::std::option::Option::None;
        self.numScreenshots = ::std::option::Option::None;
        self.promotionalDescription.clear();
        self.serverAssetState = ::std::option::Option::None;
        self.contentRatingLevel = ::std::option::Option::None;
        self.contentRatingString.clear();
        self.recentChanges.clear();
        self.videoLink.clear();
        self.downloadInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalAssetProto_ExtendedInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalAssetProto_ExtendedInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalAssetProto_ExtendedInfo_PackageDependency {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub skipPermissions: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalAssetProto_ExtendedInfo_PackageDependency {
    pub fn new() -> ExternalAssetProto_ExtendedInfo_PackageDependency {
        ::std::default::Default::default()
    }

    // optional string packageName = 41;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool skipPermissions = 42;

    pub fn get_skipPermissions(&self) -> bool {
        self.skipPermissions.unwrap_or(false)
    }
}

impl ::protobuf::Message for ExternalAssetProto_ExtendedInfo_PackageDependency {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                41 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skipPermissions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(41, &v);
        }
        if let Some(v) = self.skipPermissions {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(41, v)?;
        }
        if let Some(v) = self.skipPermissions {
            os.write_bool(42, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalAssetProto_ExtendedInfo_PackageDependency {
        ExternalAssetProto_ExtendedInfo_PackageDependency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &ExternalAssetProto_ExtendedInfo_PackageDependency| { &m.packageName },
                |m: &mut ExternalAssetProto_ExtendedInfo_PackageDependency| { &mut m.packageName },
                ExternalAssetProto_ExtendedInfo_PackageDependency::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "skipPermissions",
                |m: &ExternalAssetProto_ExtendedInfo_PackageDependency| { &m.skipPermissions },
                |m: &mut ExternalAssetProto_ExtendedInfo_PackageDependency| { &mut m.skipPermissions },
                ExternalAssetProto_ExtendedInfo_PackageDependency::get_skipPermissions,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalAssetProto_ExtendedInfo_PackageDependency>(
                "ExternalAssetProto_ExtendedInfo_PackageDependency",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalAssetProto_ExtendedInfo_PackageDependency {
        static instance: ::protobuf::rt::Lazy<ExternalAssetProto_ExtendedInfo_PackageDependency> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalAssetProto_ExtendedInfo_PackageDependency::new)
    }
}

impl ::protobuf::Clear for ExternalAssetProto_ExtendedInfo_PackageDependency {
    fn clear(&mut self) {
        self.packageName.clear();
        self.skipPermissions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalAssetProto_ExtendedInfo_PackageDependency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalAssetProto_ExtendedInfo_PackageDependency {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalBadgeImageProto {
    // message fields
    pub usage: ::std::option::Option<i32>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalBadgeImageProto {
    pub fn new() -> ExternalBadgeImageProto {
        ::std::default::Default::default()
    }

    // optional int32 usage = 1;

    pub fn get_usage(&self) -> i32 {
        self.usage.unwrap_or(0)
    }

    // optional string url = 2;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalBadgeImageProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.usage = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.usage {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.usage {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalBadgeImageProto {
        ExternalBadgeImageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "usage",
                |m: &ExternalBadgeImageProto| { &m.usage },
                |m: &mut ExternalBadgeImageProto| { &mut m.usage },
                ExternalBadgeImageProto::get_usage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "url",
                |m: &ExternalBadgeImageProto| { &m.url },
                |m: &mut ExternalBadgeImageProto| { &mut m.url },
                ExternalBadgeImageProto::get_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalBadgeImageProto>(
                "ExternalBadgeImageProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalBadgeImageProto {
        static instance: ::protobuf::rt::Lazy<ExternalBadgeImageProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalBadgeImageProto::new)
    }
}

impl ::protobuf::Clear for ExternalBadgeImageProto {
    fn clear(&mut self) {
        self.usage = ::std::option::Option::None;
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalBadgeImageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalBadgeImageProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalBadgeProto {
    // message fields
    pub localizedTitle: ::protobuf::SingularField<::std::string::String>,
    pub localizedDescription: ::protobuf::SingularField<::std::string::String>,
    pub badgeImage: ::protobuf::RepeatedField<ExternalBadgeImageProto>,
    pub searchId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalBadgeProto {
    pub fn new() -> ExternalBadgeProto {
        ::std::default::Default::default()
    }

    // optional string localizedTitle = 1;

    pub fn get_localizedTitle(&self) -> &str {
        match self.localizedTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string localizedDescription = 2;

    pub fn get_localizedDescription(&self) -> &str {
        match self.localizedDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string searchId = 4;

    pub fn get_searchId(&self) -> &str {
        match self.searchId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalBadgeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.badgeImage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedDescription)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.badgeImage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.searchId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.localizedTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.localizedDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.badgeImage {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.searchId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.localizedTitle.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.localizedDescription.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.badgeImage {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.searchId.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalBadgeProto {
        ExternalBadgeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "localizedTitle",
                |m: &ExternalBadgeProto| { &m.localizedTitle },
                |m: &mut ExternalBadgeProto| { &mut m.localizedTitle },
                ExternalBadgeProto::get_localizedTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "localizedDescription",
                |m: &ExternalBadgeProto| { &m.localizedDescription },
                |m: &mut ExternalBadgeProto| { &mut m.localizedDescription },
                ExternalBadgeProto::get_localizedDescription,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalBadgeImageProto>>(
                "badgeImage",
                |m: &ExternalBadgeProto| { &m.badgeImage },
                |m: &mut ExternalBadgeProto| { &mut m.badgeImage },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "searchId",
                |m: &ExternalBadgeProto| { &m.searchId },
                |m: &mut ExternalBadgeProto| { &mut m.searchId },
                ExternalBadgeProto::get_searchId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalBadgeProto>(
                "ExternalBadgeProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalBadgeProto {
        static instance: ::protobuf::rt::Lazy<ExternalBadgeProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalBadgeProto::new)
    }
}

impl ::protobuf::Clear for ExternalBadgeProto {
    fn clear(&mut self) {
        self.localizedTitle.clear();
        self.localizedDescription.clear();
        self.badgeImage.clear();
        self.searchId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalBadgeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalBadgeProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalCarrierBillingInstrumentProto {
    // message fields
    pub instrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub subscriberIdentifier: ::protobuf::SingularField<::std::string::String>,
    pub accountType: ::protobuf::SingularField<::std::string::String>,
    pub subscriberCurrency: ::protobuf::SingularField<::std::string::String>,
    pub transactionLimit: ::std::option::Option<u64>,
    pub subscriberName: ::protobuf::SingularField<::std::string::String>,
    pub address1: ::protobuf::SingularField<::std::string::String>,
    pub address2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub country: ::protobuf::SingularField<::std::string::String>,
    pub encryptedSubscriberInfo: ::protobuf::SingularPtrField<EncryptedSubscriberInfo>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalCarrierBillingInstrumentProto {
    pub fn new() -> ExternalCarrierBillingInstrumentProto {
        ::std::default::Default::default()
    }

    // optional string instrumentKey = 1;

    pub fn get_instrumentKey(&self) -> &str {
        match self.instrumentKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string subscriberIdentifier = 2;

    pub fn get_subscriberIdentifier(&self) -> &str {
        match self.subscriberIdentifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string accountType = 3;

    pub fn get_accountType(&self) -> &str {
        match self.accountType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string subscriberCurrency = 4;

    pub fn get_subscriberCurrency(&self) -> &str {
        match self.subscriberCurrency.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional uint64 transactionLimit = 5;

    pub fn get_transactionLimit(&self) -> u64 {
        self.transactionLimit.unwrap_or(0)
    }

    // optional string subscriberName = 6;

    pub fn get_subscriberName(&self) -> &str {
        match self.subscriberName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string address1 = 7;

    pub fn get_address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string address2 = 8;

    pub fn get_address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string city = 9;

    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string state = 10;

    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string postalCode = 11;

    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string country = 12;

    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalCarrierBillingInstrumentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedSubscriberInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberIdentifier)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.accountType)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberCurrency)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.transactionLimit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberName)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address1)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address2)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<EncryptedSubscriberInfo, _>(wire_type, is, &mut self.encryptedSubscriberInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.subscriberIdentifier.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.accountType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.subscriberCurrency.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.transactionLimit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subscriberName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.encryptedSubscriberInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentKey.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.subscriberIdentifier.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.accountType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.subscriberCurrency.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.transactionLimit {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.subscriberName.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.address1.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.address2.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.city.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.postalCode.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.country.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.encryptedSubscriberInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalCarrierBillingInstrumentProto {
        ExternalCarrierBillingInstrumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "instrumentKey",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.instrumentKey },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.instrumentKey },
                ExternalCarrierBillingInstrumentProto::get_instrumentKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subscriberIdentifier",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.subscriberIdentifier },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.subscriberIdentifier },
                ExternalCarrierBillingInstrumentProto::get_subscriberIdentifier,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "accountType",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.accountType },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.accountType },
                ExternalCarrierBillingInstrumentProto::get_accountType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subscriberCurrency",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.subscriberCurrency },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.subscriberCurrency },
                ExternalCarrierBillingInstrumentProto::get_subscriberCurrency,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint64, _>(
                "transactionLimit",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.transactionLimit },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.transactionLimit },
                ExternalCarrierBillingInstrumentProto::get_transactionLimit,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subscriberName",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.subscriberName },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.subscriberName },
                ExternalCarrierBillingInstrumentProto::get_subscriberName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "address1",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.address1 },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.address1 },
                ExternalCarrierBillingInstrumentProto::get_address1,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "address2",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.address2 },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.address2 },
                ExternalCarrierBillingInstrumentProto::get_address2,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "city",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.city },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.city },
                ExternalCarrierBillingInstrumentProto::get_city,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "state",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.state },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.state },
                ExternalCarrierBillingInstrumentProto::get_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "postalCode",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.postalCode },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.postalCode },
                ExternalCarrierBillingInstrumentProto::get_postalCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "country",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.country },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.country },
                ExternalCarrierBillingInstrumentProto::get_country,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedSubscriberInfo>, _>(
                "encryptedSubscriberInfo",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.encryptedSubscriberInfo },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.encryptedSubscriberInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalCarrierBillingInstrumentProto>(
                "ExternalCarrierBillingInstrumentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalCarrierBillingInstrumentProto {
        static instance: ::protobuf::rt::Lazy<ExternalCarrierBillingInstrumentProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalCarrierBillingInstrumentProto::new)
    }
}

impl ::protobuf::Clear for ExternalCarrierBillingInstrumentProto {
    fn clear(&mut self) {
        self.instrumentKey.clear();
        self.subscriberIdentifier.clear();
        self.accountType.clear();
        self.subscriberCurrency.clear();
        self.transactionLimit = ::std::option::Option::None;
        self.subscriberName.clear();
        self.address1.clear();
        self.address2.clear();
        self.city.clear();
        self.state.clear();
        self.postalCode.clear();
        self.country.clear();
        self.encryptedSubscriberInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalCarrierBillingInstrumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalCarrierBillingInstrumentProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalCommentProto {
    // message fields
    pub body: ::protobuf::SingularField<::std::string::String>,
    pub rating: ::std::option::Option<i32>,
    pub creatorName: ::protobuf::SingularField<::std::string::String>,
    pub creationTime: ::std::option::Option<i64>,
    pub creatorId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalCommentProto {
    pub fn new() -> ExternalCommentProto {
        ::std::default::Default::default()
    }

    // optional string body = 1;

    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 rating = 2;

    pub fn get_rating(&self) -> i32 {
        self.rating.unwrap_or(0)
    }

    // optional string creatorName = 3;

    pub fn get_creatorName(&self) -> &str {
        match self.creatorName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 creationTime = 4;

    pub fn get_creationTime(&self) -> i64 {
        self.creationTime.unwrap_or(0)
    }

    // optional string creatorId = 5;

    pub fn get_creatorId(&self) -> &str {
        match self.creatorId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalCommentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rating = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creatorName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creationTime = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creatorId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rating {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.creationTime {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creatorId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.body.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rating {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.creatorName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.creationTime {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.creatorId.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalCommentProto {
        ExternalCommentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "body",
                |m: &ExternalCommentProto| { &m.body },
                |m: &mut ExternalCommentProto| { &mut m.body },
                ExternalCommentProto::get_body,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "rating",
                |m: &ExternalCommentProto| { &m.rating },
                |m: &mut ExternalCommentProto| { &mut m.rating },
                ExternalCommentProto::get_rating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "creatorName",
                |m: &ExternalCommentProto| { &m.creatorName },
                |m: &mut ExternalCommentProto| { &mut m.creatorName },
                ExternalCommentProto::get_creatorName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "creationTime",
                |m: &ExternalCommentProto| { &m.creationTime },
                |m: &mut ExternalCommentProto| { &mut m.creationTime },
                ExternalCommentProto::get_creationTime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "creatorId",
                |m: &ExternalCommentProto| { &m.creatorId },
                |m: &mut ExternalCommentProto| { &mut m.creatorId },
                ExternalCommentProto::get_creatorId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalCommentProto>(
                "ExternalCommentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalCommentProto {
        static instance: ::protobuf::rt::Lazy<ExternalCommentProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalCommentProto::new)
    }
}

impl ::protobuf::Clear for ExternalCommentProto {
    fn clear(&mut self) {
        self.body.clear();
        self.rating = ::std::option::Option::None;
        self.creatorName.clear();
        self.creationTime = ::std::option::Option::None;
        self.creatorId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalCommentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalCommentProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalCreditCard {
    // message fields
    pub field_type: ::protobuf::SingularField<::std::string::String>,
    pub lastDigits: ::protobuf::SingularField<::std::string::String>,
    pub expYear: ::std::option::Option<i32>,
    pub expMonth: ::std::option::Option<i32>,
    pub personName: ::protobuf::SingularField<::std::string::String>,
    pub countryCode: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub makeDefault: ::std::option::Option<bool>,
    pub address1: ::protobuf::SingularField<::std::string::String>,
    pub address2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub phone: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalCreditCard {
    pub fn new() -> ExternalCreditCard {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string lastDigits = 2;

    pub fn get_lastDigits(&self) -> &str {
        match self.lastDigits.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 expYear = 3;

    pub fn get_expYear(&self) -> i32 {
        self.expYear.unwrap_or(0)
    }

    // optional int32 expMonth = 4;

    pub fn get_expMonth(&self) -> i32 {
        self.expMonth.unwrap_or(0)
    }

    // optional string personName = 5;

    pub fn get_personName(&self) -> &str {
        match self.personName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string countryCode = 6;

    pub fn get_countryCode(&self) -> &str {
        match self.countryCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string postalCode = 7;

    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool makeDefault = 8;

    pub fn get_makeDefault(&self) -> bool {
        self.makeDefault.unwrap_or(false)
    }

    // optional string address1 = 9;

    pub fn get_address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string address2 = 10;

    pub fn get_address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string city = 11;

    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string state = 12;

    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string phone = 13;

    pub fn get_phone(&self) -> &str {
        match self.phone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalCreditCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastDigits)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expYear = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expMonth = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.personName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.countryCode)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.makeDefault = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address1)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address2)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.lastDigits.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.expYear {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expMonth {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.personName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.countryCode.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.makeDefault {
            my_size += 2;
        }
        if let Some(v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.phone.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.lastDigits.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.expYear {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.expMonth {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.personName.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.countryCode.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.postalCode.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.makeDefault {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.address1.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.address2.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.city.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.phone.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalCreditCard {
        ExternalCreditCard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "type",
                |m: &ExternalCreditCard| { &m.field_type },
                |m: &mut ExternalCreditCard| { &mut m.field_type },
                ExternalCreditCard::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "lastDigits",
                |m: &ExternalCreditCard| { &m.lastDigits },
                |m: &mut ExternalCreditCard| { &mut m.lastDigits },
                ExternalCreditCard::get_lastDigits,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "expYear",
                |m: &ExternalCreditCard| { &m.expYear },
                |m: &mut ExternalCreditCard| { &mut m.expYear },
                ExternalCreditCard::get_expYear,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "expMonth",
                |m: &ExternalCreditCard| { &m.expMonth },
                |m: &mut ExternalCreditCard| { &mut m.expMonth },
                ExternalCreditCard::get_expMonth,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "personName",
                |m: &ExternalCreditCard| { &m.personName },
                |m: &mut ExternalCreditCard| { &mut m.personName },
                ExternalCreditCard::get_personName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "countryCode",
                |m: &ExternalCreditCard| { &m.countryCode },
                |m: &mut ExternalCreditCard| { &mut m.countryCode },
                ExternalCreditCard::get_countryCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "postalCode",
                |m: &ExternalCreditCard| { &m.postalCode },
                |m: &mut ExternalCreditCard| { &mut m.postalCode },
                ExternalCreditCard::get_postalCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "makeDefault",
                |m: &ExternalCreditCard| { &m.makeDefault },
                |m: &mut ExternalCreditCard| { &mut m.makeDefault },
                ExternalCreditCard::get_makeDefault,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "address1",
                |m: &ExternalCreditCard| { &m.address1 },
                |m: &mut ExternalCreditCard| { &mut m.address1 },
                ExternalCreditCard::get_address1,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "address2",
                |m: &ExternalCreditCard| { &m.address2 },
                |m: &mut ExternalCreditCard| { &mut m.address2 },
                ExternalCreditCard::get_address2,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "city",
                |m: &ExternalCreditCard| { &m.city },
                |m: &mut ExternalCreditCard| { &mut m.city },
                ExternalCreditCard::get_city,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "state",
                |m: &ExternalCreditCard| { &m.state },
                |m: &mut ExternalCreditCard| { &mut m.state },
                ExternalCreditCard::get_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "phone",
                |m: &ExternalCreditCard| { &m.phone },
                |m: &mut ExternalCreditCard| { &mut m.phone },
                ExternalCreditCard::get_phone,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalCreditCard>(
                "ExternalCreditCard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalCreditCard {
        static instance: ::protobuf::rt::Lazy<ExternalCreditCard> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalCreditCard::new)
    }
}

impl ::protobuf::Clear for ExternalCreditCard {
    fn clear(&mut self) {
        self.field_type.clear();
        self.lastDigits.clear();
        self.expYear = ::std::option::Option::None;
        self.expMonth = ::std::option::Option::None;
        self.personName.clear();
        self.countryCode.clear();
        self.postalCode.clear();
        self.makeDefault = ::std::option::Option::None;
        self.address1.clear();
        self.address2.clear();
        self.city.clear();
        self.state.clear();
        self.phone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalCreditCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalCreditCard {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ExternalPaypalInstrumentProto {
    // message fields
    pub instrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub preapprovalKey: ::protobuf::SingularField<::std::string::String>,
    pub paypalEmail: ::protobuf::SingularField<::std::string::String>,
    pub paypalAddress: ::protobuf::SingularPtrField<AddressProto>,
    pub multiplePaypalInstrumentsSupported: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ExternalPaypalInstrumentProto {
    pub fn new() -> ExternalPaypalInstrumentProto {
        ::std::default::Default::default()
    }

    // optional string instrumentKey = 1;

    pub fn get_instrumentKey(&self) -> &str {
        match self.instrumentKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string preapprovalKey = 2;

    pub fn get_preapprovalKey(&self) -> &str {
        match self.preapprovalKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string paypalEmail = 3;

    pub fn get_paypalEmail(&self) -> &str {
        match self.paypalEmail.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool multiplePaypalInstrumentsSupported = 5;

    pub fn get_multiplePaypalInstrumentsSupported(&self) -> bool {
        self.multiplePaypalInstrumentsSupported.unwrap_or(false)
    }
}

impl ::protobuf::Message for ExternalPaypalInstrumentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.paypalAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preapprovalKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalEmail)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<AddressProto, _>(wire_type, is, &mut self.paypalAddress)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.multiplePaypalInstrumentsSupported = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.preapprovalKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.paypalEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.paypalAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.multiplePaypalInstrumentsSupported {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentKey.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.preapprovalKey.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.paypalEmail.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.paypalAddress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.multiplePaypalInstrumentsSupported {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalPaypalInstrumentProto {
        ExternalPaypalInstrumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "instrumentKey",
                |m: &ExternalPaypalInstrumentProto| { &m.instrumentKey },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.instrumentKey },
                ExternalPaypalInstrumentProto::get_instrumentKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "preapprovalKey",
                |m: &ExternalPaypalInstrumentProto| { &m.preapprovalKey },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.preapprovalKey },
                ExternalPaypalInstrumentProto::get_preapprovalKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "paypalEmail",
                |m: &ExternalPaypalInstrumentProto| { &m.paypalEmail },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.paypalEmail },
                ExternalPaypalInstrumentProto::get_paypalEmail,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>, _>(
                "paypalAddress",
                |m: &ExternalPaypalInstrumentProto| { &m.paypalAddress },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.paypalAddress },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "multiplePaypalInstrumentsSupported",
                |m: &ExternalPaypalInstrumentProto| { &m.multiplePaypalInstrumentsSupported },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.multiplePaypalInstrumentsSupported },
                ExternalPaypalInstrumentProto::get_multiplePaypalInstrumentsSupported,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ExternalPaypalInstrumentProto>(
                "ExternalPaypalInstrumentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalPaypalInstrumentProto {
        static instance: ::protobuf::rt::Lazy<ExternalPaypalInstrumentProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ExternalPaypalInstrumentProto::new)
    }
}

impl ::protobuf::Clear for ExternalPaypalInstrumentProto {
    fn clear(&mut self) {
        self.instrumentKey.clear();
        self.preapprovalKey.clear();
        self.paypalEmail.clear();
        self.paypalAddress.clear();
        self.multiplePaypalInstrumentsSupported = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalPaypalInstrumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalPaypalInstrumentProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct FileMetadataProto {
    // message fields
    pub fileType: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl FileMetadataProto {
    pub fn new() -> FileMetadataProto {
        ::std::default::Default::default()
    }

    // optional int32 fileType = 1;

    pub fn get_fileType(&self) -> i32 {
        self.fileType.unwrap_or(0)
    }

    // optional int32 versionCode = 2;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 size = 3;

    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional string downloadUrl = 4;

    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for FileMetadataProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fileType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.downloadUrl.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileMetadataProto {
        FileMetadataProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "fileType",
                |m: &FileMetadataProto| { &m.fileType },
                |m: &mut FileMetadataProto| { &mut m.fileType },
                FileMetadataProto::get_fileType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &FileMetadataProto| { &m.versionCode },
                |m: &mut FileMetadataProto| { &mut m.versionCode },
                FileMetadataProto::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "size",
                |m: &FileMetadataProto| { &m.size },
                |m: &mut FileMetadataProto| { &mut m.size },
                FileMetadataProto::get_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadUrl",
                |m: &FileMetadataProto| { &m.downloadUrl },
                |m: &mut FileMetadataProto| { &mut m.downloadUrl },
                FileMetadataProto::get_downloadUrl,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<FileMetadataProto>(
                "FileMetadataProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileMetadataProto {
        static instance: ::protobuf::rt::Lazy<FileMetadataProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(FileMetadataProto::new)
    }
}

impl ::protobuf::Clear for FileMetadataProto {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.downloadUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileMetadataProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileMetadataProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetAddressSnippetRequestProto {
    // message fields
    pub encryptedSubscriberInfo: ::protobuf::SingularPtrField<EncryptedSubscriberInfo>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetAddressSnippetRequestProto {
    pub fn new() -> GetAddressSnippetRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetAddressSnippetRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedSubscriberInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<EncryptedSubscriberInfo, _>(wire_type, is, &mut self.encryptedSubscriberInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.encryptedSubscriberInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.encryptedSubscriberInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressSnippetRequestProto {
        GetAddressSnippetRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedSubscriberInfo>, _>(
                "encryptedSubscriberInfo",
                |m: &GetAddressSnippetRequestProto| { &m.encryptedSubscriberInfo },
                |m: &mut GetAddressSnippetRequestProto| { &mut m.encryptedSubscriberInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetAddressSnippetRequestProto>(
                "GetAddressSnippetRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressSnippetRequestProto {
        static instance: ::protobuf::rt::Lazy<GetAddressSnippetRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetAddressSnippetRequestProto::new)
    }
}

impl ::protobuf::Clear for GetAddressSnippetRequestProto {
    fn clear(&mut self) {
        self.encryptedSubscriberInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressSnippetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressSnippetRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetAddressSnippetResponseProto {
    // message fields
    pub addressSnippet: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetAddressSnippetResponseProto {
    pub fn new() -> GetAddressSnippetResponseProto {
        ::std::default::Default::default()
    }

    // optional string addressSnippet = 1;

    pub fn get_addressSnippet(&self) -> &str {
        match self.addressSnippet.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetAddressSnippetResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressSnippet)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.addressSnippet.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.addressSnippet.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressSnippetResponseProto {
        GetAddressSnippetResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "addressSnippet",
                |m: &GetAddressSnippetResponseProto| { &m.addressSnippet },
                |m: &mut GetAddressSnippetResponseProto| { &mut m.addressSnippet },
                GetAddressSnippetResponseProto::get_addressSnippet,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetAddressSnippetResponseProto>(
                "GetAddressSnippetResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressSnippetResponseProto {
        static instance: ::protobuf::rt::Lazy<GetAddressSnippetResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetAddressSnippetResponseProto::new)
    }
}

impl ::protobuf::Clear for GetAddressSnippetResponseProto {
    fn clear(&mut self) {
        self.addressSnippet.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressSnippetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressSnippetResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetAssetRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub directDownloadKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetAssetRequestProto {
    pub fn new() -> GetAssetRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string directDownloadKey = 2;

    pub fn get_directDownloadKey(&self) -> &str {
        match self.directDownloadKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetAssetRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.directDownloadKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.directDownloadKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.directDownloadKey.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAssetRequestProto {
        GetAssetRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &GetAssetRequestProto| { &m.assetId },
                |m: &mut GetAssetRequestProto| { &mut m.assetId },
                GetAssetRequestProto::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "directDownloadKey",
                |m: &GetAssetRequestProto| { &m.directDownloadKey },
                |m: &mut GetAssetRequestProto| { &mut m.directDownloadKey },
                GetAssetRequestProto::get_directDownloadKey,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetAssetRequestProto>(
                "GetAssetRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAssetRequestProto {
        static instance: ::protobuf::rt::Lazy<GetAssetRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetAssetRequestProto::new)
    }
}

impl ::protobuf::Clear for GetAssetRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.directDownloadKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAssetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAssetRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetAssetResponseProto {
    // message fields
    // installasset: <group>
    pub additionalFile: ::protobuf::RepeatedField<FileMetadataProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetAssetResponseProto {
    pub fn new() -> GetAssetResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetAssetResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.additionalFile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                15 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.additionalFile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.additionalFile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.additionalFile {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAssetResponseProto {
        GetAssetResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileMetadataProto>>(
                "additionalFile",
                |m: &GetAssetResponseProto| { &m.additionalFile },
                |m: &mut GetAssetResponseProto| { &mut m.additionalFile },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetAssetResponseProto>(
                "GetAssetResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAssetResponseProto {
        static instance: ::protobuf::rt::Lazy<GetAssetResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetAssetResponseProto::new)
    }
}

impl ::protobuf::Clear for GetAssetResponseProto {
    fn clear(&mut self) {
        self.additionalFile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAssetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAssetResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetAssetResponseProto_InstallAsset {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub assetName: ::protobuf::SingularField<::std::string::String>,
    pub assetType: ::protobuf::SingularField<::std::string::String>,
    pub assetPackage: ::protobuf::SingularField<::std::string::String>,
    pub blobUrl: ::protobuf::SingularField<::std::string::String>,
    pub assetSignature: ::protobuf::SingularField<::std::string::String>,
    pub assetSize: ::std::option::Option<i64>,
    pub refundTimeoutMillis: ::std::option::Option<i64>,
    pub forwardLocked: ::std::option::Option<bool>,
    pub secured: ::std::option::Option<bool>,
    pub versionCode: ::std::option::Option<i32>,
    pub downloadAuthCookieName: ::protobuf::SingularField<::std::string::String>,
    pub downloadAuthCookieValue: ::protobuf::SingularField<::std::string::String>,
    pub postInstallRefundWindowMillis: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetAssetResponseProto_InstallAsset {
    pub fn new() -> GetAssetResponseProto_InstallAsset {
        ::std::default::Default::default()
    }

    // optional string assetId = 2;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string assetName = 3;

    pub fn get_assetName(&self) -> &str {
        match self.assetName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string assetType = 4;

    pub fn get_assetType(&self) -> &str {
        match self.assetType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string assetPackage = 5;

    pub fn get_assetPackage(&self) -> &str {
        match self.assetPackage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string blobUrl = 6;

    pub fn get_blobUrl(&self) -> &str {
        match self.blobUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string assetSignature = 7;

    pub fn get_assetSignature(&self) -> &str {
        match self.assetSignature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 assetSize = 8;

    pub fn get_assetSize(&self) -> i64 {
        self.assetSize.unwrap_or(0)
    }

    // optional int64 refundTimeoutMillis = 9;

    pub fn get_refundTimeoutMillis(&self) -> i64 {
        self.refundTimeoutMillis.unwrap_or(0)
    }

    // optional bool forwardLocked = 10;

    pub fn get_forwardLocked(&self) -> bool {
        self.forwardLocked.unwrap_or(false)
    }

    // optional bool secured = 11;

    pub fn get_secured(&self) -> bool {
        self.secured.unwrap_or(false)
    }

    // optional int32 versionCode = 12;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string downloadAuthCookieName = 13;

    pub fn get_downloadAuthCookieName(&self) -> &str {
        match self.downloadAuthCookieName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string downloadAuthCookieValue = 14;

    pub fn get_downloadAuthCookieValue(&self) -> &str {
        match self.downloadAuthCookieValue.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 postInstallRefundWindowMillis = 16;

    pub fn get_postInstallRefundWindowMillis(&self) -> i64 {
        self.postInstallRefundWindowMillis.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetAssetResponseProto_InstallAsset {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetType)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetPackage)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blobUrl)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetSignature)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.assetSize = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutMillis = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forwardLocked = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.secured = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadAuthCookieName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadAuthCookieValue)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postInstallRefundWindowMillis = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.assetName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.assetType.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.assetPackage.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.blobUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.assetSignature.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.assetSize {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refundTimeoutMillis {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.forwardLocked {
            my_size += 2;
        }
        if let Some(v) = self.secured {
            my_size += 2;
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.downloadAuthCookieName.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.downloadAuthCookieValue.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.assetName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.assetType.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.assetPackage.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.blobUrl.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.assetSignature.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.assetSize {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.refundTimeoutMillis {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.forwardLocked {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.secured {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.downloadAuthCookieName.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.downloadAuthCookieValue.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            os.write_int64(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAssetResponseProto_InstallAsset {
        GetAssetResponseProto_InstallAsset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetId },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetId },
                GetAssetResponseProto_InstallAsset::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetName",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetName },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetName },
                GetAssetResponseProto_InstallAsset::get_assetName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetType",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetType },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetType },
                GetAssetResponseProto_InstallAsset::get_assetType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetPackage",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetPackage },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetPackage },
                GetAssetResponseProto_InstallAsset::get_assetPackage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "blobUrl",
                |m: &GetAssetResponseProto_InstallAsset| { &m.blobUrl },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.blobUrl },
                GetAssetResponseProto_InstallAsset::get_blobUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetSignature",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetSignature },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetSignature },
                GetAssetResponseProto_InstallAsset::get_assetSignature,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "assetSize",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetSize },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetSize },
                GetAssetResponseProto_InstallAsset::get_assetSize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "refundTimeoutMillis",
                |m: &GetAssetResponseProto_InstallAsset| { &m.refundTimeoutMillis },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.refundTimeoutMillis },
                GetAssetResponseProto_InstallAsset::get_refundTimeoutMillis,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "forwardLocked",
                |m: &GetAssetResponseProto_InstallAsset| { &m.forwardLocked },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.forwardLocked },
                GetAssetResponseProto_InstallAsset::get_forwardLocked,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "secured",
                |m: &GetAssetResponseProto_InstallAsset| { &m.secured },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.secured },
                GetAssetResponseProto_InstallAsset::get_secured,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &GetAssetResponseProto_InstallAsset| { &m.versionCode },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.versionCode },
                GetAssetResponseProto_InstallAsset::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadAuthCookieName",
                |m: &GetAssetResponseProto_InstallAsset| { &m.downloadAuthCookieName },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.downloadAuthCookieName },
                GetAssetResponseProto_InstallAsset::get_downloadAuthCookieName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "downloadAuthCookieValue",
                |m: &GetAssetResponseProto_InstallAsset| { &m.downloadAuthCookieValue },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.downloadAuthCookieValue },
                GetAssetResponseProto_InstallAsset::get_downloadAuthCookieValue,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "postInstallRefundWindowMillis",
                |m: &GetAssetResponseProto_InstallAsset| { &m.postInstallRefundWindowMillis },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.postInstallRefundWindowMillis },
                GetAssetResponseProto_InstallAsset::get_postInstallRefundWindowMillis,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetAssetResponseProto_InstallAsset>(
                "GetAssetResponseProto_InstallAsset",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAssetResponseProto_InstallAsset {
        static instance: ::protobuf::rt::Lazy<GetAssetResponseProto_InstallAsset> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetAssetResponseProto_InstallAsset::new)
    }
}

impl ::protobuf::Clear for GetAssetResponseProto_InstallAsset {
    fn clear(&mut self) {
        self.assetId.clear();
        self.assetName.clear();
        self.assetType.clear();
        self.assetPackage.clear();
        self.blobUrl.clear();
        self.assetSignature.clear();
        self.assetSize = ::std::option::Option::None;
        self.refundTimeoutMillis = ::std::option::Option::None;
        self.forwardLocked = ::std::option::Option::None;
        self.secured = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.downloadAuthCookieName.clear();
        self.downloadAuthCookieValue.clear();
        self.postInstallRefundWindowMillis = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAssetResponseProto_InstallAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAssetResponseProto_InstallAsset {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetCarrierInfoRequestProto {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetCarrierInfoRequestProto {
    pub fn new() -> GetCarrierInfoRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCarrierInfoRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCarrierInfoRequestProto {
        GetCarrierInfoRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<GetCarrierInfoRequestProto>(
                "GetCarrierInfoRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCarrierInfoRequestProto {
        static instance: ::protobuf::rt::Lazy<GetCarrierInfoRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetCarrierInfoRequestProto::new)
    }
}

impl ::protobuf::Clear for GetCarrierInfoRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCarrierInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCarrierInfoRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetCarrierInfoResponseProto {
    // message fields
    pub carrierChannelEnabled: ::std::option::Option<bool>,
    pub carrierLogoIcon: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub carrierBanner: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub carrierSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub carrierTitle: ::protobuf::SingularField<::std::string::String>,
    pub carrierImageDensity: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetCarrierInfoResponseProto {
    pub fn new() -> GetCarrierInfoResponseProto {
        ::std::default::Default::default()
    }

    // optional bool carrierChannelEnabled = 1;

    pub fn get_carrierChannelEnabled(&self) -> bool {
        self.carrierChannelEnabled.unwrap_or(false)
    }

    // optional bytes carrierLogoIcon = 2;

    pub fn get_carrierLogoIcon(&self) -> &[u8] {
        match self.carrierLogoIcon.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional bytes carrierBanner = 3;

    pub fn get_carrierBanner(&self) -> &[u8] {
        match self.carrierBanner.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional string carrierSubtitle = 4;

    pub fn get_carrierSubtitle(&self) -> &str {
        match self.carrierSubtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string carrierTitle = 5;

    pub fn get_carrierTitle(&self) -> &str {
        match self.carrierTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 carrierImageDensity = 6;

    pub fn get_carrierImageDensity(&self) -> i32 {
        self.carrierImageDensity.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetCarrierInfoResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.carrierChannelEnabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.carrierLogoIcon)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.carrierBanner)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrierSubtitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrierTitle)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.carrierImageDensity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.carrierChannelEnabled {
            my_size += 2;
        }
        if let Some(v) = self.carrierLogoIcon.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.carrierBanner.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.carrierSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.carrierTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.carrierImageDensity {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.carrierChannelEnabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.carrierLogoIcon.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.carrierBanner.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.carrierSubtitle.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.carrierTitle.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.carrierImageDensity {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCarrierInfoResponseProto {
        GetCarrierInfoResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "carrierChannelEnabled",
                |m: &GetCarrierInfoResponseProto| { &m.carrierChannelEnabled },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierChannelEnabled },
                GetCarrierInfoResponseProto::get_carrierChannelEnabled,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "carrierLogoIcon",
                |m: &GetCarrierInfoResponseProto| { &m.carrierLogoIcon },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierLogoIcon },
                GetCarrierInfoResponseProto::get_carrierLogoIcon,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "carrierBanner",
                |m: &GetCarrierInfoResponseProto| { &m.carrierBanner },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierBanner },
                GetCarrierInfoResponseProto::get_carrierBanner,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "carrierSubtitle",
                |m: &GetCarrierInfoResponseProto| { &m.carrierSubtitle },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierSubtitle },
                GetCarrierInfoResponseProto::get_carrierSubtitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "carrierTitle",
                |m: &GetCarrierInfoResponseProto| { &m.carrierTitle },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierTitle },
                GetCarrierInfoResponseProto::get_carrierTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "carrierImageDensity",
                |m: &GetCarrierInfoResponseProto| { &m.carrierImageDensity },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierImageDensity },
                GetCarrierInfoResponseProto::get_carrierImageDensity,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetCarrierInfoResponseProto>(
                "GetCarrierInfoResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCarrierInfoResponseProto {
        static instance: ::protobuf::rt::Lazy<GetCarrierInfoResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetCarrierInfoResponseProto::new)
    }
}

impl ::protobuf::Clear for GetCarrierInfoResponseProto {
    fn clear(&mut self) {
        self.carrierChannelEnabled = ::std::option::Option::None;
        self.carrierLogoIcon.clear();
        self.carrierBanner.clear();
        self.carrierSubtitle.clear();
        self.carrierTitle.clear();
        self.carrierImageDensity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCarrierInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCarrierInfoResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetCategoriesRequestProto {
    // message fields
    pub prefetchPromoData: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetCategoriesRequestProto {
    pub fn new() -> GetCategoriesRequestProto {
        ::std::default::Default::default()
    }

    // optional bool prefetchPromoData = 1;

    pub fn get_prefetchPromoData(&self) -> bool {
        self.prefetchPromoData.unwrap_or(false)
    }
}

impl ::protobuf::Message for GetCategoriesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prefetchPromoData = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prefetchPromoData {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prefetchPromoData {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCategoriesRequestProto {
        GetCategoriesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "prefetchPromoData",
                |m: &GetCategoriesRequestProto| { &m.prefetchPromoData },
                |m: &mut GetCategoriesRequestProto| { &mut m.prefetchPromoData },
                GetCategoriesRequestProto::get_prefetchPromoData,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetCategoriesRequestProto>(
                "GetCategoriesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCategoriesRequestProto {
        static instance: ::protobuf::rt::Lazy<GetCategoriesRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetCategoriesRequestProto::new)
    }
}

impl ::protobuf::Clear for GetCategoriesRequestProto {
    fn clear(&mut self) {
        self.prefetchPromoData = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCategoriesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCategoriesRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetCategoriesResponseProto {
    // message fields
    pub categories: ::protobuf::RepeatedField<CategoryProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetCategoriesResponseProto {
    pub fn new() -> GetCategoriesResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCategoriesResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.categories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.categories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.categories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.categories {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCategoriesResponseProto {
        GetCategoriesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CategoryProto>>(
                "categories",
                |m: &GetCategoriesResponseProto| { &m.categories },
                |m: &mut GetCategoriesResponseProto| { &mut m.categories },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetCategoriesResponseProto>(
                "GetCategoriesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCategoriesResponseProto {
        static instance: ::protobuf::rt::Lazy<GetCategoriesResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetCategoriesResponseProto::new)
    }
}

impl ::protobuf::Clear for GetCategoriesResponseProto {
    fn clear(&mut self) {
        self.categories.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCategoriesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCategoriesResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetImageRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub imageUsage: ::std::option::Option<i32>,
    pub imageId: ::protobuf::SingularField<::std::string::String>,
    pub screenPropertyWidth: ::std::option::Option<i32>,
    pub screenPropertyHeight: ::std::option::Option<i32>,
    pub screenPropertyDensity: ::std::option::Option<i32>,
    pub productType: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetImageRequestProto {
    pub fn new() -> GetImageRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 imageUsage = 3;

    pub fn get_imageUsage(&self) -> i32 {
        self.imageUsage.unwrap_or(0)
    }

    // optional string imageId = 4;

    pub fn get_imageId(&self) -> &str {
        match self.imageId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 screenPropertyWidth = 5;

    pub fn get_screenPropertyWidth(&self) -> i32 {
        self.screenPropertyWidth.unwrap_or(0)
    }

    // optional int32 screenPropertyHeight = 6;

    pub fn get_screenPropertyHeight(&self) -> i32 {
        self.screenPropertyHeight.unwrap_or(0)
    }

    // optional int32 screenPropertyDensity = 7;

    pub fn get_screenPropertyDensity(&self) -> i32 {
        self.screenPropertyDensity.unwrap_or(0)
    }

    // optional int32 productType = 8;

    pub fn get_productType(&self) -> i32 {
        self.productType.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetImageRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.imageUsage = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imageId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenPropertyWidth = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenPropertyHeight = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenPropertyDensity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.productType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.imageUsage {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.imageId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.screenPropertyWidth {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenPropertyHeight {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenPropertyDensity {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.productType {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.imageUsage {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.imageId.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.screenPropertyWidth {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.screenPropertyHeight {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.screenPropertyDensity {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.productType {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetImageRequestProto {
        GetImageRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &GetImageRequestProto| { &m.assetId },
                |m: &mut GetImageRequestProto| { &mut m.assetId },
                GetImageRequestProto::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "imageUsage",
                |m: &GetImageRequestProto| { &m.imageUsage },
                |m: &mut GetImageRequestProto| { &mut m.imageUsage },
                GetImageRequestProto::get_imageUsage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "imageId",
                |m: &GetImageRequestProto| { &m.imageId },
                |m: &mut GetImageRequestProto| { &mut m.imageId },
                GetImageRequestProto::get_imageId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "screenPropertyWidth",
                |m: &GetImageRequestProto| { &m.screenPropertyWidth },
                |m: &mut GetImageRequestProto| { &mut m.screenPropertyWidth },
                GetImageRequestProto::get_screenPropertyWidth,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "screenPropertyHeight",
                |m: &GetImageRequestProto| { &m.screenPropertyHeight },
                |m: &mut GetImageRequestProto| { &mut m.screenPropertyHeight },
                GetImageRequestProto::get_screenPropertyHeight,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "screenPropertyDensity",
                |m: &GetImageRequestProto| { &m.screenPropertyDensity },
                |m: &mut GetImageRequestProto| { &mut m.screenPropertyDensity },
                GetImageRequestProto::get_screenPropertyDensity,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "productType",
                |m: &GetImageRequestProto| { &m.productType },
                |m: &mut GetImageRequestProto| { &mut m.productType },
                GetImageRequestProto::get_productType,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetImageRequestProto>(
                "GetImageRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetImageRequestProto {
        static instance: ::protobuf::rt::Lazy<GetImageRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetImageRequestProto::new)
    }
}

impl ::protobuf::Clear for GetImageRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.imageUsage = ::std::option::Option::None;
        self.imageId.clear();
        self.screenPropertyWidth = ::std::option::Option::None;
        self.screenPropertyHeight = ::std::option::Option::None;
        self.screenPropertyDensity = ::std::option::Option::None;
        self.productType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetImageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetImageRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetImageResponseProto {
    // message fields
    pub imageData: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub imageDensity: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetImageResponseProto {
    pub fn new() -> GetImageResponseProto {
        ::std::default::Default::default()
    }

    // optional bytes imageData = 1;

    pub fn get_imageData(&self) -> &[u8] {
        match self.imageData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    // optional int32 imageDensity = 2;

    pub fn get_imageDensity(&self) -> i32 {
        self.imageDensity.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetImageResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.imageData)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.imageDensity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.imageData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.imageDensity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.imageData.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.imageDensity {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetImageResponseProto {
        GetImageResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "imageData",
                |m: &GetImageResponseProto| { &m.imageData },
                |m: &mut GetImageResponseProto| { &mut m.imageData },
                GetImageResponseProto::get_imageData,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "imageDensity",
                |m: &GetImageResponseProto| { &m.imageDensity },
                |m: &mut GetImageResponseProto| { &mut m.imageDensity },
                GetImageResponseProto::get_imageDensity,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetImageResponseProto>(
                "GetImageResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetImageResponseProto {
        static instance: ::protobuf::rt::Lazy<GetImageResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetImageResponseProto::new)
    }
}

impl ::protobuf::Clear for GetImageResponseProto {
    fn clear(&mut self) {
        self.imageData.clear();
        self.imageDensity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetImageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetImageResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetMarketMetadataRequestProto {
    // message fields
    pub lastRequestTime: ::std::option::Option<i64>,
    pub deviceConfiguration: ::protobuf::SingularPtrField<DeviceConfigurationProto>,
    pub deviceRoaming: ::std::option::Option<bool>,
    pub marketSignatureHash: ::protobuf::RepeatedField<::std::string::String>,
    pub contentRating: ::std::option::Option<i32>,
    pub deviceModelName: ::protobuf::SingularField<::std::string::String>,
    pub deviceManufacturerName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetMarketMetadataRequestProto {
    pub fn new() -> GetMarketMetadataRequestProto {
        ::std::default::Default::default()
    }

    // optional int64 lastRequestTime = 1;

    pub fn get_lastRequestTime(&self) -> i64 {
        self.lastRequestTime.unwrap_or(0)
    }

    // optional bool deviceRoaming = 3;

    pub fn get_deviceRoaming(&self) -> bool {
        self.deviceRoaming.unwrap_or(false)
    }

    // optional int32 contentRating = 5;

    pub fn get_contentRating(&self) -> i32 {
        self.contentRating.unwrap_or(0)
    }

    // optional string deviceModelName = 6;

    pub fn get_deviceModelName(&self) -> &str {
        match self.deviceModelName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string deviceManufacturerName = 7;

    pub fn get_deviceManufacturerName(&self) -> &str {
        match self.deviceManufacturerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetMarketMetadataRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.deviceConfiguration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastRequestTime = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<DeviceConfigurationProto, _>(wire_type, is, &mut self.deviceConfiguration)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deviceRoaming = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.marketSignatureHash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentRating = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceModelName)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceManufacturerName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lastRequestTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deviceRoaming {
            my_size += 2;
        }
        for value in &self.marketSignatureHash {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.contentRating {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deviceModelName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.deviceManufacturerName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lastRequestTime {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.deviceRoaming {
            os.write_bool(3, v)?;
        }
        for v in &self.marketSignatureHash {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.contentRating {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.deviceModelName.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.deviceManufacturerName.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMarketMetadataRequestProto {
        GetMarketMetadataRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "lastRequestTime",
                |m: &GetMarketMetadataRequestProto| { &m.lastRequestTime },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.lastRequestTime },
                GetMarketMetadataRequestProto::get_lastRequestTime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfigurationProto>, _>(
                "deviceConfiguration",
                |m: &GetMarketMetadataRequestProto| { &m.deviceConfiguration },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.deviceConfiguration },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "deviceRoaming",
                |m: &GetMarketMetadataRequestProto| { &m.deviceRoaming },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.deviceRoaming },
                GetMarketMetadataRequestProto::get_deviceRoaming,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "marketSignatureHash",
                |m: &GetMarketMetadataRequestProto| { &m.marketSignatureHash },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.marketSignatureHash },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "contentRating",
                |m: &GetMarketMetadataRequestProto| { &m.contentRating },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.contentRating },
                GetMarketMetadataRequestProto::get_contentRating,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "deviceModelName",
                |m: &GetMarketMetadataRequestProto| { &m.deviceModelName },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.deviceModelName },
                GetMarketMetadataRequestProto::get_deviceModelName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "deviceManufacturerName",
                |m: &GetMarketMetadataRequestProto| { &m.deviceManufacturerName },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.deviceManufacturerName },
                GetMarketMetadataRequestProto::get_deviceManufacturerName,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetMarketMetadataRequestProto>(
                "GetMarketMetadataRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetMarketMetadataRequestProto {
        static instance: ::protobuf::rt::Lazy<GetMarketMetadataRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetMarketMetadataRequestProto::new)
    }
}

impl ::protobuf::Clear for GetMarketMetadataRequestProto {
    fn clear(&mut self) {
        self.lastRequestTime = ::std::option::Option::None;
        self.deviceConfiguration.clear();
        self.deviceRoaming = ::std::option::Option::None;
        self.marketSignatureHash.clear();
        self.contentRating = ::std::option::Option::None;
        self.deviceModelName.clear();
        self.deviceManufacturerName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMarketMetadataRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMarketMetadataRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetMarketMetadataResponseProto {
    // message fields
    pub latestClientVersionCode: ::std::option::Option<i32>,
    pub latestClientUrl: ::protobuf::SingularField<::std::string::String>,
    pub paidAppsEnabled: ::std::option::Option<bool>,
    pub billingParameter: ::protobuf::RepeatedField<BillingParameterProto>,
    pub commentPostEnabled: ::std::option::Option<bool>,
    pub billingEventsEnabled: ::std::option::Option<bool>,
    pub warningMessage: ::protobuf::SingularField<::std::string::String>,
    pub inAppBillingEnabled: ::std::option::Option<bool>,
    pub inAppBillingMaxApiVersion: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetMarketMetadataResponseProto {
    pub fn new() -> GetMarketMetadataResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 latestClientVersionCode = 1;

    pub fn get_latestClientVersionCode(&self) -> i32 {
        self.latestClientVersionCode.unwrap_or(0)
    }

    // optional string latestClientUrl = 2;

    pub fn get_latestClientUrl(&self) -> &str {
        match self.latestClientUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool paidAppsEnabled = 3;

    pub fn get_paidAppsEnabled(&self) -> bool {
        self.paidAppsEnabled.unwrap_or(false)
    }

    // optional bool commentPostEnabled = 5;

    pub fn get_commentPostEnabled(&self) -> bool {
        self.commentPostEnabled.unwrap_or(false)
    }

    // optional bool billingEventsEnabled = 6;

    pub fn get_billingEventsEnabled(&self) -> bool {
        self.billingEventsEnabled.unwrap_or(false)
    }

    // optional string warningMessage = 7;

    pub fn get_warningMessage(&self) -> &str {
        match self.warningMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool inAppBillingEnabled = 8;

    pub fn get_inAppBillingEnabled(&self) -> bool {
        self.inAppBillingEnabled.unwrap_or(false)
    }

    // optional int32 inAppBillingMaxApiVersion = 9;

    pub fn get_inAppBillingMaxApiVersion(&self) -> i32 {
        self.inAppBillingMaxApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetMarketMetadataResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.billingParameter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.latestClientVersionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.latestClientUrl)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.paidAppsEnabled = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.billingParameter)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.commentPostEnabled = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.billingEventsEnabled = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.warningMessage)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inAppBillingEnabled = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inAppBillingMaxApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.latestClientVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latestClientUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.paidAppsEnabled {
            my_size += 2;
        }
        for value in &self.billingParameter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.commentPostEnabled {
            my_size += 2;
        }
        if let Some(v) = self.billingEventsEnabled {
            my_size += 2;
        }
        if let Some(v) = self.warningMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.inAppBillingEnabled {
            my_size += 2;
        }
        if let Some(v) = self.inAppBillingMaxApiVersion {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.latestClientVersionCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.latestClientUrl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.paidAppsEnabled {
            os.write_bool(3, v)?;
        }
        for v in &self.billingParameter {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.commentPostEnabled {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.billingEventsEnabled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.warningMessage.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.inAppBillingEnabled {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.inAppBillingMaxApiVersion {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMarketMetadataResponseProto {
        GetMarketMetadataResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "latestClientVersionCode",
                |m: &GetMarketMetadataResponseProto| { &m.latestClientVersionCode },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.latestClientVersionCode },
                GetMarketMetadataResponseProto::get_latestClientVersionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "latestClientUrl",
                |m: &GetMarketMetadataResponseProto| { &m.latestClientUrl },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.latestClientUrl },
                GetMarketMetadataResponseProto::get_latestClientUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "paidAppsEnabled",
                |m: &GetMarketMetadataResponseProto| { &m.paidAppsEnabled },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.paidAppsEnabled },
                GetMarketMetadataResponseProto::get_paidAppsEnabled,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingParameterProto>>(
                "billingParameter",
                |m: &GetMarketMetadataResponseProto| { &m.billingParameter },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.billingParameter },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "commentPostEnabled",
                |m: &GetMarketMetadataResponseProto| { &m.commentPostEnabled },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.commentPostEnabled },
                GetMarketMetadataResponseProto::get_commentPostEnabled,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "billingEventsEnabled",
                |m: &GetMarketMetadataResponseProto| { &m.billingEventsEnabled },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.billingEventsEnabled },
                GetMarketMetadataResponseProto::get_billingEventsEnabled,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "warningMessage",
                |m: &GetMarketMetadataResponseProto| { &m.warningMessage },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.warningMessage },
                GetMarketMetadataResponseProto::get_warningMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "inAppBillingEnabled",
                |m: &GetMarketMetadataResponseProto| { &m.inAppBillingEnabled },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.inAppBillingEnabled },
                GetMarketMetadataResponseProto::get_inAppBillingEnabled,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "inAppBillingMaxApiVersion",
                |m: &GetMarketMetadataResponseProto| { &m.inAppBillingMaxApiVersion },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.inAppBillingMaxApiVersion },
                GetMarketMetadataResponseProto::get_inAppBillingMaxApiVersion,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetMarketMetadataResponseProto>(
                "GetMarketMetadataResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetMarketMetadataResponseProto {
        static instance: ::protobuf::rt::Lazy<GetMarketMetadataResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetMarketMetadataResponseProto::new)
    }
}

impl ::protobuf::Clear for GetMarketMetadataResponseProto {
    fn clear(&mut self) {
        self.latestClientVersionCode = ::std::option::Option::None;
        self.latestClientUrl.clear();
        self.paidAppsEnabled = ::std::option::Option::None;
        self.billingParameter.clear();
        self.commentPostEnabled = ::std::option::Option::None;
        self.billingEventsEnabled = ::std::option::Option::None;
        self.warningMessage.clear();
        self.inAppBillingEnabled = ::std::option::Option::None;
        self.inAppBillingMaxApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMarketMetadataResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMarketMetadataResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetSubCategoriesRequestProto {
    // message fields
    pub assetType: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetSubCategoriesRequestProto {
    pub fn new() -> GetSubCategoriesRequestProto {
        ::std::default::Default::default()
    }

    // optional int32 assetType = 1;

    pub fn get_assetType(&self) -> i32 {
        self.assetType.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetSubCategoriesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetType {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSubCategoriesRequestProto {
        GetSubCategoriesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "assetType",
                |m: &GetSubCategoriesRequestProto| { &m.assetType },
                |m: &mut GetSubCategoriesRequestProto| { &mut m.assetType },
                GetSubCategoriesRequestProto::get_assetType,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetSubCategoriesRequestProto>(
                "GetSubCategoriesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSubCategoriesRequestProto {
        static instance: ::protobuf::rt::Lazy<GetSubCategoriesRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetSubCategoriesRequestProto::new)
    }
}

impl ::protobuf::Clear for GetSubCategoriesRequestProto {
    fn clear(&mut self) {
        self.assetType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSubCategoriesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubCategoriesRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetSubCategoriesResponseProto {
    // message fields
    // subcategory: <group>
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetSubCategoriesResponseProto {
    pub fn new() -> GetSubCategoriesResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSubCategoriesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSubCategoriesResponseProto {
        GetSubCategoriesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<GetSubCategoriesResponseProto>(
                "GetSubCategoriesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSubCategoriesResponseProto {
        static instance: ::protobuf::rt::Lazy<GetSubCategoriesResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetSubCategoriesResponseProto::new)
    }
}

impl ::protobuf::Clear for GetSubCategoriesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSubCategoriesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubCategoriesResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct GetSubCategoriesResponseProto_SubCategory {
    // message fields
    pub subCategoryDisplay: ::protobuf::SingularField<::std::string::String>,
    pub subCategoryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl GetSubCategoriesResponseProto_SubCategory {
    pub fn new() -> GetSubCategoriesResponseProto_SubCategory {
        ::std::default::Default::default()
    }

    // optional string subCategoryDisplay = 2;

    pub fn get_subCategoryDisplay(&self) -> &str {
        match self.subCategoryDisplay.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string subCategoryId = 3;

    pub fn get_subCategoryId(&self) -> &str {
        match self.subCategoryId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetSubCategoriesResponseProto_SubCategory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subCategoryDisplay)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subCategoryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subCategoryDisplay.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.subCategoryId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subCategoryDisplay.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.subCategoryId.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSubCategoriesResponseProto_SubCategory {
        GetSubCategoriesResponseProto_SubCategory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subCategoryDisplay",
                |m: &GetSubCategoriesResponseProto_SubCategory| { &m.subCategoryDisplay },
                |m: &mut GetSubCategoriesResponseProto_SubCategory| { &mut m.subCategoryDisplay },
                GetSubCategoriesResponseProto_SubCategory::get_subCategoryDisplay,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "subCategoryId",
                |m: &GetSubCategoriesResponseProto_SubCategory| { &m.subCategoryId },
                |m: &mut GetSubCategoriesResponseProto_SubCategory| { &mut m.subCategoryId },
                GetSubCategoriesResponseProto_SubCategory::get_subCategoryId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<GetSubCategoriesResponseProto_SubCategory>(
                "GetSubCategoriesResponseProto_SubCategory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSubCategoriesResponseProto_SubCategory {
        static instance: ::protobuf::rt::Lazy<GetSubCategoriesResponseProto_SubCategory> = ::protobuf::rt::Lazy::INIT;
        instance.get(GetSubCategoriesResponseProto_SubCategory::new)
    }
}

impl ::protobuf::Clear for GetSubCategoriesResponseProto_SubCategory {
    fn clear(&mut self) {
        self.subCategoryDisplay.clear();
        self.subCategoryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSubCategoriesResponseProto_SubCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubCategoriesResponseProto_SubCategory {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InAppPurchaseInformationRequestProto {
    // message fields
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    pub nonce: ::std::option::Option<i64>,
    pub notificationId: ::protobuf::RepeatedField<::std::string::String>,
    pub signatureAlgorithm: ::protobuf::SingularField<::std::string::String>,
    pub billingApiVersion: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InAppPurchaseInformationRequestProto {
    pub fn new() -> InAppPurchaseInformationRequestProto {
        ::std::default::Default::default()
    }

    // optional int64 nonce = 2;

    pub fn get_nonce(&self) -> i64 {
        self.nonce.unwrap_or(0)
    }

    // optional string signatureAlgorithm = 4;

    pub fn get_signatureAlgorithm(&self) -> &str {
        match self.signatureAlgorithm.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 billingApiVersion = 5;

    pub fn get_billingApiVersion(&self) -> i32 {
        self.billingApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for InAppPurchaseInformationRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<SignatureHashProto, _>(wire_type, is, &mut self.signatureHash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.notificationId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signatureAlgorithm)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nonce {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.notificationId {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.signatureAlgorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.billingApiVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.signatureHash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.nonce {
            os.write_int64(2, v)?;
        }
        for v in &self.notificationId {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.signatureAlgorithm.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.billingApiVersion {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppPurchaseInformationRequestProto {
        InAppPurchaseInformationRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>, _>(
                "signatureHash",
                |m: &InAppPurchaseInformationRequestProto| { &m.signatureHash },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.signatureHash },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "nonce",
                |m: &InAppPurchaseInformationRequestProto| { &m.nonce },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.nonce },
                InAppPurchaseInformationRequestProto::get_nonce,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationId",
                |m: &InAppPurchaseInformationRequestProto| { &m.notificationId },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.notificationId },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signatureAlgorithm",
                |m: &InAppPurchaseInformationRequestProto| { &m.signatureAlgorithm },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.signatureAlgorithm },
                InAppPurchaseInformationRequestProto::get_signatureAlgorithm,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "billingApiVersion",
                |m: &InAppPurchaseInformationRequestProto| { &m.billingApiVersion },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.billingApiVersion },
                InAppPurchaseInformationRequestProto::get_billingApiVersion,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InAppPurchaseInformationRequestProto>(
                "InAppPurchaseInformationRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppPurchaseInformationRequestProto {
        static instance: ::protobuf::rt::Lazy<InAppPurchaseInformationRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(InAppPurchaseInformationRequestProto::new)
    }
}

impl ::protobuf::Clear for InAppPurchaseInformationRequestProto {
    fn clear(&mut self) {
        self.signatureHash.clear();
        self.nonce = ::std::option::Option::None;
        self.notificationId.clear();
        self.signatureAlgorithm.clear();
        self.billingApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppPurchaseInformationRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppPurchaseInformationRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InAppPurchaseInformationResponseProto {
    // message fields
    pub signedResponse: ::protobuf::SingularPtrField<SignedDataProto>,
    pub statusBarNotification: ::protobuf::RepeatedField<StatusBarNotificationProto>,
    pub purchaseResult: ::protobuf::SingularPtrField<PurchaseResultProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InAppPurchaseInformationResponseProto {
    pub fn new() -> InAppPurchaseInformationResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InAppPurchaseInformationResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signedResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statusBarNotification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<SignedDataProto, _>(wire_type, is, &mut self.signedResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.statusBarNotification)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseResultProto, _>(wire_type, is, &mut self.purchaseResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.signedResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.statusBarNotification {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.purchaseResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.signedResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.statusBarNotification {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.purchaseResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppPurchaseInformationResponseProto {
        InAppPurchaseInformationResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignedDataProto>, _>(
                "signedResponse",
                |m: &InAppPurchaseInformationResponseProto| { &m.signedResponse },
                |m: &mut InAppPurchaseInformationResponseProto| { &mut m.signedResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusBarNotificationProto>>(
                "statusBarNotification",
                |m: &InAppPurchaseInformationResponseProto| { &m.statusBarNotification },
                |m: &mut InAppPurchaseInformationResponseProto| { &mut m.statusBarNotification },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseResultProto>, _>(
                "purchaseResult",
                |m: &InAppPurchaseInformationResponseProto| { &m.purchaseResult },
                |m: &mut InAppPurchaseInformationResponseProto| { &mut m.purchaseResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InAppPurchaseInformationResponseProto>(
                "InAppPurchaseInformationResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppPurchaseInformationResponseProto {
        static instance: ::protobuf::rt::Lazy<InAppPurchaseInformationResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(InAppPurchaseInformationResponseProto::new)
    }
}

impl ::protobuf::Clear for InAppPurchaseInformationResponseProto {
    fn clear(&mut self) {
        self.signedResponse.clear();
        self.statusBarNotification.clear();
        self.purchaseResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppPurchaseInformationResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppPurchaseInformationResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InAppRestoreTransactionsRequestProto {
    // message fields
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    pub nonce: ::std::option::Option<i64>,
    pub signatureAlgorithm: ::protobuf::SingularField<::std::string::String>,
    pub billingApiVersion: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InAppRestoreTransactionsRequestProto {
    pub fn new() -> InAppRestoreTransactionsRequestProto {
        ::std::default::Default::default()
    }

    // optional int64 nonce = 2;

    pub fn get_nonce(&self) -> i64 {
        self.nonce.unwrap_or(0)
    }

    // optional string signatureAlgorithm = 3;

    pub fn get_signatureAlgorithm(&self) -> &str {
        match self.signatureAlgorithm.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 billingApiVersion = 4;

    pub fn get_billingApiVersion(&self) -> i32 {
        self.billingApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for InAppRestoreTransactionsRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<SignatureHashProto, _>(wire_type, is, &mut self.signatureHash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signatureAlgorithm)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nonce {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signatureAlgorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.billingApiVersion {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.signatureHash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.nonce {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.signatureAlgorithm.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.billingApiVersion {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppRestoreTransactionsRequestProto {
        InAppRestoreTransactionsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>, _>(
                "signatureHash",
                |m: &InAppRestoreTransactionsRequestProto| { &m.signatureHash },
                |m: &mut InAppRestoreTransactionsRequestProto| { &mut m.signatureHash },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "nonce",
                |m: &InAppRestoreTransactionsRequestProto| { &m.nonce },
                |m: &mut InAppRestoreTransactionsRequestProto| { &mut m.nonce },
                InAppRestoreTransactionsRequestProto::get_nonce,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signatureAlgorithm",
                |m: &InAppRestoreTransactionsRequestProto| { &m.signatureAlgorithm },
                |m: &mut InAppRestoreTransactionsRequestProto| { &mut m.signatureAlgorithm },
                InAppRestoreTransactionsRequestProto::get_signatureAlgorithm,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "billingApiVersion",
                |m: &InAppRestoreTransactionsRequestProto| { &m.billingApiVersion },
                |m: &mut InAppRestoreTransactionsRequestProto| { &mut m.billingApiVersion },
                InAppRestoreTransactionsRequestProto::get_billingApiVersion,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InAppRestoreTransactionsRequestProto>(
                "InAppRestoreTransactionsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppRestoreTransactionsRequestProto {
        static instance: ::protobuf::rt::Lazy<InAppRestoreTransactionsRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(InAppRestoreTransactionsRequestProto::new)
    }
}

impl ::protobuf::Clear for InAppRestoreTransactionsRequestProto {
    fn clear(&mut self) {
        self.signatureHash.clear();
        self.nonce = ::std::option::Option::None;
        self.signatureAlgorithm.clear();
        self.billingApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppRestoreTransactionsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppRestoreTransactionsRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct InAppRestoreTransactionsResponseProto {
    // message fields
    pub signedResponse: ::protobuf::SingularPtrField<SignedDataProto>,
    pub purchaseResult: ::protobuf::SingularPtrField<PurchaseResultProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl InAppRestoreTransactionsResponseProto {
    pub fn new() -> InAppRestoreTransactionsResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InAppRestoreTransactionsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signedResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<SignedDataProto, _>(wire_type, is, &mut self.signedResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseResultProto, _>(wire_type, is, &mut self.purchaseResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.signedResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.signedResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.purchaseResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppRestoreTransactionsResponseProto {
        InAppRestoreTransactionsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignedDataProto>, _>(
                "signedResponse",
                |m: &InAppRestoreTransactionsResponseProto| { &m.signedResponse },
                |m: &mut InAppRestoreTransactionsResponseProto| { &mut m.signedResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseResultProto>, _>(
                "purchaseResult",
                |m: &InAppRestoreTransactionsResponseProto| { &m.purchaseResult },
                |m: &mut InAppRestoreTransactionsResponseProto| { &mut m.purchaseResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<InAppRestoreTransactionsResponseProto>(
                "InAppRestoreTransactionsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppRestoreTransactionsResponseProto {
        static instance: ::protobuf::rt::Lazy<InAppRestoreTransactionsResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(InAppRestoreTransactionsResponseProto::new)
    }
}

impl ::protobuf::Clear for InAppRestoreTransactionsResponseProto {
    fn clear(&mut self) {
        self.signedResponse.clear();
        self.purchaseResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppRestoreTransactionsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppRestoreTransactionsResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ModifyCommentRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub comment: ::protobuf::SingularPtrField<ExternalCommentProto>,
    pub deleteComment: ::std::option::Option<bool>,
    pub flagAsset: ::std::option::Option<bool>,
    pub flagType: ::std::option::Option<i32>,
    pub flagMessage: ::protobuf::SingularField<::std::string::String>,
    pub nonFlagFlow: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ModifyCommentRequestProto {
    pub fn new() -> ModifyCommentRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool deleteComment = 3;

    pub fn get_deleteComment(&self) -> bool {
        self.deleteComment.unwrap_or(false)
    }

    // optional bool flagAsset = 4;

    pub fn get_flagAsset(&self) -> bool {
        self.flagAsset.unwrap_or(false)
    }

    // optional int32 flagType = 5;

    pub fn get_flagType(&self) -> i32 {
        self.flagType.unwrap_or(0)
    }

    // optional string flagMessage = 6;

    pub fn get_flagMessage(&self) -> &str {
        match self.flagMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool nonFlagFlow = 7;

    pub fn get_nonFlagFlow(&self) -> bool {
        self.nonFlagFlow.unwrap_or(false)
    }
}

impl ::protobuf::Message for ModifyCommentRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.comment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalCommentProto, _>(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleteComment = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.flagAsset = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flagType = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.flagMessage)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.nonFlagFlow = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.comment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deleteComment {
            my_size += 2;
        }
        if let Some(v) = self.flagAsset {
            my_size += 2;
        }
        if let Some(v) = self.flagType {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flagMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.nonFlagFlow {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.deleteComment {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.flagAsset {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.flagType {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.flagMessage.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.nonFlagFlow {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCommentRequestProto {
        ModifyCommentRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &ModifyCommentRequestProto| { &m.assetId },
                |m: &mut ModifyCommentRequestProto| { &mut m.assetId },
                ModifyCommentRequestProto::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCommentProto>, _>(
                "comment",
                |m: &ModifyCommentRequestProto| { &m.comment },
                |m: &mut ModifyCommentRequestProto| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "deleteComment",
                |m: &ModifyCommentRequestProto| { &m.deleteComment },
                |m: &mut ModifyCommentRequestProto| { &mut m.deleteComment },
                ModifyCommentRequestProto::get_deleteComment,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "flagAsset",
                |m: &ModifyCommentRequestProto| { &m.flagAsset },
                |m: &mut ModifyCommentRequestProto| { &mut m.flagAsset },
                ModifyCommentRequestProto::get_flagAsset,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "flagType",
                |m: &ModifyCommentRequestProto| { &m.flagType },
                |m: &mut ModifyCommentRequestProto| { &mut m.flagType },
                ModifyCommentRequestProto::get_flagType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "flagMessage",
                |m: &ModifyCommentRequestProto| { &m.flagMessage },
                |m: &mut ModifyCommentRequestProto| { &mut m.flagMessage },
                ModifyCommentRequestProto::get_flagMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "nonFlagFlow",
                |m: &ModifyCommentRequestProto| { &m.nonFlagFlow },
                |m: &mut ModifyCommentRequestProto| { &mut m.nonFlagFlow },
                ModifyCommentRequestProto::get_nonFlagFlow,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ModifyCommentRequestProto>(
                "ModifyCommentRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyCommentRequestProto {
        static instance: ::protobuf::rt::Lazy<ModifyCommentRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ModifyCommentRequestProto::new)
    }
}

impl ::protobuf::Clear for ModifyCommentRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.comment.clear();
        self.deleteComment = ::std::option::Option::None;
        self.flagAsset = ::std::option::Option::None;
        self.flagType = ::std::option::Option::None;
        self.flagMessage.clear();
        self.nonFlagFlow = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCommentRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCommentRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ModifyCommentResponseProto {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ModifyCommentResponseProto {
    pub fn new() -> ModifyCommentResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModifyCommentResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCommentResponseProto {
        ModifyCommentResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<ModifyCommentResponseProto>(
                "ModifyCommentResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyCommentResponseProto {
        static instance: ::protobuf::rt::Lazy<ModifyCommentResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ModifyCommentResponseProto::new)
    }
}

impl ::protobuf::Clear for ModifyCommentResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCommentResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCommentResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalCountryInfoProto {
    // message fields
    pub birthDateRequired: ::std::option::Option<bool>,
    pub tosText: ::protobuf::SingularField<::std::string::String>,
    pub billingAgreementText: ::protobuf::SingularField<::std::string::String>,
    pub preTosText: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalCountryInfoProto {
    pub fn new() -> PaypalCountryInfoProto {
        ::std::default::Default::default()
    }

    // optional bool birthDateRequired = 1;

    pub fn get_birthDateRequired(&self) -> bool {
        self.birthDateRequired.unwrap_or(false)
    }

    // optional string tosText = 2;

    pub fn get_tosText(&self) -> &str {
        match self.tosText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string billingAgreementText = 3;

    pub fn get_billingAgreementText(&self) -> &str {
        match self.billingAgreementText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string preTosText = 4;

    pub fn get_preTosText(&self) -> &str {
        match self.preTosText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalCountryInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.birthDateRequired = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosText)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingAgreementText)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preTosText)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.birthDateRequired {
            my_size += 2;
        }
        if let Some(v) = self.tosText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.billingAgreementText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.preTosText.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.birthDateRequired {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.tosText.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.billingAgreementText.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.preTosText.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalCountryInfoProto {
        PaypalCountryInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "birthDateRequired",
                |m: &PaypalCountryInfoProto| { &m.birthDateRequired },
                |m: &mut PaypalCountryInfoProto| { &mut m.birthDateRequired },
                PaypalCountryInfoProto::get_birthDateRequired,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tosText",
                |m: &PaypalCountryInfoProto| { &m.tosText },
                |m: &mut PaypalCountryInfoProto| { &mut m.tosText },
                PaypalCountryInfoProto::get_tosText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "billingAgreementText",
                |m: &PaypalCountryInfoProto| { &m.billingAgreementText },
                |m: &mut PaypalCountryInfoProto| { &mut m.billingAgreementText },
                PaypalCountryInfoProto::get_billingAgreementText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "preTosText",
                |m: &PaypalCountryInfoProto| { &m.preTosText },
                |m: &mut PaypalCountryInfoProto| { &mut m.preTosText },
                PaypalCountryInfoProto::get_preTosText,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalCountryInfoProto>(
                "PaypalCountryInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalCountryInfoProto {
        static instance: ::protobuf::rt::Lazy<PaypalCountryInfoProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalCountryInfoProto::new)
    }
}

impl ::protobuf::Clear for PaypalCountryInfoProto {
    fn clear(&mut self) {
        self.birthDateRequired = ::std::option::Option::None;
        self.tosText.clear();
        self.billingAgreementText.clear();
        self.preTosText.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalCountryInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalCountryInfoProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalCreateAccountRequestProto {
    // message fields
    pub firstName: ::protobuf::SingularField<::std::string::String>,
    pub lastName: ::protobuf::SingularField<::std::string::String>,
    pub address: ::protobuf::SingularPtrField<AddressProto>,
    pub birthDate: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalCreateAccountRequestProto {
    pub fn new() -> PaypalCreateAccountRequestProto {
        ::std::default::Default::default()
    }

    // optional string firstName = 1;

    pub fn get_firstName(&self) -> &str {
        match self.firstName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string lastName = 2;

    pub fn get_lastName(&self) -> &str {
        match self.lastName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string birthDate = 4;

    pub fn get_birthDate(&self) -> &str {
        match self.birthDate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalCreateAccountRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.firstName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<AddressProto, _>(wire_type, is, &mut self.address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.birthDate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.firstName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.lastName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.birthDate.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.firstName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.lastName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.birthDate.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalCreateAccountRequestProto {
        PaypalCreateAccountRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "firstName",
                |m: &PaypalCreateAccountRequestProto| { &m.firstName },
                |m: &mut PaypalCreateAccountRequestProto| { &mut m.firstName },
                PaypalCreateAccountRequestProto::get_firstName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "lastName",
                |m: &PaypalCreateAccountRequestProto| { &m.lastName },
                |m: &mut PaypalCreateAccountRequestProto| { &mut m.lastName },
                PaypalCreateAccountRequestProto::get_lastName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>, _>(
                "address",
                |m: &PaypalCreateAccountRequestProto| { &m.address },
                |m: &mut PaypalCreateAccountRequestProto| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "birthDate",
                |m: &PaypalCreateAccountRequestProto| { &m.birthDate },
                |m: &mut PaypalCreateAccountRequestProto| { &mut m.birthDate },
                PaypalCreateAccountRequestProto::get_birthDate,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalCreateAccountRequestProto>(
                "PaypalCreateAccountRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalCreateAccountRequestProto {
        static instance: ::protobuf::rt::Lazy<PaypalCreateAccountRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalCreateAccountRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalCreateAccountRequestProto {
    fn clear(&mut self) {
        self.firstName.clear();
        self.lastName.clear();
        self.address.clear();
        self.birthDate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalCreateAccountRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalCreateAccountRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalCreateAccountResponseProto {
    // message fields
    pub createAccountKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalCreateAccountResponseProto {
    pub fn new() -> PaypalCreateAccountResponseProto {
        ::std::default::Default::default()
    }

    // optional string createAccountKey = 1;

    pub fn get_createAccountKey(&self) -> &str {
        match self.createAccountKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalCreateAccountResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.createAccountKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.createAccountKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.createAccountKey.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalCreateAccountResponseProto {
        PaypalCreateAccountResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "createAccountKey",
                |m: &PaypalCreateAccountResponseProto| { &m.createAccountKey },
                |m: &mut PaypalCreateAccountResponseProto| { &mut m.createAccountKey },
                PaypalCreateAccountResponseProto::get_createAccountKey,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalCreateAccountResponseProto>(
                "PaypalCreateAccountResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalCreateAccountResponseProto {
        static instance: ::protobuf::rt::Lazy<PaypalCreateAccountResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalCreateAccountResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalCreateAccountResponseProto {
    fn clear(&mut self) {
        self.createAccountKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalCreateAccountResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalCreateAccountResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalCredentialsProto {
    // message fields
    pub preapprovalKey: ::protobuf::SingularField<::std::string::String>,
    pub paypalEmail: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalCredentialsProto {
    pub fn new() -> PaypalCredentialsProto {
        ::std::default::Default::default()
    }

    // optional string preapprovalKey = 1;

    pub fn get_preapprovalKey(&self) -> &str {
        match self.preapprovalKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string paypalEmail = 2;

    pub fn get_paypalEmail(&self) -> &str {
        match self.paypalEmail.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalCredentialsProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preapprovalKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalEmail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.preapprovalKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.paypalEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.preapprovalKey.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.paypalEmail.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalCredentialsProto {
        PaypalCredentialsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "preapprovalKey",
                |m: &PaypalCredentialsProto| { &m.preapprovalKey },
                |m: &mut PaypalCredentialsProto| { &mut m.preapprovalKey },
                PaypalCredentialsProto::get_preapprovalKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "paypalEmail",
                |m: &PaypalCredentialsProto| { &m.paypalEmail },
                |m: &mut PaypalCredentialsProto| { &mut m.paypalEmail },
                PaypalCredentialsProto::get_paypalEmail,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalCredentialsProto>(
                "PaypalCredentialsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalCredentialsProto {
        static instance: ::protobuf::rt::Lazy<PaypalCredentialsProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalCredentialsProto::new)
    }
}

impl ::protobuf::Clear for PaypalCredentialsProto {
    fn clear(&mut self) {
        self.preapprovalKey.clear();
        self.paypalEmail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalCredentialsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalCredentialsProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalMassageAddressRequestProto {
    // message fields
    pub address: ::protobuf::SingularPtrField<AddressProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalMassageAddressRequestProto {
    pub fn new() -> PaypalMassageAddressRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PaypalMassageAddressRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<AddressProto, _>(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalMassageAddressRequestProto {
        PaypalMassageAddressRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>, _>(
                "address",
                |m: &PaypalMassageAddressRequestProto| { &m.address },
                |m: &mut PaypalMassageAddressRequestProto| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalMassageAddressRequestProto>(
                "PaypalMassageAddressRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalMassageAddressRequestProto {
        static instance: ::protobuf::rt::Lazy<PaypalMassageAddressRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalMassageAddressRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalMassageAddressRequestProto {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalMassageAddressRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalMassageAddressRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalMassageAddressResponseProto {
    // message fields
    pub address: ::protobuf::SingularPtrField<AddressProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalMassageAddressResponseProto {
    pub fn new() -> PaypalMassageAddressResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PaypalMassageAddressResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<AddressProto, _>(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalMassageAddressResponseProto {
        PaypalMassageAddressResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>, _>(
                "address",
                |m: &PaypalMassageAddressResponseProto| { &m.address },
                |m: &mut PaypalMassageAddressResponseProto| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalMassageAddressResponseProto>(
                "PaypalMassageAddressResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalMassageAddressResponseProto {
        static instance: ::protobuf::rt::Lazy<PaypalMassageAddressResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalMassageAddressResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalMassageAddressResponseProto {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalMassageAddressResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalMassageAddressResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalPreapprovalCredentialsRequestProto {
    // message fields
    pub gaiaAuthToken: ::protobuf::SingularField<::std::string::String>,
    pub billingInstrumentId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalPreapprovalCredentialsRequestProto {
    pub fn new() -> PaypalPreapprovalCredentialsRequestProto {
        ::std::default::Default::default()
    }

    // optional string gaiaAuthToken = 1;

    pub fn get_gaiaAuthToken(&self) -> &str {
        match self.gaiaAuthToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string billingInstrumentId = 2;

    pub fn get_billingInstrumentId(&self) -> &str {
        match self.billingInstrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalCredentialsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaAuthToken)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingInstrumentId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gaiaAuthToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.billingInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gaiaAuthToken.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.billingInstrumentId.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalCredentialsRequestProto {
        PaypalPreapprovalCredentialsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gaiaAuthToken",
                |m: &PaypalPreapprovalCredentialsRequestProto| { &m.gaiaAuthToken },
                |m: &mut PaypalPreapprovalCredentialsRequestProto| { &mut m.gaiaAuthToken },
                PaypalPreapprovalCredentialsRequestProto::get_gaiaAuthToken,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "billingInstrumentId",
                |m: &PaypalPreapprovalCredentialsRequestProto| { &m.billingInstrumentId },
                |m: &mut PaypalPreapprovalCredentialsRequestProto| { &mut m.billingInstrumentId },
                PaypalPreapprovalCredentialsRequestProto::get_billingInstrumentId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalPreapprovalCredentialsRequestProto>(
                "PaypalPreapprovalCredentialsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalCredentialsRequestProto {
        static instance: ::protobuf::rt::Lazy<PaypalPreapprovalCredentialsRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalPreapprovalCredentialsRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalCredentialsRequestProto {
    fn clear(&mut self) {
        self.gaiaAuthToken.clear();
        self.billingInstrumentId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalCredentialsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalCredentialsRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalPreapprovalCredentialsResponseProto {
    // message fields
    pub resultCode: ::std::option::Option<i32>,
    pub paypalAccountKey: ::protobuf::SingularField<::std::string::String>,
    pub paypalEmail: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalPreapprovalCredentialsResponseProto {
    pub fn new() -> PaypalPreapprovalCredentialsResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 resultCode = 1;

    pub fn get_resultCode(&self) -> i32 {
        self.resultCode.unwrap_or(0)
    }

    // optional string paypalAccountKey = 2;

    pub fn get_paypalAccountKey(&self) -> &str {
        match self.paypalAccountKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string paypalEmail = 3;

    pub fn get_paypalEmail(&self) -> &str {
        match self.paypalEmail.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalCredentialsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.resultCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalAccountKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalEmail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.resultCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.paypalAccountKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.paypalEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.resultCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.paypalAccountKey.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.paypalEmail.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalCredentialsResponseProto {
        PaypalPreapprovalCredentialsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "resultCode",
                |m: &PaypalPreapprovalCredentialsResponseProto| { &m.resultCode },
                |m: &mut PaypalPreapprovalCredentialsResponseProto| { &mut m.resultCode },
                PaypalPreapprovalCredentialsResponseProto::get_resultCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "paypalAccountKey",
                |m: &PaypalPreapprovalCredentialsResponseProto| { &m.paypalAccountKey },
                |m: &mut PaypalPreapprovalCredentialsResponseProto| { &mut m.paypalAccountKey },
                PaypalPreapprovalCredentialsResponseProto::get_paypalAccountKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "paypalEmail",
                |m: &PaypalPreapprovalCredentialsResponseProto| { &m.paypalEmail },
                |m: &mut PaypalPreapprovalCredentialsResponseProto| { &mut m.paypalEmail },
                PaypalPreapprovalCredentialsResponseProto::get_paypalEmail,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalPreapprovalCredentialsResponseProto>(
                "PaypalPreapprovalCredentialsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalCredentialsResponseProto {
        static instance: ::protobuf::rt::Lazy<PaypalPreapprovalCredentialsResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalPreapprovalCredentialsResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalCredentialsResponseProto {
    fn clear(&mut self) {
        self.resultCode = ::std::option::Option::None;
        self.paypalAccountKey.clear();
        self.paypalEmail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalCredentialsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalCredentialsResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalPreapprovalDetailsRequestProto {
    // message fields
    pub getAddress: ::std::option::Option<bool>,
    pub preapprovalKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalPreapprovalDetailsRequestProto {
    pub fn new() -> PaypalPreapprovalDetailsRequestProto {
        ::std::default::Default::default()
    }

    // optional bool getAddress = 1;

    pub fn get_getAddress(&self) -> bool {
        self.getAddress.unwrap_or(false)
    }

    // optional string preapprovalKey = 2;

    pub fn get_preapprovalKey(&self) -> &str {
        match self.preapprovalKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalDetailsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.getAddress = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preapprovalKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.getAddress {
            my_size += 2;
        }
        if let Some(v) = self.preapprovalKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.getAddress {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.preapprovalKey.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalDetailsRequestProto {
        PaypalPreapprovalDetailsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "getAddress",
                |m: &PaypalPreapprovalDetailsRequestProto| { &m.getAddress },
                |m: &mut PaypalPreapprovalDetailsRequestProto| { &mut m.getAddress },
                PaypalPreapprovalDetailsRequestProto::get_getAddress,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "preapprovalKey",
                |m: &PaypalPreapprovalDetailsRequestProto| { &m.preapprovalKey },
                |m: &mut PaypalPreapprovalDetailsRequestProto| { &mut m.preapprovalKey },
                PaypalPreapprovalDetailsRequestProto::get_preapprovalKey,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalPreapprovalDetailsRequestProto>(
                "PaypalPreapprovalDetailsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalDetailsRequestProto {
        static instance: ::protobuf::rt::Lazy<PaypalPreapprovalDetailsRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalPreapprovalDetailsRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalDetailsRequestProto {
    fn clear(&mut self) {
        self.getAddress = ::std::option::Option::None;
        self.preapprovalKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalDetailsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalDetailsRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalPreapprovalDetailsResponseProto {
    // message fields
    pub paypalEmail: ::protobuf::SingularField<::std::string::String>,
    pub address: ::protobuf::SingularPtrField<AddressProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalPreapprovalDetailsResponseProto {
    pub fn new() -> PaypalPreapprovalDetailsResponseProto {
        ::std::default::Default::default()
    }

    // optional string paypalEmail = 1;

    pub fn get_paypalEmail(&self) -> &str {
        match self.paypalEmail.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalDetailsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalEmail)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<AddressProto, _>(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.paypalEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.paypalEmail.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalDetailsResponseProto {
        PaypalPreapprovalDetailsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "paypalEmail",
                |m: &PaypalPreapprovalDetailsResponseProto| { &m.paypalEmail },
                |m: &mut PaypalPreapprovalDetailsResponseProto| { &mut m.paypalEmail },
                PaypalPreapprovalDetailsResponseProto::get_paypalEmail,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>, _>(
                "address",
                |m: &PaypalPreapprovalDetailsResponseProto| { &m.address },
                |m: &mut PaypalPreapprovalDetailsResponseProto| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalPreapprovalDetailsResponseProto>(
                "PaypalPreapprovalDetailsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalDetailsResponseProto {
        static instance: ::protobuf::rt::Lazy<PaypalPreapprovalDetailsResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalPreapprovalDetailsResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalDetailsResponseProto {
    fn clear(&mut self) {
        self.paypalEmail.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalDetailsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalDetailsResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalPreapprovalRequestProto {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalPreapprovalRequestProto {
    pub fn new() -> PaypalPreapprovalRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PaypalPreapprovalRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalRequestProto {
        PaypalPreapprovalRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<PaypalPreapprovalRequestProto>(
                "PaypalPreapprovalRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalRequestProto {
        static instance: ::protobuf::rt::Lazy<PaypalPreapprovalRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalPreapprovalRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PaypalPreapprovalResponseProto {
    // message fields
    pub preapprovalKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PaypalPreapprovalResponseProto {
    pub fn new() -> PaypalPreapprovalResponseProto {
        ::std::default::Default::default()
    }

    // optional string preapprovalKey = 1;

    pub fn get_preapprovalKey(&self) -> &str {
        match self.preapprovalKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preapprovalKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.preapprovalKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.preapprovalKey.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalResponseProto {
        PaypalPreapprovalResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "preapprovalKey",
                |m: &PaypalPreapprovalResponseProto| { &m.preapprovalKey },
                |m: &mut PaypalPreapprovalResponseProto| { &mut m.preapprovalKey },
                PaypalPreapprovalResponseProto::get_preapprovalKey,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PaypalPreapprovalResponseProto>(
                "PaypalPreapprovalResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalResponseProto {
        static instance: ::protobuf::rt::Lazy<PaypalPreapprovalResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PaypalPreapprovalResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalResponseProto {
    fn clear(&mut self) {
        self.preapprovalKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PendingNotificationsProto {
    // message fields
    pub notification: ::protobuf::RepeatedField<DataMessageProto>,
    pub nextCheckMillis: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingNotificationsProto {
    pub fn new() -> PendingNotificationsProto {
        ::std::default::Default::default()
    }

    // optional int64 nextCheckMillis = 2;

    pub fn get_nextCheckMillis(&self) -> i64 {
        self.nextCheckMillis.unwrap_or(0)
    }
}

impl ::protobuf::Message for PendingNotificationsProto {
    fn is_initialized(&self) -> bool {
        for v in &self.notification {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.notification)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nextCheckMillis = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notification {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.nextCheckMillis {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notification {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.nextCheckMillis {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingNotificationsProto {
        PendingNotificationsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessageProto>>(
                "notification",
                |m: &PendingNotificationsProto| { &m.notification },
                |m: &mut PendingNotificationsProto| { &mut m.notification },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "nextCheckMillis",
                |m: &PendingNotificationsProto| { &m.nextCheckMillis },
                |m: &mut PendingNotificationsProto| { &mut m.nextCheckMillis },
                PendingNotificationsProto::get_nextCheckMillis,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PendingNotificationsProto>(
                "PendingNotificationsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingNotificationsProto {
        static instance: ::protobuf::rt::Lazy<PendingNotificationsProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PendingNotificationsProto::new)
    }
}

impl ::protobuf::Clear for PendingNotificationsProto {
    fn clear(&mut self) {
        self.notification.clear();
        self.nextCheckMillis = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingNotificationsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingNotificationsProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PrefetchedBundleProto {
    // message fields
    pub request: ::protobuf::SingularPtrField<SingleRequestProto>,
    pub response: ::protobuf::SingularPtrField<SingleResponseProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PrefetchedBundleProto {
    pub fn new() -> PrefetchedBundleProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrefetchedBundleProto {
    fn is_initialized(&self) -> bool {
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<SingleRequestProto, _>(wire_type, is, &mut self.request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<SingleResponseProto, _>(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrefetchedBundleProto {
        PrefetchedBundleProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SingleRequestProto>, _>(
                "request",
                |m: &PrefetchedBundleProto| { &m.request },
                |m: &mut PrefetchedBundleProto| { &mut m.request },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SingleResponseProto>, _>(
                "response",
                |m: &PrefetchedBundleProto| { &m.response },
                |m: &mut PrefetchedBundleProto| { &mut m.response },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PrefetchedBundleProto>(
                "PrefetchedBundleProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrefetchedBundleProto {
        static instance: ::protobuf::rt::Lazy<PrefetchedBundleProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PrefetchedBundleProto::new)
    }
}

impl ::protobuf::Clear for PrefetchedBundleProto {
    fn clear(&mut self) {
        self.request.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrefetchedBundleProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrefetchedBundleProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseCartInfoProto {
    // message fields
    pub itemPrice: ::protobuf::SingularField<::std::string::String>,
    pub taxInclusive: ::protobuf::SingularField<::std::string::String>,
    pub taxExclusive: ::protobuf::SingularField<::std::string::String>,
    pub total: ::protobuf::SingularField<::std::string::String>,
    pub taxMessage: ::protobuf::SingularField<::std::string::String>,
    pub footerMessage: ::protobuf::SingularField<::std::string::String>,
    pub priceCurrency: ::protobuf::SingularField<::std::string::String>,
    pub priceMicros: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseCartInfoProto {
    pub fn new() -> PurchaseCartInfoProto {
        ::std::default::Default::default()
    }

    // optional string itemPrice = 1;

    pub fn get_itemPrice(&self) -> &str {
        match self.itemPrice.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string taxInclusive = 2;

    pub fn get_taxInclusive(&self) -> &str {
        match self.taxInclusive.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string taxExclusive = 3;

    pub fn get_taxExclusive(&self) -> &str {
        match self.taxExclusive.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string total = 4;

    pub fn get_total(&self) -> &str {
        match self.total.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string taxMessage = 5;

    pub fn get_taxMessage(&self) -> &str {
        match self.taxMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string footerMessage = 6;

    pub fn get_footerMessage(&self) -> &str {
        match self.footerMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string priceCurrency = 7;

    pub fn get_priceCurrency(&self) -> &str {
        match self.priceCurrency.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int64 priceMicros = 8;

    pub fn get_priceMicros(&self) -> i64 {
        self.priceMicros.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseCartInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.itemPrice)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.taxInclusive)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.taxExclusive)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.total)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.taxMessage)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.footerMessage)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.priceCurrency)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.priceMicros = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.itemPrice.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.taxInclusive.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.taxExclusive.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.total.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.taxMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.footerMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.priceCurrency.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.priceMicros {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.itemPrice.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.taxInclusive.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.taxExclusive.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.total.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.taxMessage.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.footerMessage.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.priceCurrency.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.priceMicros {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseCartInfoProto {
        PurchaseCartInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "itemPrice",
                |m: &PurchaseCartInfoProto| { &m.itemPrice },
                |m: &mut PurchaseCartInfoProto| { &mut m.itemPrice },
                PurchaseCartInfoProto::get_itemPrice,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "taxInclusive",
                |m: &PurchaseCartInfoProto| { &m.taxInclusive },
                |m: &mut PurchaseCartInfoProto| { &mut m.taxInclusive },
                PurchaseCartInfoProto::get_taxInclusive,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "taxExclusive",
                |m: &PurchaseCartInfoProto| { &m.taxExclusive },
                |m: &mut PurchaseCartInfoProto| { &mut m.taxExclusive },
                PurchaseCartInfoProto::get_taxExclusive,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "total",
                |m: &PurchaseCartInfoProto| { &m.total },
                |m: &mut PurchaseCartInfoProto| { &mut m.total },
                PurchaseCartInfoProto::get_total,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "taxMessage",
                |m: &PurchaseCartInfoProto| { &m.taxMessage },
                |m: &mut PurchaseCartInfoProto| { &mut m.taxMessage },
                PurchaseCartInfoProto::get_taxMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "footerMessage",
                |m: &PurchaseCartInfoProto| { &m.footerMessage },
                |m: &mut PurchaseCartInfoProto| { &mut m.footerMessage },
                PurchaseCartInfoProto::get_footerMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "priceCurrency",
                |m: &PurchaseCartInfoProto| { &m.priceCurrency },
                |m: &mut PurchaseCartInfoProto| { &mut m.priceCurrency },
                PurchaseCartInfoProto::get_priceCurrency,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt64, _>(
                "priceMicros",
                |m: &PurchaseCartInfoProto| { &m.priceMicros },
                |m: &mut PurchaseCartInfoProto| { &mut m.priceMicros },
                PurchaseCartInfoProto::get_priceMicros,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseCartInfoProto>(
                "PurchaseCartInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseCartInfoProto {
        static instance: ::protobuf::rt::Lazy<PurchaseCartInfoProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseCartInfoProto::new)
    }
}

impl ::protobuf::Clear for PurchaseCartInfoProto {
    fn clear(&mut self) {
        self.itemPrice.clear();
        self.taxInclusive.clear();
        self.taxExclusive.clear();
        self.total.clear();
        self.taxMessage.clear();
        self.footerMessage.clear();
        self.priceCurrency.clear();
        self.priceMicros = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseCartInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseCartInfoProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseInfoProto {
    // message fields
    pub transactionId: ::protobuf::SingularField<::std::string::String>,
    pub cartInfo: ::protobuf::SingularPtrField<PurchaseCartInfoProto>,
    // billinginstruments: <group>
    pub errorInputFields: ::std::vec::Vec<i32>,
    pub refundPolicy: ::protobuf::SingularField<::std::string::String>,
    pub userCanAddGdd: ::std::option::Option<bool>,
    pub eligibleInstrumentTypes: ::std::vec::Vec<i32>,
    pub orderId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseInfoProto {
    pub fn new() -> PurchaseInfoProto {
        ::std::default::Default::default()
    }

    // optional string transactionId = 1;

    pub fn get_transactionId(&self) -> &str {
        match self.transactionId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string refundPolicy = 10;

    pub fn get_refundPolicy(&self) -> &str {
        match self.refundPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool userCanAddGdd = 12;

    pub fn get_userCanAddGdd(&self) -> bool {
        self.userCanAddGdd.unwrap_or(false)
    }

    // optional string orderId = 15;

    pub fn get_orderId(&self) -> &str {
        match self.orderId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.cartInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transactionId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseCartInfoProto, _>(wire_type, is, &mut self.cartInfo)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.errorInputFields)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.refundPolicy)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.userCanAddGdd = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.eligibleInstrumentTypes)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.orderId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.transactionId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.cartInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errorInputFields {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.refundPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.userCanAddGdd {
            my_size += 2;
        }
        for value in &self.eligibleInstrumentTypes {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.orderId.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.transactionId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.cartInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.errorInputFields {
            os.write_int32(9, *v)?;
        };
        if let Some(v) = self.refundPolicy.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.userCanAddGdd {
            os.write_bool(12, v)?;
        }
        for v in &self.eligibleInstrumentTypes {
            os.write_int32(13, *v)?;
        };
        if let Some(v) = self.orderId.as_ref() {
            os.write_string(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseInfoProto {
        PurchaseInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "transactionId",
                |m: &PurchaseInfoProto| { &m.transactionId },
                |m: &mut PurchaseInfoProto| { &mut m.transactionId },
                PurchaseInfoProto::get_transactionId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseCartInfoProto>, _>(
                "cartInfo",
                |m: &PurchaseInfoProto| { &m.cartInfo },
                |m: &mut PurchaseInfoProto| { &mut m.cartInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorInputFields",
                |m: &PurchaseInfoProto| { &m.errorInputFields },
                |m: &mut PurchaseInfoProto| { &mut m.errorInputFields },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "refundPolicy",
                |m: &PurchaseInfoProto| { &m.refundPolicy },
                |m: &mut PurchaseInfoProto| { &mut m.refundPolicy },
                PurchaseInfoProto::get_refundPolicy,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "userCanAddGdd",
                |m: &PurchaseInfoProto| { &m.userCanAddGdd },
                |m: &mut PurchaseInfoProto| { &mut m.userCanAddGdd },
                PurchaseInfoProto::get_userCanAddGdd,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eligibleInstrumentTypes",
                |m: &PurchaseInfoProto| { &m.eligibleInstrumentTypes },
                |m: &mut PurchaseInfoProto| { &mut m.eligibleInstrumentTypes },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "orderId",
                |m: &PurchaseInfoProto| { &m.orderId },
                |m: &mut PurchaseInfoProto| { &mut m.orderId },
                PurchaseInfoProto::get_orderId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseInfoProto>(
                "PurchaseInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseInfoProto {
        static instance: ::protobuf::rt::Lazy<PurchaseInfoProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseInfoProto::new)
    }
}

impl ::protobuf::Clear for PurchaseInfoProto {
    fn clear(&mut self) {
        self.transactionId.clear();
        self.cartInfo.clear();
        self.errorInputFields.clear();
        self.refundPolicy.clear();
        self.userCanAddGdd = ::std::option::Option::None;
        self.eligibleInstrumentTypes.clear();
        self.orderId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseInfoProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseInfoProto_BillingInstruments {
    // message fields
    // billinginstrument: <group>
    pub defaultBillingInstrumentId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseInfoProto_BillingInstruments {
    pub fn new() -> PurchaseInfoProto_BillingInstruments {
        ::std::default::Default::default()
    }

    // optional string defaultBillingInstrumentId = 8;

    pub fn get_defaultBillingInstrumentId(&self) -> &str {
        match self.defaultBillingInstrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseInfoProto_BillingInstruments {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.defaultBillingInstrumentId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.defaultBillingInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.defaultBillingInstrumentId.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseInfoProto_BillingInstruments {
        PurchaseInfoProto_BillingInstruments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "defaultBillingInstrumentId",
                |m: &PurchaseInfoProto_BillingInstruments| { &m.defaultBillingInstrumentId },
                |m: &mut PurchaseInfoProto_BillingInstruments| { &mut m.defaultBillingInstrumentId },
                PurchaseInfoProto_BillingInstruments::get_defaultBillingInstrumentId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseInfoProto_BillingInstruments>(
                "PurchaseInfoProto_BillingInstruments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseInfoProto_BillingInstruments {
        static instance: ::protobuf::rt::Lazy<PurchaseInfoProto_BillingInstruments> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseInfoProto_BillingInstruments::new)
    }
}

impl ::protobuf::Clear for PurchaseInfoProto_BillingInstruments {
    fn clear(&mut self) {
        self.defaultBillingInstrumentId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseInfoProto_BillingInstruments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseInfoProto_BillingInstruments {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseInfoProto_BillingInstruments_BillingInstrument {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub isInvalid: ::std::option::Option<bool>,
    pub instrumentType: ::std::option::Option<i32>,
    pub instrumentStatus: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseInfoProto_BillingInstruments_BillingInstrument {
    pub fn new() -> PurchaseInfoProto_BillingInstruments_BillingInstrument {
        ::std::default::Default::default()
    }

    // optional string id = 5;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string name = 6;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool isInvalid = 7;

    pub fn get_isInvalid(&self) -> bool {
        self.isInvalid.unwrap_or(false)
    }

    // optional int32 instrumentType = 11;

    pub fn get_instrumentType(&self) -> i32 {
        self.instrumentType.unwrap_or(0)
    }

    // optional int32 instrumentStatus = 14;

    pub fn get_instrumentStatus(&self) -> i32 {
        self.instrumentStatus.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseInfoProto_BillingInstruments_BillingInstrument {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isInvalid = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentType = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentStatus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.isInvalid {
            my_size += 2;
        }
        if let Some(v) = self.instrumentType {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.instrumentStatus {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.isInvalid {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.instrumentType {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.instrumentStatus {
            os.write_int32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseInfoProto_BillingInstruments_BillingInstrument {
        PurchaseInfoProto_BillingInstruments_BillingInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "id",
                |m: &PurchaseInfoProto_BillingInstruments_BillingInstrument| { &m.id },
                |m: &mut PurchaseInfoProto_BillingInstruments_BillingInstrument| { &mut m.id },
                PurchaseInfoProto_BillingInstruments_BillingInstrument::get_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "name",
                |m: &PurchaseInfoProto_BillingInstruments_BillingInstrument| { &m.name },
                |m: &mut PurchaseInfoProto_BillingInstruments_BillingInstrument| { &mut m.name },
                PurchaseInfoProto_BillingInstruments_BillingInstrument::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "isInvalid",
                |m: &PurchaseInfoProto_BillingInstruments_BillingInstrument| { &m.isInvalid },
                |m: &mut PurchaseInfoProto_BillingInstruments_BillingInstrument| { &mut m.isInvalid },
                PurchaseInfoProto_BillingInstruments_BillingInstrument::get_isInvalid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "instrumentType",
                |m: &PurchaseInfoProto_BillingInstruments_BillingInstrument| { &m.instrumentType },
                |m: &mut PurchaseInfoProto_BillingInstruments_BillingInstrument| { &mut m.instrumentType },
                PurchaseInfoProto_BillingInstruments_BillingInstrument::get_instrumentType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "instrumentStatus",
                |m: &PurchaseInfoProto_BillingInstruments_BillingInstrument| { &m.instrumentStatus },
                |m: &mut PurchaseInfoProto_BillingInstruments_BillingInstrument| { &mut m.instrumentStatus },
                PurchaseInfoProto_BillingInstruments_BillingInstrument::get_instrumentStatus,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseInfoProto_BillingInstruments_BillingInstrument>(
                "PurchaseInfoProto_BillingInstruments_BillingInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseInfoProto_BillingInstruments_BillingInstrument {
        static instance: ::protobuf::rt::Lazy<PurchaseInfoProto_BillingInstruments_BillingInstrument> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseInfoProto_BillingInstruments_BillingInstrument::new)
    }
}

impl ::protobuf::Clear for PurchaseInfoProto_BillingInstruments_BillingInstrument {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.isInvalid = ::std::option::Option::None;
        self.instrumentType = ::std::option::Option::None;
        self.instrumentStatus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseInfoProto_BillingInstruments_BillingInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseInfoProto_BillingInstruments_BillingInstrument {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseMetadataRequestProto {
    // message fields
    pub deprecatedRetrieveBillingCountries: ::std::option::Option<bool>,
    pub billingInstrumentType: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseMetadataRequestProto {
    pub fn new() -> PurchaseMetadataRequestProto {
        ::std::default::Default::default()
    }

    // optional bool deprecatedRetrieveBillingCountries = 1;

    pub fn get_deprecatedRetrieveBillingCountries(&self) -> bool {
        self.deprecatedRetrieveBillingCountries.unwrap_or(false)
    }

    // optional int32 billingInstrumentType = 2;

    pub fn get_billingInstrumentType(&self) -> i32 {
        self.billingInstrumentType.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseMetadataRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deprecatedRetrieveBillingCountries = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingInstrumentType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deprecatedRetrieveBillingCountries {
            my_size += 2;
        }
        if let Some(v) = self.billingInstrumentType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deprecatedRetrieveBillingCountries {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.billingInstrumentType {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseMetadataRequestProto {
        PurchaseMetadataRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "deprecatedRetrieveBillingCountries",
                |m: &PurchaseMetadataRequestProto| { &m.deprecatedRetrieveBillingCountries },
                |m: &mut PurchaseMetadataRequestProto| { &mut m.deprecatedRetrieveBillingCountries },
                PurchaseMetadataRequestProto::get_deprecatedRetrieveBillingCountries,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "billingInstrumentType",
                |m: &PurchaseMetadataRequestProto| { &m.billingInstrumentType },
                |m: &mut PurchaseMetadataRequestProto| { &mut m.billingInstrumentType },
                PurchaseMetadataRequestProto::get_billingInstrumentType,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseMetadataRequestProto>(
                "PurchaseMetadataRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseMetadataRequestProto {
        static instance: ::protobuf::rt::Lazy<PurchaseMetadataRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseMetadataRequestProto::new)
    }
}

impl ::protobuf::Clear for PurchaseMetadataRequestProto {
    fn clear(&mut self) {
        self.deprecatedRetrieveBillingCountries = ::std::option::Option::None;
        self.billingInstrumentType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseMetadataRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseMetadataRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseMetadataResponseProto {
    // message fields
    // countries: <group>
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseMetadataResponseProto {
    pub fn new() -> PurchaseMetadataResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PurchaseMetadataResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseMetadataResponseProto {
        PurchaseMetadataResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseMetadataResponseProto>(
                "PurchaseMetadataResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseMetadataResponseProto {
        static instance: ::protobuf::rt::Lazy<PurchaseMetadataResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseMetadataResponseProto::new)
    }
}

impl ::protobuf::Clear for PurchaseMetadataResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseMetadataResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseMetadataResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseMetadataResponseProto_Countries {
    // message fields
    // country: <group>
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseMetadataResponseProto_Countries {
    pub fn new() -> PurchaseMetadataResponseProto_Countries {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PurchaseMetadataResponseProto_Countries {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseMetadataResponseProto_Countries {
        PurchaseMetadataResponseProto_Countries::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseMetadataResponseProto_Countries>(
                "PurchaseMetadataResponseProto_Countries",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseMetadataResponseProto_Countries {
        static instance: ::protobuf::rt::Lazy<PurchaseMetadataResponseProto_Countries> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseMetadataResponseProto_Countries::new)
    }
}

impl ::protobuf::Clear for PurchaseMetadataResponseProto_Countries {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseMetadataResponseProto_Countries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseMetadataResponseProto_Countries {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseMetadataResponseProto_Countries_Country {
    // message fields
    pub countryCode: ::protobuf::SingularField<::std::string::String>,
    pub countryName: ::protobuf::SingularField<::std::string::String>,
    pub paypalCountryInfo: ::protobuf::SingularPtrField<PaypalCountryInfoProto>,
    pub allowsReducedBillingAddress: ::std::option::Option<bool>,
    // instrumentaddressspec: <group>
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseMetadataResponseProto_Countries_Country {
    pub fn new() -> PurchaseMetadataResponseProto_Countries_Country {
        ::std::default::Default::default()
    }

    // optional string countryCode = 3;

    pub fn get_countryCode(&self) -> &str {
        match self.countryCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string countryName = 4;

    pub fn get_countryName(&self) -> &str {
        match self.countryName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool allowsReducedBillingAddress = 6;

    pub fn get_allowsReducedBillingAddress(&self) -> bool {
        self.allowsReducedBillingAddress.unwrap_or(false)
    }
}

impl ::protobuf::Message for PurchaseMetadataResponseProto_Countries_Country {
    fn is_initialized(&self) -> bool {
        for v in &self.paypalCountryInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.countryCode)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.countryName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalCountryInfoProto, _>(wire_type, is, &mut self.paypalCountryInfo)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowsReducedBillingAddress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.countryCode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.countryName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.paypalCountryInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allowsReducedBillingAddress {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.countryCode.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.countryName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.paypalCountryInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.allowsReducedBillingAddress {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseMetadataResponseProto_Countries_Country {
        PurchaseMetadataResponseProto_Countries_Country::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "countryCode",
                |m: &PurchaseMetadataResponseProto_Countries_Country| { &m.countryCode },
                |m: &mut PurchaseMetadataResponseProto_Countries_Country| { &mut m.countryCode },
                PurchaseMetadataResponseProto_Countries_Country::get_countryCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "countryName",
                |m: &PurchaseMetadataResponseProto_Countries_Country| { &m.countryName },
                |m: &mut PurchaseMetadataResponseProto_Countries_Country| { &mut m.countryName },
                PurchaseMetadataResponseProto_Countries_Country::get_countryName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCountryInfoProto>, _>(
                "paypalCountryInfo",
                |m: &PurchaseMetadataResponseProto_Countries_Country| { &m.paypalCountryInfo },
                |m: &mut PurchaseMetadataResponseProto_Countries_Country| { &mut m.paypalCountryInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "allowsReducedBillingAddress",
                |m: &PurchaseMetadataResponseProto_Countries_Country| { &m.allowsReducedBillingAddress },
                |m: &mut PurchaseMetadataResponseProto_Countries_Country| { &mut m.allowsReducedBillingAddress },
                PurchaseMetadataResponseProto_Countries_Country::get_allowsReducedBillingAddress,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseMetadataResponseProto_Countries_Country>(
                "PurchaseMetadataResponseProto_Countries_Country",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseMetadataResponseProto_Countries_Country {
        static instance: ::protobuf::rt::Lazy<PurchaseMetadataResponseProto_Countries_Country> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseMetadataResponseProto_Countries_Country::new)
    }
}

impl ::protobuf::Clear for PurchaseMetadataResponseProto_Countries_Country {
    fn clear(&mut self) {
        self.countryCode.clear();
        self.countryName.clear();
        self.paypalCountryInfo.clear();
        self.allowsReducedBillingAddress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseMetadataResponseProto_Countries_Country {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseMetadataResponseProto_Countries_Country {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
    // message fields
    pub instrumentFamily: ::std::option::Option<i32>,
    pub billingAddressSpec: ::protobuf::SingularPtrField<BillingAddressSpec>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
    pub fn new() -> PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
        ::std::default::Default::default()
    }

    // optional int32 instrumentFamily = 8;

    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.billingAddressSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<BillingAddressSpec, _>(wire_type, is, &mut self.billingAddressSpec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.billingAddressSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentFamily {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.billingAddressSpec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
        PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "instrumentFamily",
                |m: &PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec| { &m.instrumentFamily },
                |m: &mut PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec| { &mut m.instrumentFamily },
                PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec::get_instrumentFamily,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingAddressSpec>, _>(
                "billingAddressSpec",
                |m: &PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec| { &m.billingAddressSpec },
                |m: &mut PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec| { &mut m.billingAddressSpec },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec>(
                "PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
        static instance: ::protobuf::rt::Lazy<PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec::new)
    }
}

impl ::protobuf::Clear for PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
    fn clear(&mut self) {
        self.instrumentFamily = ::std::option::Option::None;
        self.billingAddressSpec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseMetadataResponseProto_Countries_Country_InstrumentAddressSpec {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseOrderRequestProto {
    // message fields
    pub gaiaAuthToken: ::protobuf::SingularField<::std::string::String>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub transactionId: ::protobuf::SingularField<::std::string::String>,
    pub billingInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub tosAccepted: ::std::option::Option<bool>,
    pub carrierBillingCredentials: ::protobuf::SingularPtrField<CarrierBillingCredentialsProto>,
    pub existingOrderId: ::protobuf::SingularField<::std::string::String>,
    pub billingInstrumentType: ::std::option::Option<i32>,
    pub billingParametersId: ::protobuf::SingularField<::std::string::String>,
    pub paypalCredentials: ::protobuf::SingularPtrField<PaypalCredentialsProto>,
    pub riskHeaderInfo: ::protobuf::SingularPtrField<RiskHeaderInfoProto>,
    pub productType: ::std::option::Option<i32>,
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    pub developerPayload: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseOrderRequestProto {
    pub fn new() -> PurchaseOrderRequestProto {
        ::std::default::Default::default()
    }

    // optional string gaiaAuthToken = 1;

    pub fn get_gaiaAuthToken(&self) -> &str {
        match self.gaiaAuthToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string assetId = 2;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string transactionId = 3;

    pub fn get_transactionId(&self) -> &str {
        match self.transactionId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string billingInstrumentId = 4;

    pub fn get_billingInstrumentId(&self) -> &str {
        match self.billingInstrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool tosAccepted = 5;

    pub fn get_tosAccepted(&self) -> bool {
        self.tosAccepted.unwrap_or(false)
    }

    // optional string existingOrderId = 7;

    pub fn get_existingOrderId(&self) -> &str {
        match self.existingOrderId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 billingInstrumentType = 8;

    pub fn get_billingInstrumentType(&self) -> i32 {
        self.billingInstrumentType.unwrap_or(0)
    }

    // optional string billingParametersId = 9;

    pub fn get_billingParametersId(&self) -> &str {
        match self.billingParametersId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 productType = 12;

    pub fn get_productType(&self) -> i32 {
        self.productType.unwrap_or(0)
    }

    // optional string developerPayload = 14;

    pub fn get_developerPayload(&self) -> &str {
        match self.developerPayload.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseOrderRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierBillingCredentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCredentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.riskHeaderInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaAuthToken)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transactionId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingInstrumentId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosAccepted = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<CarrierBillingCredentialsProto, _>(wire_type, is, &mut self.carrierBillingCredentials)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.existingOrderId)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingInstrumentType = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingParametersId)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalCredentialsProto, _>(wire_type, is, &mut self.paypalCredentials)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<RiskHeaderInfoProto, _>(wire_type, is, &mut self.riskHeaderInfo)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.productType = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<SignatureHashProto, _>(wire_type, is, &mut self.signatureHash)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerPayload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gaiaAuthToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.transactionId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.billingInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tosAccepted {
            my_size += 2;
        }
        if let Some(v) = self.carrierBillingCredentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.existingOrderId.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.billingInstrumentType {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.billingParametersId.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.paypalCredentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.riskHeaderInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.productType {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.developerPayload.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gaiaAuthToken.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.transactionId.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.billingInstrumentId.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.tosAccepted {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.carrierBillingCredentials.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.existingOrderId.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.billingInstrumentType {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.billingParametersId.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.paypalCredentials.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.riskHeaderInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.productType {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.signatureHash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.developerPayload.as_ref() {
            os.write_string(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseOrderRequestProto {
        PurchaseOrderRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gaiaAuthToken",
                |m: &PurchaseOrderRequestProto| { &m.gaiaAuthToken },
                |m: &mut PurchaseOrderRequestProto| { &mut m.gaiaAuthToken },
                PurchaseOrderRequestProto::get_gaiaAuthToken,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &PurchaseOrderRequestProto| { &m.assetId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.assetId },
                PurchaseOrderRequestProto::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "transactionId",
                |m: &PurchaseOrderRequestProto| { &m.transactionId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.transactionId },
                PurchaseOrderRequestProto::get_transactionId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "billingInstrumentId",
                |m: &PurchaseOrderRequestProto| { &m.billingInstrumentId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.billingInstrumentId },
                PurchaseOrderRequestProto::get_billingInstrumentId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "tosAccepted",
                |m: &PurchaseOrderRequestProto| { &m.tosAccepted },
                |m: &mut PurchaseOrderRequestProto| { &mut m.tosAccepted },
                PurchaseOrderRequestProto::get_tosAccepted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingCredentialsProto>, _>(
                "carrierBillingCredentials",
                |m: &PurchaseOrderRequestProto| { &m.carrierBillingCredentials },
                |m: &mut PurchaseOrderRequestProto| { &mut m.carrierBillingCredentials },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "existingOrderId",
                |m: &PurchaseOrderRequestProto| { &m.existingOrderId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.existingOrderId },
                PurchaseOrderRequestProto::get_existingOrderId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "billingInstrumentType",
                |m: &PurchaseOrderRequestProto| { &m.billingInstrumentType },
                |m: &mut PurchaseOrderRequestProto| { &mut m.billingInstrumentType },
                PurchaseOrderRequestProto::get_billingInstrumentType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "billingParametersId",
                |m: &PurchaseOrderRequestProto| { &m.billingParametersId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.billingParametersId },
                PurchaseOrderRequestProto::get_billingParametersId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCredentialsProto>, _>(
                "paypalCredentials",
                |m: &PurchaseOrderRequestProto| { &m.paypalCredentials },
                |m: &mut PurchaseOrderRequestProto| { &mut m.paypalCredentials },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiskHeaderInfoProto>, _>(
                "riskHeaderInfo",
                |m: &PurchaseOrderRequestProto| { &m.riskHeaderInfo },
                |m: &mut PurchaseOrderRequestProto| { &mut m.riskHeaderInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "productType",
                |m: &PurchaseOrderRequestProto| { &m.productType },
                |m: &mut PurchaseOrderRequestProto| { &mut m.productType },
                PurchaseOrderRequestProto::get_productType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>, _>(
                "signatureHash",
                |m: &PurchaseOrderRequestProto| { &m.signatureHash },
                |m: &mut PurchaseOrderRequestProto| { &mut m.signatureHash },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "developerPayload",
                |m: &PurchaseOrderRequestProto| { &m.developerPayload },
                |m: &mut PurchaseOrderRequestProto| { &mut m.developerPayload },
                PurchaseOrderRequestProto::get_developerPayload,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseOrderRequestProto>(
                "PurchaseOrderRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseOrderRequestProto {
        static instance: ::protobuf::rt::Lazy<PurchaseOrderRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseOrderRequestProto::new)
    }
}

impl ::protobuf::Clear for PurchaseOrderRequestProto {
    fn clear(&mut self) {
        self.gaiaAuthToken.clear();
        self.assetId.clear();
        self.transactionId.clear();
        self.billingInstrumentId.clear();
        self.tosAccepted = ::std::option::Option::None;
        self.carrierBillingCredentials.clear();
        self.existingOrderId.clear();
        self.billingInstrumentType = ::std::option::Option::None;
        self.billingParametersId.clear();
        self.paypalCredentials.clear();
        self.riskHeaderInfo.clear();
        self.productType = ::std::option::Option::None;
        self.signatureHash.clear();
        self.developerPayload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseOrderRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseOrderRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseOrderResponseProto {
    // message fields
    pub deprecatedResultCode: ::std::option::Option<i32>,
    pub purchaseInfo: ::protobuf::SingularPtrField<PurchaseInfoProto>,
    pub asset: ::protobuf::SingularPtrField<ExternalAssetProto>,
    pub purchaseResult: ::protobuf::SingularPtrField<PurchaseResultProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseOrderResponseProto {
    pub fn new() -> PurchaseOrderResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 deprecatedResultCode = 1;

    pub fn get_deprecatedResultCode(&self) -> i32 {
        self.deprecatedResultCode.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseOrderResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deprecatedResultCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseInfoProto, _>(wire_type, is, &mut self.purchaseInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalAssetProto, _>(wire_type, is, &mut self.asset)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseResultProto, _>(wire_type, is, &mut self.purchaseResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deprecatedResultCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchaseInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.asset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deprecatedResultCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchaseInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.asset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.purchaseResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseOrderResponseProto {
        PurchaseOrderResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "deprecatedResultCode",
                |m: &PurchaseOrderResponseProto| { &m.deprecatedResultCode },
                |m: &mut PurchaseOrderResponseProto| { &mut m.deprecatedResultCode },
                PurchaseOrderResponseProto::get_deprecatedResultCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseInfoProto>, _>(
                "purchaseInfo",
                |m: &PurchaseOrderResponseProto| { &m.purchaseInfo },
                |m: &mut PurchaseOrderResponseProto| { &mut m.purchaseInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>, _>(
                "asset",
                |m: &PurchaseOrderResponseProto| { &m.asset },
                |m: &mut PurchaseOrderResponseProto| { &mut m.asset },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseResultProto>, _>(
                "purchaseResult",
                |m: &PurchaseOrderResponseProto| { &m.purchaseResult },
                |m: &mut PurchaseOrderResponseProto| { &mut m.purchaseResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseOrderResponseProto>(
                "PurchaseOrderResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseOrderResponseProto {
        static instance: ::protobuf::rt::Lazy<PurchaseOrderResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseOrderResponseProto::new)
    }
}

impl ::protobuf::Clear for PurchaseOrderResponseProto {
    fn clear(&mut self) {
        self.deprecatedResultCode = ::std::option::Option::None;
        self.purchaseInfo.clear();
        self.asset.clear();
        self.purchaseResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseOrderResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseOrderResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchasePostRequestProto {
    // message fields
    pub gaiaAuthToken: ::protobuf::SingularField<::std::string::String>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub transactionId: ::protobuf::SingularField<::std::string::String>,
    // billinginstrumentinfo: <group>
    pub tosAccepted: ::std::option::Option<bool>,
    pub cbInstrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub paypalAuthConfirmed: ::std::option::Option<bool>,
    pub productType: ::std::option::Option<i32>,
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchasePostRequestProto {
    pub fn new() -> PurchasePostRequestProto {
        ::std::default::Default::default()
    }

    // optional string gaiaAuthToken = 1;

    pub fn get_gaiaAuthToken(&self) -> &str {
        match self.gaiaAuthToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string assetId = 2;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string transactionId = 3;

    pub fn get_transactionId(&self) -> &str {
        match self.transactionId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool tosAccepted = 7;

    pub fn get_tosAccepted(&self) -> bool {
        self.tosAccepted.unwrap_or(false)
    }

    // optional string cbInstrumentKey = 8;

    pub fn get_cbInstrumentKey(&self) -> &str {
        match self.cbInstrumentKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool paypalAuthConfirmed = 11;

    pub fn get_paypalAuthConfirmed(&self) -> bool {
        self.paypalAuthConfirmed.unwrap_or(false)
    }

    // optional int32 productType = 12;

    pub fn get_productType(&self) -> i32 {
        self.productType.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchasePostRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaAuthToken)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transactionId)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosAccepted = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cbInstrumentKey)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.paypalAuthConfirmed = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.productType = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<SignatureHashProto, _>(wire_type, is, &mut self.signatureHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gaiaAuthToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.transactionId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.tosAccepted {
            my_size += 2;
        }
        if let Some(v) = self.cbInstrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.paypalAuthConfirmed {
            my_size += 2;
        }
        if let Some(v) = self.productType {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gaiaAuthToken.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.transactionId.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.tosAccepted {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.cbInstrumentKey.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.paypalAuthConfirmed {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.productType {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.signatureHash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchasePostRequestProto {
        PurchasePostRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "gaiaAuthToken",
                |m: &PurchasePostRequestProto| { &m.gaiaAuthToken },
                |m: &mut PurchasePostRequestProto| { &mut m.gaiaAuthToken },
                PurchasePostRequestProto::get_gaiaAuthToken,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &PurchasePostRequestProto| { &m.assetId },
                |m: &mut PurchasePostRequestProto| { &mut m.assetId },
                PurchasePostRequestProto::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "transactionId",
                |m: &PurchasePostRequestProto| { &m.transactionId },
                |m: &mut PurchasePostRequestProto| { &mut m.transactionId },
                PurchasePostRequestProto::get_transactionId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "tosAccepted",
                |m: &PurchasePostRequestProto| { &m.tosAccepted },
                |m: &mut PurchasePostRequestProto| { &mut m.tosAccepted },
                PurchasePostRequestProto::get_tosAccepted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "cbInstrumentKey",
                |m: &PurchasePostRequestProto| { &m.cbInstrumentKey },
                |m: &mut PurchasePostRequestProto| { &mut m.cbInstrumentKey },
                PurchasePostRequestProto::get_cbInstrumentKey,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "paypalAuthConfirmed",
                |m: &PurchasePostRequestProto| { &m.paypalAuthConfirmed },
                |m: &mut PurchasePostRequestProto| { &mut m.paypalAuthConfirmed },
                PurchasePostRequestProto::get_paypalAuthConfirmed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "productType",
                |m: &PurchasePostRequestProto| { &m.productType },
                |m: &mut PurchasePostRequestProto| { &mut m.productType },
                PurchasePostRequestProto::get_productType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>, _>(
                "signatureHash",
                |m: &PurchasePostRequestProto| { &m.signatureHash },
                |m: &mut PurchasePostRequestProto| { &mut m.signatureHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchasePostRequestProto>(
                "PurchasePostRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchasePostRequestProto {
        static instance: ::protobuf::rt::Lazy<PurchasePostRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchasePostRequestProto::new)
    }
}

impl ::protobuf::Clear for PurchasePostRequestProto {
    fn clear(&mut self) {
        self.gaiaAuthToken.clear();
        self.assetId.clear();
        self.transactionId.clear();
        self.tosAccepted = ::std::option::Option::None;
        self.cbInstrumentKey.clear();
        self.paypalAuthConfirmed = ::std::option::Option::None;
        self.productType = ::std::option::Option::None;
        self.signatureHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchasePostRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchasePostRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchasePostRequestProto_BillingInstrumentInfo {
    // message fields
    pub billingInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub creditCard: ::protobuf::SingularPtrField<ExternalCreditCard>,
    pub carrierInstrument: ::protobuf::SingularPtrField<ExternalCarrierBillingInstrumentProto>,
    pub paypalInstrument: ::protobuf::SingularPtrField<ExternalPaypalInstrumentProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchasePostRequestProto_BillingInstrumentInfo {
    pub fn new() -> PurchasePostRequestProto_BillingInstrumentInfo {
        ::std::default::Default::default()
    }

    // optional string billingInstrumentId = 5;

    pub fn get_billingInstrumentId(&self) -> &str {
        match self.billingInstrumentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchasePostRequestProto_BillingInstrumentInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.creditCard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingInstrumentId)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalCreditCard, _>(wire_type, is, &mut self.creditCard)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalCarrierBillingInstrumentProto, _>(wire_type, is, &mut self.carrierInstrument)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalPaypalInstrumentProto, _>(wire_type, is, &mut self.paypalInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.billingInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.creditCard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.carrierInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.billingInstrumentId.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.creditCard.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.carrierInstrument.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.paypalInstrument.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchasePostRequestProto_BillingInstrumentInfo {
        PurchasePostRequestProto_BillingInstrumentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "billingInstrumentId",
                |m: &PurchasePostRequestProto_BillingInstrumentInfo| { &m.billingInstrumentId },
                |m: &mut PurchasePostRequestProto_BillingInstrumentInfo| { &mut m.billingInstrumentId },
                PurchasePostRequestProto_BillingInstrumentInfo::get_billingInstrumentId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCreditCard>, _>(
                "creditCard",
                |m: &PurchasePostRequestProto_BillingInstrumentInfo| { &m.creditCard },
                |m: &mut PurchasePostRequestProto_BillingInstrumentInfo| { &mut m.creditCard },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCarrierBillingInstrumentProto>, _>(
                "carrierInstrument",
                |m: &PurchasePostRequestProto_BillingInstrumentInfo| { &m.carrierInstrument },
                |m: &mut PurchasePostRequestProto_BillingInstrumentInfo| { &mut m.carrierInstrument },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalPaypalInstrumentProto>, _>(
                "paypalInstrument",
                |m: &PurchasePostRequestProto_BillingInstrumentInfo| { &m.paypalInstrument },
                |m: &mut PurchasePostRequestProto_BillingInstrumentInfo| { &mut m.paypalInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchasePostRequestProto_BillingInstrumentInfo>(
                "PurchasePostRequestProto_BillingInstrumentInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchasePostRequestProto_BillingInstrumentInfo {
        static instance: ::protobuf::rt::Lazy<PurchasePostRequestProto_BillingInstrumentInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchasePostRequestProto_BillingInstrumentInfo::new)
    }
}

impl ::protobuf::Clear for PurchasePostRequestProto_BillingInstrumentInfo {
    fn clear(&mut self) {
        self.billingInstrumentId.clear();
        self.creditCard.clear();
        self.carrierInstrument.clear();
        self.paypalInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchasePostRequestProto_BillingInstrumentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchasePostRequestProto_BillingInstrumentInfo {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchasePostResponseProto {
    // message fields
    pub deprecatedResultCode: ::std::option::Option<i32>,
    pub purchaseInfo: ::protobuf::SingularPtrField<PurchaseInfoProto>,
    pub termsOfServiceUrl: ::protobuf::SingularField<::std::string::String>,
    pub termsOfServiceText: ::protobuf::SingularField<::std::string::String>,
    pub termsOfServiceName: ::protobuf::SingularField<::std::string::String>,
    pub termsOfServiceCheckboxText: ::protobuf::SingularField<::std::string::String>,
    pub termsOfServiceHeaderText: ::protobuf::SingularField<::std::string::String>,
    pub purchaseResult: ::protobuf::SingularPtrField<PurchaseResultProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchasePostResponseProto {
    pub fn new() -> PurchasePostResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 deprecatedResultCode = 1;

    pub fn get_deprecatedResultCode(&self) -> i32 {
        self.deprecatedResultCode.unwrap_or(0)
    }

    // optional string termsOfServiceUrl = 3;

    pub fn get_termsOfServiceUrl(&self) -> &str {
        match self.termsOfServiceUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string termsOfServiceText = 4;

    pub fn get_termsOfServiceText(&self) -> &str {
        match self.termsOfServiceText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string termsOfServiceName = 5;

    pub fn get_termsOfServiceName(&self) -> &str {
        match self.termsOfServiceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string termsOfServiceCheckboxText = 6;

    pub fn get_termsOfServiceCheckboxText(&self) -> &str {
        match self.termsOfServiceCheckboxText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string termsOfServiceHeaderText = 7;

    pub fn get_termsOfServiceHeaderText(&self) -> &str {
        match self.termsOfServiceHeaderText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchasePostResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deprecatedResultCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseInfoProto, _>(wire_type, is, &mut self.purchaseInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceText)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceCheckboxText)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceHeaderText)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseResultProto, _>(wire_type, is, &mut self.purchaseResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deprecatedResultCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchaseInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.termsOfServiceUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.termsOfServiceText.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.termsOfServiceName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.termsOfServiceCheckboxText.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.termsOfServiceHeaderText.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.purchaseResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deprecatedResultCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchaseInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.termsOfServiceUrl.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.termsOfServiceText.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.termsOfServiceName.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.termsOfServiceCheckboxText.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.termsOfServiceHeaderText.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.purchaseResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchasePostResponseProto {
        PurchasePostResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "deprecatedResultCode",
                |m: &PurchasePostResponseProto| { &m.deprecatedResultCode },
                |m: &mut PurchasePostResponseProto| { &mut m.deprecatedResultCode },
                PurchasePostResponseProto::get_deprecatedResultCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseInfoProto>, _>(
                "purchaseInfo",
                |m: &PurchasePostResponseProto| { &m.purchaseInfo },
                |m: &mut PurchasePostResponseProto| { &mut m.purchaseInfo },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "termsOfServiceUrl",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceUrl },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceUrl },
                PurchasePostResponseProto::get_termsOfServiceUrl,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "termsOfServiceText",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceText },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceText },
                PurchasePostResponseProto::get_termsOfServiceText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "termsOfServiceName",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceName },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceName },
                PurchasePostResponseProto::get_termsOfServiceName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "termsOfServiceCheckboxText",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceCheckboxText },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceCheckboxText },
                PurchasePostResponseProto::get_termsOfServiceCheckboxText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "termsOfServiceHeaderText",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceHeaderText },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceHeaderText },
                PurchasePostResponseProto::get_termsOfServiceHeaderText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseResultProto>, _>(
                "purchaseResult",
                |m: &PurchasePostResponseProto| { &m.purchaseResult },
                |m: &mut PurchasePostResponseProto| { &mut m.purchaseResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchasePostResponseProto>(
                "PurchasePostResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchasePostResponseProto {
        static instance: ::protobuf::rt::Lazy<PurchasePostResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchasePostResponseProto::new)
    }
}

impl ::protobuf::Clear for PurchasePostResponseProto {
    fn clear(&mut self) {
        self.deprecatedResultCode = ::std::option::Option::None;
        self.purchaseInfo.clear();
        self.termsOfServiceUrl.clear();
        self.termsOfServiceText.clear();
        self.termsOfServiceName.clear();
        self.termsOfServiceCheckboxText.clear();
        self.termsOfServiceHeaderText.clear();
        self.purchaseResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchasePostResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchasePostResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseProductRequestProto {
    // message fields
    pub productType: ::std::option::Option<i32>,
    pub productId: ::protobuf::SingularField<::std::string::String>,
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseProductRequestProto {
    pub fn new() -> PurchaseProductRequestProto {
        ::std::default::Default::default()
    }

    // optional int32 productType = 1;

    pub fn get_productType(&self) -> i32 {
        self.productType.unwrap_or(0)
    }

    // optional string productId = 2;

    pub fn get_productId(&self) -> &str {
        match self.productId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseProductRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.productType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.productId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<SignatureHashProto, _>(wire_type, is, &mut self.signatureHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.productType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.productId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.productType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.productId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.signatureHash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseProductRequestProto {
        PurchaseProductRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "productType",
                |m: &PurchaseProductRequestProto| { &m.productType },
                |m: &mut PurchaseProductRequestProto| { &mut m.productType },
                PurchaseProductRequestProto::get_productType,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "productId",
                |m: &PurchaseProductRequestProto| { &m.productId },
                |m: &mut PurchaseProductRequestProto| { &mut m.productId },
                PurchaseProductRequestProto::get_productId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>, _>(
                "signatureHash",
                |m: &PurchaseProductRequestProto| { &m.signatureHash },
                |m: &mut PurchaseProductRequestProto| { &mut m.signatureHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseProductRequestProto>(
                "PurchaseProductRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseProductRequestProto {
        static instance: ::protobuf::rt::Lazy<PurchaseProductRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseProductRequestProto::new)
    }
}

impl ::protobuf::Clear for PurchaseProductRequestProto {
    fn clear(&mut self) {
        self.productType = ::std::option::Option::None;
        self.productId.clear();
        self.signatureHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseProductRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseProductRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseProductResponseProto {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub itemTitle: ::protobuf::SingularField<::std::string::String>,
    pub itemDescription: ::protobuf::SingularField<::std::string::String>,
    pub merchantField: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseProductResponseProto {
    pub fn new() -> PurchaseProductResponseProto {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string itemTitle = 2;

    pub fn get_itemTitle(&self) -> &str {
        match self.itemTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string itemDescription = 3;

    pub fn get_itemDescription(&self) -> &str {
        match self.itemDescription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string merchantField = 4;

    pub fn get_merchantField(&self) -> &str {
        match self.merchantField.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseProductResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.itemTitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.itemDescription)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.merchantField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.itemTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.itemDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.merchantField.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.itemTitle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.itemDescription.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.merchantField.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseProductResponseProto {
        PurchaseProductResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &PurchaseProductResponseProto| { &m.title },
                |m: &mut PurchaseProductResponseProto| { &mut m.title },
                PurchaseProductResponseProto::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "itemTitle",
                |m: &PurchaseProductResponseProto| { &m.itemTitle },
                |m: &mut PurchaseProductResponseProto| { &mut m.itemTitle },
                PurchaseProductResponseProto::get_itemTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "itemDescription",
                |m: &PurchaseProductResponseProto| { &m.itemDescription },
                |m: &mut PurchaseProductResponseProto| { &mut m.itemDescription },
                PurchaseProductResponseProto::get_itemDescription,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "merchantField",
                |m: &PurchaseProductResponseProto| { &m.merchantField },
                |m: &mut PurchaseProductResponseProto| { &mut m.merchantField },
                PurchaseProductResponseProto::get_merchantField,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseProductResponseProto>(
                "PurchaseProductResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseProductResponseProto {
        static instance: ::protobuf::rt::Lazy<PurchaseProductResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseProductResponseProto::new)
    }
}

impl ::protobuf::Clear for PurchaseProductResponseProto {
    fn clear(&mut self) {
        self.title.clear();
        self.itemTitle.clear();
        self.itemDescription.clear();
        self.merchantField.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseProductResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseProductResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct PurchaseResultProto {
    // message fields
    pub resultCode: ::std::option::Option<i32>,
    pub resultCodeMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl PurchaseResultProto {
    pub fn new() -> PurchaseResultProto {
        ::std::default::Default::default()
    }

    // optional int32 resultCode = 1;

    pub fn get_resultCode(&self) -> i32 {
        self.resultCode.unwrap_or(0)
    }

    // optional string resultCodeMessage = 2;

    pub fn get_resultCodeMessage(&self) -> &str {
        match self.resultCodeMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseResultProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.resultCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resultCodeMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.resultCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resultCodeMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.resultCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.resultCodeMessage.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseResultProto {
        PurchaseResultProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "resultCode",
                |m: &PurchaseResultProto| { &m.resultCode },
                |m: &mut PurchaseResultProto| { &mut m.resultCode },
                PurchaseResultProto::get_resultCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "resultCodeMessage",
                |m: &PurchaseResultProto| { &m.resultCodeMessage },
                |m: &mut PurchaseResultProto| { &mut m.resultCodeMessage },
                PurchaseResultProto::get_resultCodeMessage,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PurchaseResultProto>(
                "PurchaseResultProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseResultProto {
        static instance: ::protobuf::rt::Lazy<PurchaseResultProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(PurchaseResultProto::new)
    }
}

impl ::protobuf::Clear for PurchaseResultProto {
    fn clear(&mut self) {
        self.resultCode = ::std::option::Option::None;
        self.resultCodeMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseResultProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseResultProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct QuerySuggestionProto {
    // message fields
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub estimatedNumResults: ::std::option::Option<i32>,
    pub queryWeight: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl QuerySuggestionProto {
    pub fn new() -> QuerySuggestionProto {
        ::std::default::Default::default()
    }

    // optional string query = 1;

    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 estimatedNumResults = 2;

    pub fn get_estimatedNumResults(&self) -> i32 {
        self.estimatedNumResults.unwrap_or(0)
    }

    // optional int32 queryWeight = 3;

    pub fn get_queryWeight(&self) -> i32 {
        self.queryWeight.unwrap_or(0)
    }
}

impl ::protobuf::Message for QuerySuggestionProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimatedNumResults = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.queryWeight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.estimatedNumResults {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.queryWeight {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.query.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.estimatedNumResults {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.queryWeight {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySuggestionProto {
        QuerySuggestionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "query",
                |m: &QuerySuggestionProto| { &m.query },
                |m: &mut QuerySuggestionProto| { &mut m.query },
                QuerySuggestionProto::get_query,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "estimatedNumResults",
                |m: &QuerySuggestionProto| { &m.estimatedNumResults },
                |m: &mut QuerySuggestionProto| { &mut m.estimatedNumResults },
                QuerySuggestionProto::get_estimatedNumResults,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "queryWeight",
                |m: &QuerySuggestionProto| { &m.queryWeight },
                |m: &mut QuerySuggestionProto| { &mut m.queryWeight },
                QuerySuggestionProto::get_queryWeight,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<QuerySuggestionProto>(
                "QuerySuggestionProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySuggestionProto {
        static instance: ::protobuf::rt::Lazy<QuerySuggestionProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(QuerySuggestionProto::new)
    }
}

impl ::protobuf::Clear for QuerySuggestionProto {
    fn clear(&mut self) {
        self.query.clear();
        self.estimatedNumResults = ::std::option::Option::None;
        self.queryWeight = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySuggestionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySuggestionProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct QuerySuggestionRequestProto {
    // message fields
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub requestType: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl QuerySuggestionRequestProto {
    pub fn new() -> QuerySuggestionRequestProto {
        ::std::default::Default::default()
    }

    // optional string query = 1;

    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 requestType = 2;

    pub fn get_requestType(&self) -> i32 {
        self.requestType.unwrap_or(0)
    }
}

impl ::protobuf::Message for QuerySuggestionRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.requestType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.requestType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.query.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.requestType {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySuggestionRequestProto {
        QuerySuggestionRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "query",
                |m: &QuerySuggestionRequestProto| { &m.query },
                |m: &mut QuerySuggestionRequestProto| { &mut m.query },
                QuerySuggestionRequestProto::get_query,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "requestType",
                |m: &QuerySuggestionRequestProto| { &m.requestType },
                |m: &mut QuerySuggestionRequestProto| { &mut m.requestType },
                QuerySuggestionRequestProto::get_requestType,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<QuerySuggestionRequestProto>(
                "QuerySuggestionRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySuggestionRequestProto {
        static instance: ::protobuf::rt::Lazy<QuerySuggestionRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(QuerySuggestionRequestProto::new)
    }
}

impl ::protobuf::Clear for QuerySuggestionRequestProto {
    fn clear(&mut self) {
        self.query.clear();
        self.requestType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySuggestionRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySuggestionRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct QuerySuggestionResponseProto {
    // message fields
    // suggestion: <group>
    pub estimatedNumAppSuggestions: ::std::option::Option<i32>,
    pub estimatedNumQuerySuggestions: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl QuerySuggestionResponseProto {
    pub fn new() -> QuerySuggestionResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 estimatedNumAppSuggestions = 4;

    pub fn get_estimatedNumAppSuggestions(&self) -> i32 {
        self.estimatedNumAppSuggestions.unwrap_or(0)
    }

    // optional int32 estimatedNumQuerySuggestions = 5;

    pub fn get_estimatedNumQuerySuggestions(&self) -> i32 {
        self.estimatedNumQuerySuggestions.unwrap_or(0)
    }
}

impl ::protobuf::Message for QuerySuggestionResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimatedNumAppSuggestions = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimatedNumQuerySuggestions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.estimatedNumAppSuggestions {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.estimatedNumQuerySuggestions {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.estimatedNumAppSuggestions {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.estimatedNumQuerySuggestions {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySuggestionResponseProto {
        QuerySuggestionResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "estimatedNumAppSuggestions",
                |m: &QuerySuggestionResponseProto| { &m.estimatedNumAppSuggestions },
                |m: &mut QuerySuggestionResponseProto| { &mut m.estimatedNumAppSuggestions },
                QuerySuggestionResponseProto::get_estimatedNumAppSuggestions,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "estimatedNumQuerySuggestions",
                |m: &QuerySuggestionResponseProto| { &m.estimatedNumQuerySuggestions },
                |m: &mut QuerySuggestionResponseProto| { &mut m.estimatedNumQuerySuggestions },
                QuerySuggestionResponseProto::get_estimatedNumQuerySuggestions,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<QuerySuggestionResponseProto>(
                "QuerySuggestionResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySuggestionResponseProto {
        static instance: ::protobuf::rt::Lazy<QuerySuggestionResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(QuerySuggestionResponseProto::new)
    }
}

impl ::protobuf::Clear for QuerySuggestionResponseProto {
    fn clear(&mut self) {
        self.estimatedNumAppSuggestions = ::std::option::Option::None;
        self.estimatedNumQuerySuggestions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySuggestionResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySuggestionResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct QuerySuggestionResponseProto_Suggestion {
    // message fields
    pub appSuggestion: ::protobuf::SingularPtrField<AppSuggestionProto>,
    pub querySuggestion: ::protobuf::SingularPtrField<QuerySuggestionProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl QuerySuggestionResponseProto_Suggestion {
    pub fn new() -> QuerySuggestionResponseProto_Suggestion {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QuerySuggestionResponseProto_Suggestion {
    fn is_initialized(&self) -> bool {
        for v in &self.appSuggestion {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestion {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into::<AppSuggestionProto, _>(wire_type, is, &mut self.appSuggestion)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<QuerySuggestionProto, _>(wire_type, is, &mut self.querySuggestion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appSuggestion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.querySuggestion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appSuggestion.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.querySuggestion.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySuggestionResponseProto_Suggestion {
        QuerySuggestionResponseProto_Suggestion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppSuggestionProto>, _>(
                "appSuggestion",
                |m: &QuerySuggestionResponseProto_Suggestion| { &m.appSuggestion },
                |m: &mut QuerySuggestionResponseProto_Suggestion| { &mut m.appSuggestion },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionProto>, _>(
                "querySuggestion",
                |m: &QuerySuggestionResponseProto_Suggestion| { &m.querySuggestion },
                |m: &mut QuerySuggestionResponseProto_Suggestion| { &mut m.querySuggestion },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<QuerySuggestionResponseProto_Suggestion>(
                "QuerySuggestionResponseProto_Suggestion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySuggestionResponseProto_Suggestion {
        static instance: ::protobuf::rt::Lazy<QuerySuggestionResponseProto_Suggestion> = ::protobuf::rt::Lazy::INIT;
        instance.get(QuerySuggestionResponseProto_Suggestion::new)
    }
}

impl ::protobuf::Clear for QuerySuggestionResponseProto_Suggestion {
    fn clear(&mut self) {
        self.appSuggestion.clear();
        self.querySuggestion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySuggestionResponseProto_Suggestion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySuggestionResponseProto_Suggestion {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RateCommentRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub creatorId: ::protobuf::SingularField<::std::string::String>,
    pub commentRating: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RateCommentRequestProto {
    pub fn new() -> RateCommentRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string creatorId = 2;

    pub fn get_creatorId(&self) -> &str {
        match self.creatorId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 commentRating = 3;

    pub fn get_commentRating(&self) -> i32 {
        self.commentRating.unwrap_or(0)
    }
}

impl ::protobuf::Message for RateCommentRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creatorId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.commentRating = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.creatorId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.commentRating {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.creatorId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.commentRating {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateCommentRequestProto {
        RateCommentRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &RateCommentRequestProto| { &m.assetId },
                |m: &mut RateCommentRequestProto| { &mut m.assetId },
                RateCommentRequestProto::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "creatorId",
                |m: &RateCommentRequestProto| { &m.creatorId },
                |m: &mut RateCommentRequestProto| { &mut m.creatorId },
                RateCommentRequestProto::get_creatorId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "commentRating",
                |m: &RateCommentRequestProto| { &m.commentRating },
                |m: &mut RateCommentRequestProto| { &mut m.commentRating },
                RateCommentRequestProto::get_commentRating,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RateCommentRequestProto>(
                "RateCommentRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateCommentRequestProto {
        static instance: ::protobuf::rt::Lazy<RateCommentRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RateCommentRequestProto::new)
    }
}

impl ::protobuf::Clear for RateCommentRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.creatorId.clear();
        self.commentRating = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateCommentRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateCommentRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RateCommentResponseProto {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RateCommentResponseProto {
    pub fn new() -> RateCommentResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateCommentResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateCommentResponseProto {
        RateCommentResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<RateCommentResponseProto>(
                "RateCommentResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateCommentResponseProto {
        static instance: ::protobuf::rt::Lazy<RateCommentResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RateCommentResponseProto::new)
    }
}

impl ::protobuf::Clear for RateCommentResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateCommentResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateCommentResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ReconstructDatabaseRequestProto {
    // message fields
    pub retrieveFullHistory: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ReconstructDatabaseRequestProto {
    pub fn new() -> ReconstructDatabaseRequestProto {
        ::std::default::Default::default()
    }

    // optional bool retrieveFullHistory = 1;

    pub fn get_retrieveFullHistory(&self) -> bool {
        self.retrieveFullHistory.unwrap_or(false)
    }
}

impl ::protobuf::Message for ReconstructDatabaseRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retrieveFullHistory = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.retrieveFullHistory {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.retrieveFullHistory {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReconstructDatabaseRequestProto {
        ReconstructDatabaseRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "retrieveFullHistory",
                |m: &ReconstructDatabaseRequestProto| { &m.retrieveFullHistory },
                |m: &mut ReconstructDatabaseRequestProto| { &mut m.retrieveFullHistory },
                ReconstructDatabaseRequestProto::get_retrieveFullHistory,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ReconstructDatabaseRequestProto>(
                "ReconstructDatabaseRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReconstructDatabaseRequestProto {
        static instance: ::protobuf::rt::Lazy<ReconstructDatabaseRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ReconstructDatabaseRequestProto::new)
    }
}

impl ::protobuf::Clear for ReconstructDatabaseRequestProto {
    fn clear(&mut self) {
        self.retrieveFullHistory = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReconstructDatabaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReconstructDatabaseRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ReconstructDatabaseResponseProto {
    // message fields
    pub asset: ::protobuf::RepeatedField<AssetIdentifierProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ReconstructDatabaseResponseProto {
    pub fn new() -> ReconstructDatabaseResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReconstructDatabaseResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.asset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.asset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.asset {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReconstructDatabaseResponseProto {
        ReconstructDatabaseResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetIdentifierProto>>(
                "asset",
                |m: &ReconstructDatabaseResponseProto| { &m.asset },
                |m: &mut ReconstructDatabaseResponseProto| { &mut m.asset },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ReconstructDatabaseResponseProto>(
                "ReconstructDatabaseResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReconstructDatabaseResponseProto {
        static instance: ::protobuf::rt::Lazy<ReconstructDatabaseResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ReconstructDatabaseResponseProto::new)
    }
}

impl ::protobuf::Clear for ReconstructDatabaseResponseProto {
    fn clear(&mut self) {
        self.asset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReconstructDatabaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReconstructDatabaseResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RefundRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RefundRequestProto {
    pub fn new() -> RefundRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RefundRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefundRequestProto {
        RefundRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &RefundRequestProto| { &m.assetId },
                |m: &mut RefundRequestProto| { &mut m.assetId },
                RefundRequestProto::get_assetId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RefundRequestProto>(
                "RefundRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RefundRequestProto {
        static instance: ::protobuf::rt::Lazy<RefundRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RefundRequestProto::new)
    }
}

impl ::protobuf::Clear for RefundRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefundRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefundRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RefundResponseProto {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub asset: ::protobuf::SingularPtrField<ExternalAssetProto>,
    pub resultDetail: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RefundResponseProto {
    pub fn new() -> RefundResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional string resultDetail = 3;

    pub fn get_resultDetail(&self) -> &str {
        match self.resultDetail.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RefundResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ExternalAssetProto, _>(wire_type, is, &mut self.asset)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resultDetail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.asset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.resultDetail.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.asset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.resultDetail.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefundResponseProto {
        RefundResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "result",
                |m: &RefundResponseProto| { &m.result },
                |m: &mut RefundResponseProto| { &mut m.result },
                RefundResponseProto::get_result,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>, _>(
                "asset",
                |m: &RefundResponseProto| { &m.asset },
                |m: &mut RefundResponseProto| { &mut m.asset },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "resultDetail",
                |m: &RefundResponseProto| { &m.resultDetail },
                |m: &mut RefundResponseProto| { &mut m.resultDetail },
                RefundResponseProto::get_resultDetail,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RefundResponseProto>(
                "RefundResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RefundResponseProto {
        static instance: ::protobuf::rt::Lazy<RefundResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RefundResponseProto::new)
    }
}

impl ::protobuf::Clear for RefundResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.asset.clear();
        self.resultDetail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefundResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefundResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RemoveAssetRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RemoveAssetRequestProto {
    pub fn new() -> RemoveAssetRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RemoveAssetRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveAssetRequestProto {
        RemoveAssetRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &RemoveAssetRequestProto| { &m.assetId },
                |m: &mut RemoveAssetRequestProto| { &mut m.assetId },
                RemoveAssetRequestProto::get_assetId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RemoveAssetRequestProto>(
                "RemoveAssetRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveAssetRequestProto {
        static instance: ::protobuf::rt::Lazy<RemoveAssetRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RemoveAssetRequestProto::new)
    }
}

impl ::protobuf::Clear for RemoveAssetRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveAssetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveAssetRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RequestPropertiesProto {
    // message fields
    pub userAuthToken: ::protobuf::SingularField<::std::string::String>,
    pub userAuthTokenSecure: ::std::option::Option<bool>,
    pub softwareVersion: ::std::option::Option<i32>,
    pub aid: ::protobuf::SingularField<::std::string::String>,
    pub productNameAndVersion: ::protobuf::SingularField<::std::string::String>,
    pub userLanguage: ::protobuf::SingularField<::std::string::String>,
    pub userCountry: ::protobuf::SingularField<::std::string::String>,
    pub operatorName: ::protobuf::SingularField<::std::string::String>,
    pub simOperatorName: ::protobuf::SingularField<::std::string::String>,
    pub operatorNumericName: ::protobuf::SingularField<::std::string::String>,
    pub simOperatorNumericName: ::protobuf::SingularField<::std::string::String>,
    pub clientId: ::protobuf::SingularField<::std::string::String>,
    pub loggingId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RequestPropertiesProto {
    pub fn new() -> RequestPropertiesProto {
        ::std::default::Default::default()
    }

    // optional string userAuthToken = 1;

    pub fn get_userAuthToken(&self) -> &str {
        match self.userAuthToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional bool userAuthTokenSecure = 2;

    pub fn get_userAuthTokenSecure(&self) -> bool {
        self.userAuthTokenSecure.unwrap_or(false)
    }

    // optional int32 softwareVersion = 3;

    pub fn get_softwareVersion(&self) -> i32 {
        self.softwareVersion.unwrap_or(0)
    }

    // optional string aid = 4;

    pub fn get_aid(&self) -> &str {
        match self.aid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string productNameAndVersion = 5;

    pub fn get_productNameAndVersion(&self) -> &str {
        match self.productNameAndVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string userLanguage = 6;

    pub fn get_userLanguage(&self) -> &str {
        match self.userLanguage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string userCountry = 7;

    pub fn get_userCountry(&self) -> &str {
        match self.userCountry.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string operatorName = 8;

    pub fn get_operatorName(&self) -> &str {
        match self.operatorName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string simOperatorName = 9;

    pub fn get_simOperatorName(&self) -> &str {
        match self.simOperatorName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string operatorNumericName = 10;

    pub fn get_operatorNumericName(&self) -> &str {
        match self.operatorNumericName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string simOperatorNumericName = 11;

    pub fn get_simOperatorNumericName(&self) -> &str {
        match self.simOperatorNumericName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string clientId = 12;

    pub fn get_clientId(&self) -> &str {
        match self.clientId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string loggingId = 13;

    pub fn get_loggingId(&self) -> &str {
        match self.loggingId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RequestPropertiesProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userAuthToken)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.userAuthTokenSecure = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.softwareVersion = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.aid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.productNameAndVersion)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userLanguage)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userCountry)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operatorName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.simOperatorName)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operatorNumericName)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.simOperatorNumericName)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientId)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loggingId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.userAuthToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.userAuthTokenSecure {
            my_size += 2;
        }
        if let Some(v) = self.softwareVersion {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.aid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.productNameAndVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.userLanguage.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.userCountry.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.operatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.simOperatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.operatorNumericName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.simOperatorNumericName.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.clientId.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.loggingId.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.userAuthToken.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.userAuthTokenSecure {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.softwareVersion {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.aid.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.productNameAndVersion.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.userLanguage.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.userCountry.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.operatorName.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.simOperatorName.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.operatorNumericName.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.simOperatorNumericName.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.clientId.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.loggingId.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestPropertiesProto {
        RequestPropertiesProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userAuthToken",
                |m: &RequestPropertiesProto| { &m.userAuthToken },
                |m: &mut RequestPropertiesProto| { &mut m.userAuthToken },
                RequestPropertiesProto::get_userAuthToken,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeBool, _>(
                "userAuthTokenSecure",
                |m: &RequestPropertiesProto| { &m.userAuthTokenSecure },
                |m: &mut RequestPropertiesProto| { &mut m.userAuthTokenSecure },
                RequestPropertiesProto::get_userAuthTokenSecure,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "softwareVersion",
                |m: &RequestPropertiesProto| { &m.softwareVersion },
                |m: &mut RequestPropertiesProto| { &mut m.softwareVersion },
                RequestPropertiesProto::get_softwareVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "aid",
                |m: &RequestPropertiesProto| { &m.aid },
                |m: &mut RequestPropertiesProto| { &mut m.aid },
                RequestPropertiesProto::get_aid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "productNameAndVersion",
                |m: &RequestPropertiesProto| { &m.productNameAndVersion },
                |m: &mut RequestPropertiesProto| { &mut m.productNameAndVersion },
                RequestPropertiesProto::get_productNameAndVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userLanguage",
                |m: &RequestPropertiesProto| { &m.userLanguage },
                |m: &mut RequestPropertiesProto| { &mut m.userLanguage },
                RequestPropertiesProto::get_userLanguage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "userCountry",
                |m: &RequestPropertiesProto| { &m.userCountry },
                |m: &mut RequestPropertiesProto| { &mut m.userCountry },
                RequestPropertiesProto::get_userCountry,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "operatorName",
                |m: &RequestPropertiesProto| { &m.operatorName },
                |m: &mut RequestPropertiesProto| { &mut m.operatorName },
                RequestPropertiesProto::get_operatorName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "simOperatorName",
                |m: &RequestPropertiesProto| { &m.simOperatorName },
                |m: &mut RequestPropertiesProto| { &mut m.simOperatorName },
                RequestPropertiesProto::get_simOperatorName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "operatorNumericName",
                |m: &RequestPropertiesProto| { &m.operatorNumericName },
                |m: &mut RequestPropertiesProto| { &mut m.operatorNumericName },
                RequestPropertiesProto::get_operatorNumericName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "simOperatorNumericName",
                |m: &RequestPropertiesProto| { &m.simOperatorNumericName },
                |m: &mut RequestPropertiesProto| { &mut m.simOperatorNumericName },
                RequestPropertiesProto::get_simOperatorNumericName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "clientId",
                |m: &RequestPropertiesProto| { &m.clientId },
                |m: &mut RequestPropertiesProto| { &mut m.clientId },
                RequestPropertiesProto::get_clientId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "loggingId",
                |m: &RequestPropertiesProto| { &m.loggingId },
                |m: &mut RequestPropertiesProto| { &mut m.loggingId },
                RequestPropertiesProto::get_loggingId,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RequestPropertiesProto>(
                "RequestPropertiesProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestPropertiesProto {
        static instance: ::protobuf::rt::Lazy<RequestPropertiesProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RequestPropertiesProto::new)
    }
}

impl ::protobuf::Clear for RequestPropertiesProto {
    fn clear(&mut self) {
        self.userAuthToken.clear();
        self.userAuthTokenSecure = ::std::option::Option::None;
        self.softwareVersion = ::std::option::Option::None;
        self.aid.clear();
        self.productNameAndVersion.clear();
        self.userLanguage.clear();
        self.userCountry.clear();
        self.operatorName.clear();
        self.simOperatorName.clear();
        self.operatorNumericName.clear();
        self.simOperatorNumericName.clear();
        self.clientId.clear();
        self.loggingId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestPropertiesProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPropertiesProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RequestProto {
    // message fields
    pub requestProperties: ::protobuf::SingularPtrField<RequestPropertiesProto>,
    // request: <group>
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RequestProto {
    pub fn new() -> RequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.requestProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<RequestPropertiesProto, _>(wire_type, is, &mut self.requestProperties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.requestProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.requestProperties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestProto {
        RequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestPropertiesProto>, _>(
                "requestProperties",
                |m: &RequestProto| { &m.requestProperties },
                |m: &mut RequestProto| { &mut m.requestProperties },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RequestProto>(
                "RequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestProto {
        static instance: ::protobuf::rt::Lazy<RequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RequestProto::new)
    }
}

impl ::protobuf::Clear for RequestProto {
    fn clear(&mut self) {
        self.requestProperties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RequestProto_Request {
    // message fields
    pub requestSpecificProperties: ::protobuf::SingularPtrField<RequestSpecificPropertiesProto>,
    pub assetRequest: ::protobuf::SingularPtrField<AssetsRequestProto>,
    pub commentsRequest: ::protobuf::SingularPtrField<CommentsRequestProto>,
    pub modifyCommentRequest: ::protobuf::SingularPtrField<ModifyCommentRequestProto>,
    pub purchasePostRequest: ::protobuf::SingularPtrField<PurchasePostRequestProto>,
    pub purchaseOrderRequest: ::protobuf::SingularPtrField<PurchaseOrderRequestProto>,
    pub contentSyncRequest: ::protobuf::SingularPtrField<ContentSyncRequestProto>,
    pub getAssetRequest: ::protobuf::SingularPtrField<GetAssetRequestProto>,
    pub getImageRequest: ::protobuf::SingularPtrField<GetImageRequestProto>,
    pub refundRequest: ::protobuf::SingularPtrField<RefundRequestProto>,
    pub purchaseMetadataRequest: ::protobuf::SingularPtrField<PurchaseMetadataRequestProto>,
    pub subCategoriesRequest: ::protobuf::SingularPtrField<GetSubCategoriesRequestProto>,
    pub uninstallReasonRequest: ::protobuf::SingularPtrField<UninstallReasonRequestProto>,
    pub rateCommentRequest: ::protobuf::SingularPtrField<RateCommentRequestProto>,
    pub checkLicenseRequest: ::protobuf::SingularPtrField<CheckLicenseRequestProto>,
    pub getMarketMetadataRequest: ::protobuf::SingularPtrField<GetMarketMetadataRequestProto>,
    pub getCategoriesRequest: ::protobuf::SingularPtrField<GetCategoriesRequestProto>,
    pub getCarrierInfoRequest: ::protobuf::SingularPtrField<GetCarrierInfoRequestProto>,
    pub removeAssetRequest: ::protobuf::SingularPtrField<RemoveAssetRequestProto>,
    pub restoreApplicationsRequest: ::protobuf::SingularPtrField<RestoreApplicationsRequestProto>,
    pub querySuggestionRequest: ::protobuf::SingularPtrField<QuerySuggestionRequestProto>,
    pub billingEventRequest: ::protobuf::SingularPtrField<BillingEventRequestProto>,
    pub paypalPreapprovalRequest: ::protobuf::SingularPtrField<PaypalPreapprovalRequestProto>,
    pub paypalPreapprovalDetailsRequest: ::protobuf::SingularPtrField<PaypalPreapprovalDetailsRequestProto>,
    pub paypalCreateAccountRequest: ::protobuf::SingularPtrField<PaypalCreateAccountRequestProto>,
    pub paypalPreapprovalCredentialsRequest: ::protobuf::SingularPtrField<PaypalPreapprovalCredentialsRequestProto>,
    pub inAppRestoreTransactionsRequest: ::protobuf::SingularPtrField<InAppRestoreTransactionsRequestProto>,
    pub inAppPurchaseInformationRequest: ::protobuf::SingularPtrField<InAppPurchaseInformationRequestProto>,
    pub checkForNotificationsRequest: ::protobuf::SingularPtrField<CheckForNotificationsRequestProto>,
    pub ackNotificationsRequest: ::protobuf::SingularPtrField<AckNotificationsRequestProto>,
    pub purchaseProductRequest: ::protobuf::SingularPtrField<PurchaseProductRequestProto>,
    pub reconstructDatabaseRequest: ::protobuf::SingularPtrField<ReconstructDatabaseRequestProto>,
    pub paypalMassageAddressRequest: ::protobuf::SingularPtrField<PaypalMassageAddressRequestProto>,
    pub getAddressSnippetRequest: ::protobuf::SingularPtrField<GetAddressSnippetRequestProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RequestProto_Request {
    pub fn new() -> RequestProto_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestProto_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.requestSpecificProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commentsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyCommentRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchasePostRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseOrderRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentSyncRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAssetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getImageRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refundRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseMetadataRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subCategoriesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uninstallReasonRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateCommentRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkLicenseRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getMarketMetadataRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCategoriesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCarrierInfoRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.removeAssetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restoreApplicationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestionRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingEventRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalDetailsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCreateAccountRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalCredentialsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppRestoreTransactionsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppPurchaseInformationRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkForNotificationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseProductRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reconstructDatabaseRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalMassageAddressRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAddressSnippetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into::<RequestSpecificPropertiesProto, _>(wire_type, is, &mut self.requestSpecificProperties)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<AssetsRequestProto, _>(wire_type, is, &mut self.assetRequest)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<CommentsRequestProto, _>(wire_type, is, &mut self.commentsRequest)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<ModifyCommentRequestProto, _>(wire_type, is, &mut self.modifyCommentRequest)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<PurchasePostRequestProto, _>(wire_type, is, &mut self.purchasePostRequest)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseOrderRequestProto, _>(wire_type, is, &mut self.purchaseOrderRequest)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<ContentSyncRequestProto, _>(wire_type, is, &mut self.contentSyncRequest)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<GetAssetRequestProto, _>(wire_type, is, &mut self.getAssetRequest)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<GetImageRequestProto, _>(wire_type, is, &mut self.getImageRequest)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<RefundRequestProto, _>(wire_type, is, &mut self.refundRequest)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseMetadataRequestProto, _>(wire_type, is, &mut self.purchaseMetadataRequest)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into::<GetSubCategoriesRequestProto, _>(wire_type, is, &mut self.subCategoriesRequest)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into::<UninstallReasonRequestProto, _>(wire_type, is, &mut self.uninstallReasonRequest)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<RateCommentRequestProto, _>(wire_type, is, &mut self.rateCommentRequest)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into::<CheckLicenseRequestProto, _>(wire_type, is, &mut self.checkLicenseRequest)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into::<GetMarketMetadataRequestProto, _>(wire_type, is, &mut self.getMarketMetadataRequest)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into::<GetCategoriesRequestProto, _>(wire_type, is, &mut self.getCategoriesRequest)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into::<GetCarrierInfoRequestProto, _>(wire_type, is, &mut self.getCarrierInfoRequest)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into::<RemoveAssetRequestProto, _>(wire_type, is, &mut self.removeAssetRequest)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into::<RestoreApplicationsRequestProto, _>(wire_type, is, &mut self.restoreApplicationsRequest)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into::<QuerySuggestionRequestProto, _>(wire_type, is, &mut self.querySuggestionRequest)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into::<BillingEventRequestProto, _>(wire_type, is, &mut self.billingEventRequest)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalRequestProto, _>(wire_type, is, &mut self.paypalPreapprovalRequest)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalDetailsRequestProto, _>(wire_type, is, &mut self.paypalPreapprovalDetailsRequest)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalCreateAccountRequestProto, _>(wire_type, is, &mut self.paypalCreateAccountRequest)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalCredentialsRequestProto, _>(wire_type, is, &mut self.paypalPreapprovalCredentialsRequest)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into::<InAppRestoreTransactionsRequestProto, _>(wire_type, is, &mut self.inAppRestoreTransactionsRequest)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into::<InAppPurchaseInformationRequestProto, _>(wire_type, is, &mut self.inAppPurchaseInformationRequest)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into::<CheckForNotificationsRequestProto, _>(wire_type, is, &mut self.checkForNotificationsRequest)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into::<AckNotificationsRequestProto, _>(wire_type, is, &mut self.ackNotificationsRequest)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseProductRequestProto, _>(wire_type, is, &mut self.purchaseProductRequest)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into::<ReconstructDatabaseRequestProto, _>(wire_type, is, &mut self.reconstructDatabaseRequest)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalMassageAddressRequestProto, _>(wire_type, is, &mut self.paypalMassageAddressRequest)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into::<GetAddressSnippetRequestProto, _>(wire_type, is, &mut self.getAddressSnippetRequest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.requestSpecificProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.assetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.commentsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.modifyCommentRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchasePostRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseOrderRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.contentSyncRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getAssetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getImageRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.refundRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseMetadataRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.subCategoriesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.uninstallReasonRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rateCommentRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkLicenseRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getMarketMetadataRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getCategoriesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getCarrierInfoRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.removeAssetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.restoreApplicationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.querySuggestionRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.billingEventRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalDetailsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalCreateAccountRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalCredentialsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.inAppRestoreTransactionsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.inAppPurchaseInformationRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkForNotificationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ackNotificationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseProductRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reconstructDatabaseRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalMassageAddressRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getAddressSnippetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.requestSpecificProperties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.assetRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.commentsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.modifyCommentRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.purchasePostRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.purchaseOrderRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.contentSyncRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.getAssetRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.getImageRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.refundRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.purchaseMetadataRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.subCategoriesRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.uninstallReasonRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.rateCommentRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.checkLicenseRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.getMarketMetadataRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.getCategoriesRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.getCarrierInfoRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.removeAssetRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.restoreApplicationsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.querySuggestionRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.billingEventRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalDetailsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.paypalCreateAccountRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalCredentialsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.inAppRestoreTransactionsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.inAppPurchaseInformationRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.checkForNotificationsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.ackNotificationsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.purchaseProductRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.reconstructDatabaseRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.paypalMassageAddressRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.getAddressSnippetRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestProto_Request {
        RequestProto_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestSpecificPropertiesProto>, _>(
                "requestSpecificProperties",
                |m: &RequestProto_Request| { &m.requestSpecificProperties },
                |m: &mut RequestProto_Request| { &mut m.requestSpecificProperties },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetsRequestProto>, _>(
                "assetRequest",
                |m: &RequestProto_Request| { &m.assetRequest },
                |m: &mut RequestProto_Request| { &mut m.assetRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentsRequestProto>, _>(
                "commentsRequest",
                |m: &RequestProto_Request| { &m.commentsRequest },
                |m: &mut RequestProto_Request| { &mut m.commentsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyCommentRequestProto>, _>(
                "modifyCommentRequest",
                |m: &RequestProto_Request| { &m.modifyCommentRequest },
                |m: &mut RequestProto_Request| { &mut m.modifyCommentRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchasePostRequestProto>, _>(
                "purchasePostRequest",
                |m: &RequestProto_Request| { &m.purchasePostRequest },
                |m: &mut RequestProto_Request| { &mut m.purchasePostRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseOrderRequestProto>, _>(
                "purchaseOrderRequest",
                |m: &RequestProto_Request| { &m.purchaseOrderRequest },
                |m: &mut RequestProto_Request| { &mut m.purchaseOrderRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentSyncRequestProto>, _>(
                "contentSyncRequest",
                |m: &RequestProto_Request| { &m.contentSyncRequest },
                |m: &mut RequestProto_Request| { &mut m.contentSyncRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetRequestProto>, _>(
                "getAssetRequest",
                |m: &RequestProto_Request| { &m.getAssetRequest },
                |m: &mut RequestProto_Request| { &mut m.getAssetRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetImageRequestProto>, _>(
                "getImageRequest",
                |m: &RequestProto_Request| { &m.getImageRequest },
                |m: &mut RequestProto_Request| { &mut m.getImageRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RefundRequestProto>, _>(
                "refundRequest",
                |m: &RequestProto_Request| { &m.refundRequest },
                |m: &mut RequestProto_Request| { &mut m.refundRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseMetadataRequestProto>, _>(
                "purchaseMetadataRequest",
                |m: &RequestProto_Request| { &m.purchaseMetadataRequest },
                |m: &mut RequestProto_Request| { &mut m.purchaseMetadataRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSubCategoriesRequestProto>, _>(
                "subCategoriesRequest",
                |m: &RequestProto_Request| { &m.subCategoriesRequest },
                |m: &mut RequestProto_Request| { &mut m.subCategoriesRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UninstallReasonRequestProto>, _>(
                "uninstallReasonRequest",
                |m: &RequestProto_Request| { &m.uninstallReasonRequest },
                |m: &mut RequestProto_Request| { &mut m.uninstallReasonRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateCommentRequestProto>, _>(
                "rateCommentRequest",
                |m: &RequestProto_Request| { &m.rateCommentRequest },
                |m: &mut RequestProto_Request| { &mut m.rateCommentRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckLicenseRequestProto>, _>(
                "checkLicenseRequest",
                |m: &RequestProto_Request| { &m.checkLicenseRequest },
                |m: &mut RequestProto_Request| { &mut m.checkLicenseRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetMarketMetadataRequestProto>, _>(
                "getMarketMetadataRequest",
                |m: &RequestProto_Request| { &m.getMarketMetadataRequest },
                |m: &mut RequestProto_Request| { &mut m.getMarketMetadataRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCategoriesRequestProto>, _>(
                "getCategoriesRequest",
                |m: &RequestProto_Request| { &m.getCategoriesRequest },
                |m: &mut RequestProto_Request| { &mut m.getCategoriesRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCarrierInfoRequestProto>, _>(
                "getCarrierInfoRequest",
                |m: &RequestProto_Request| { &m.getCarrierInfoRequest },
                |m: &mut RequestProto_Request| { &mut m.getCarrierInfoRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoveAssetRequestProto>, _>(
                "removeAssetRequest",
                |m: &RequestProto_Request| { &m.removeAssetRequest },
                |m: &mut RequestProto_Request| { &mut m.removeAssetRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreApplicationsRequestProto>, _>(
                "restoreApplicationsRequest",
                |m: &RequestProto_Request| { &m.restoreApplicationsRequest },
                |m: &mut RequestProto_Request| { &mut m.restoreApplicationsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionRequestProto>, _>(
                "querySuggestionRequest",
                |m: &RequestProto_Request| { &m.querySuggestionRequest },
                |m: &mut RequestProto_Request| { &mut m.querySuggestionRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingEventRequestProto>, _>(
                "billingEventRequest",
                |m: &RequestProto_Request| { &m.billingEventRequest },
                |m: &mut RequestProto_Request| { &mut m.billingEventRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalRequestProto>, _>(
                "paypalPreapprovalRequest",
                |m: &RequestProto_Request| { &m.paypalPreapprovalRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalPreapprovalRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalDetailsRequestProto>, _>(
                "paypalPreapprovalDetailsRequest",
                |m: &RequestProto_Request| { &m.paypalPreapprovalDetailsRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalPreapprovalDetailsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCreateAccountRequestProto>, _>(
                "paypalCreateAccountRequest",
                |m: &RequestProto_Request| { &m.paypalCreateAccountRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalCreateAccountRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalCredentialsRequestProto>, _>(
                "paypalPreapprovalCredentialsRequest",
                |m: &RequestProto_Request| { &m.paypalPreapprovalCredentialsRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalPreapprovalCredentialsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppRestoreTransactionsRequestProto>, _>(
                "inAppRestoreTransactionsRequest",
                |m: &RequestProto_Request| { &m.inAppRestoreTransactionsRequest },
                |m: &mut RequestProto_Request| { &mut m.inAppRestoreTransactionsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppPurchaseInformationRequestProto>, _>(
                "inAppPurchaseInformationRequest",
                |m: &RequestProto_Request| { &m.inAppPurchaseInformationRequest },
                |m: &mut RequestProto_Request| { &mut m.inAppPurchaseInformationRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckForNotificationsRequestProto>, _>(
                "checkForNotificationsRequest",
                |m: &RequestProto_Request| { &m.checkForNotificationsRequest },
                |m: &mut RequestProto_Request| { &mut m.checkForNotificationsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationsRequestProto>, _>(
                "ackNotificationsRequest",
                |m: &RequestProto_Request| { &m.ackNotificationsRequest },
                |m: &mut RequestProto_Request| { &mut m.ackNotificationsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseProductRequestProto>, _>(
                "purchaseProductRequest",
                |m: &RequestProto_Request| { &m.purchaseProductRequest },
                |m: &mut RequestProto_Request| { &mut m.purchaseProductRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconstructDatabaseRequestProto>, _>(
                "reconstructDatabaseRequest",
                |m: &RequestProto_Request| { &m.reconstructDatabaseRequest },
                |m: &mut RequestProto_Request| { &mut m.reconstructDatabaseRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalMassageAddressRequestProto>, _>(
                "paypalMassageAddressRequest",
                |m: &RequestProto_Request| { &m.paypalMassageAddressRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalMassageAddressRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressSnippetRequestProto>, _>(
                "getAddressSnippetRequest",
                |m: &RequestProto_Request| { &m.getAddressSnippetRequest },
                |m: &mut RequestProto_Request| { &mut m.getAddressSnippetRequest },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RequestProto_Request>(
                "RequestProto_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestProto_Request {
        static instance: ::protobuf::rt::Lazy<RequestProto_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(RequestProto_Request::new)
    }
}

impl ::protobuf::Clear for RequestProto_Request {
    fn clear(&mut self) {
        self.requestSpecificProperties.clear();
        self.assetRequest.clear();
        self.commentsRequest.clear();
        self.modifyCommentRequest.clear();
        self.purchasePostRequest.clear();
        self.purchaseOrderRequest.clear();
        self.contentSyncRequest.clear();
        self.getAssetRequest.clear();
        self.getImageRequest.clear();
        self.refundRequest.clear();
        self.purchaseMetadataRequest.clear();
        self.subCategoriesRequest.clear();
        self.uninstallReasonRequest.clear();
        self.rateCommentRequest.clear();
        self.checkLicenseRequest.clear();
        self.getMarketMetadataRequest.clear();
        self.getCategoriesRequest.clear();
        self.getCarrierInfoRequest.clear();
        self.removeAssetRequest.clear();
        self.restoreApplicationsRequest.clear();
        self.querySuggestionRequest.clear();
        self.billingEventRequest.clear();
        self.paypalPreapprovalRequest.clear();
        self.paypalPreapprovalDetailsRequest.clear();
        self.paypalCreateAccountRequest.clear();
        self.paypalPreapprovalCredentialsRequest.clear();
        self.inAppRestoreTransactionsRequest.clear();
        self.inAppPurchaseInformationRequest.clear();
        self.checkForNotificationsRequest.clear();
        self.ackNotificationsRequest.clear();
        self.purchaseProductRequest.clear();
        self.reconstructDatabaseRequest.clear();
        self.paypalMassageAddressRequest.clear();
        self.getAddressSnippetRequest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestProto_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestProto_Request {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RequestSpecificPropertiesProto {
    // message fields
    pub ifNoneMatch: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RequestSpecificPropertiesProto {
    pub fn new() -> RequestSpecificPropertiesProto {
        ::std::default::Default::default()
    }

    // optional string ifNoneMatch = 1;

    pub fn get_ifNoneMatch(&self) -> &str {
        match self.ifNoneMatch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RequestSpecificPropertiesProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ifNoneMatch)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ifNoneMatch.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ifNoneMatch.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestSpecificPropertiesProto {
        RequestSpecificPropertiesProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "ifNoneMatch",
                |m: &RequestSpecificPropertiesProto| { &m.ifNoneMatch },
                |m: &mut RequestSpecificPropertiesProto| { &mut m.ifNoneMatch },
                RequestSpecificPropertiesProto::get_ifNoneMatch,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RequestSpecificPropertiesProto>(
                "RequestSpecificPropertiesProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestSpecificPropertiesProto {
        static instance: ::protobuf::rt::Lazy<RequestSpecificPropertiesProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RequestSpecificPropertiesProto::new)
    }
}

impl ::protobuf::Clear for RequestSpecificPropertiesProto {
    fn clear(&mut self) {
        self.ifNoneMatch.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestSpecificPropertiesProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestSpecificPropertiesProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ResponsePropertiesProto {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub maxAge: ::std::option::Option<i32>,
    pub etag: ::protobuf::SingularField<::std::string::String>,
    pub serverVersion: ::std::option::Option<i32>,
    pub maxAgeConsumable: ::std::option::Option<i32>,
    pub errorMessage: ::protobuf::SingularField<::std::string::String>,
    pub errorInputField: ::protobuf::RepeatedField<InputValidationError>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ResponsePropertiesProto {
    pub fn new() -> ResponsePropertiesProto {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional int32 maxAge = 2;

    pub fn get_maxAge(&self) -> i32 {
        self.maxAge.unwrap_or(0)
    }

    // optional string etag = 3;

    pub fn get_etag(&self) -> &str {
        match self.etag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 serverVersion = 4;

    pub fn get_serverVersion(&self) -> i32 {
        self.serverVersion.unwrap_or(0)
    }

    // optional int32 maxAgeConsumable = 6;

    pub fn get_maxAgeConsumable(&self) -> i32 {
        self.maxAgeConsumable.unwrap_or(0)
    }

    // optional string errorMessage = 7;

    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ResponsePropertiesProto {
    fn is_initialized(&self) -> bool {
        for v in &self.errorInputField {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxAge = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.etag)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.serverVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxAgeConsumable = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.errorInputField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxAge {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.etag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.serverVersion {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxAgeConsumable {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.errorInputField {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.maxAge {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.etag.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.serverVersion {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maxAgeConsumable {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.errorMessage.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.errorInputField {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponsePropertiesProto {
        ResponsePropertiesProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "result",
                |m: &ResponsePropertiesProto| { &m.result },
                |m: &mut ResponsePropertiesProto| { &mut m.result },
                ResponsePropertiesProto::get_result,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "maxAge",
                |m: &ResponsePropertiesProto| { &m.maxAge },
                |m: &mut ResponsePropertiesProto| { &mut m.maxAge },
                ResponsePropertiesProto::get_maxAge,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "etag",
                |m: &ResponsePropertiesProto| { &m.etag },
                |m: &mut ResponsePropertiesProto| { &mut m.etag },
                ResponsePropertiesProto::get_etag,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "serverVersion",
                |m: &ResponsePropertiesProto| { &m.serverVersion },
                |m: &mut ResponsePropertiesProto| { &mut m.serverVersion },
                ResponsePropertiesProto::get_serverVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "maxAgeConsumable",
                |m: &ResponsePropertiesProto| { &m.maxAgeConsumable },
                |m: &mut ResponsePropertiesProto| { &mut m.maxAgeConsumable },
                ResponsePropertiesProto::get_maxAgeConsumable,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "errorMessage",
                |m: &ResponsePropertiesProto| { &m.errorMessage },
                |m: &mut ResponsePropertiesProto| { &mut m.errorMessage },
                ResponsePropertiesProto::get_errorMessage,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputValidationError>>(
                "errorInputField",
                |m: &ResponsePropertiesProto| { &m.errorInputField },
                |m: &mut ResponsePropertiesProto| { &mut m.errorInputField },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ResponsePropertiesProto>(
                "ResponsePropertiesProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponsePropertiesProto {
        static instance: ::protobuf::rt::Lazy<ResponsePropertiesProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ResponsePropertiesProto::new)
    }
}

impl ::protobuf::Clear for ResponsePropertiesProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.maxAge = ::std::option::Option::None;
        self.etag.clear();
        self.serverVersion = ::std::option::Option::None;
        self.maxAgeConsumable = ::std::option::Option::None;
        self.errorMessage.clear();
        self.errorInputField.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponsePropertiesProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponsePropertiesProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ResponseProto {
    // message fields
    // response: <group>
    pub pendingNotifications: ::protobuf::SingularPtrField<PendingNotificationsProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ResponseProto {
    pub fn new() -> ResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.pendingNotifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                38 => {
                    ::protobuf::rt::read_singular_message_into::<PendingNotificationsProto, _>(wire_type, is, &mut self.pendingNotifications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pendingNotifications.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pendingNotifications.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseProto {
        ResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingNotificationsProto>, _>(
                "pendingNotifications",
                |m: &ResponseProto| { &m.pendingNotifications },
                |m: &mut ResponseProto| { &mut m.pendingNotifications },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ResponseProto>(
                "ResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseProto {
        static instance: ::protobuf::rt::Lazy<ResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(ResponseProto::new)
    }
}

impl ::protobuf::Clear for ResponseProto {
    fn clear(&mut self) {
        self.pendingNotifications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct ResponseProto_Response {
    // message fields
    pub responseProperties: ::protobuf::SingularPtrField<ResponsePropertiesProto>,
    pub assetsResponse: ::protobuf::SingularPtrField<AssetsResponseProto>,
    pub commentsResponse: ::protobuf::SingularPtrField<CommentsResponseProto>,
    pub modifyCommentResponse: ::protobuf::SingularPtrField<ModifyCommentResponseProto>,
    pub purchasePostResponse: ::protobuf::SingularPtrField<PurchasePostResponseProto>,
    pub purchaseOrderResponse: ::protobuf::SingularPtrField<PurchaseOrderResponseProto>,
    pub contentSyncResponse: ::protobuf::SingularPtrField<ContentSyncResponseProto>,
    pub getAssetResponse: ::protobuf::SingularPtrField<GetAssetResponseProto>,
    pub getImageResponse: ::protobuf::SingularPtrField<GetImageResponseProto>,
    pub refundResponse: ::protobuf::SingularPtrField<RefundResponseProto>,
    pub purchaseMetadataResponse: ::protobuf::SingularPtrField<PurchaseMetadataResponseProto>,
    pub subCategoriesResponse: ::protobuf::SingularPtrField<GetSubCategoriesResponseProto>,
    pub uninstallReasonResponse: ::protobuf::SingularPtrField<UninstallReasonResponseProto>,
    pub rateCommentResponse: ::protobuf::SingularPtrField<RateCommentResponseProto>,
    pub checkLicenseResponse: ::protobuf::SingularPtrField<CheckLicenseResponseProto>,
    pub getMarketMetadataResponse: ::protobuf::SingularPtrField<GetMarketMetadataResponseProto>,
    pub prefetchedBundle: ::protobuf::RepeatedField<PrefetchedBundleProto>,
    pub getCategoriesResponse: ::protobuf::SingularPtrField<GetCategoriesResponseProto>,
    pub getCarrierInfoResponse: ::protobuf::SingularPtrField<GetCarrierInfoResponseProto>,
    pub restoreApplicationResponse: ::protobuf::SingularPtrField<RestoreApplicationsResponseProto>,
    pub querySuggestionResponse: ::protobuf::SingularPtrField<QuerySuggestionResponseProto>,
    pub billingEventResponse: ::protobuf::SingularPtrField<BillingEventResponseProto>,
    pub paypalPreapprovalResponse: ::protobuf::SingularPtrField<PaypalPreapprovalResponseProto>,
    pub paypalPreapprovalDetailsResponse: ::protobuf::SingularPtrField<PaypalPreapprovalDetailsResponseProto>,
    pub paypalCreateAccountResponse: ::protobuf::SingularPtrField<PaypalCreateAccountResponseProto>,
    pub paypalPreapprovalCredentialsResponse: ::protobuf::SingularPtrField<PaypalPreapprovalCredentialsResponseProto>,
    pub inAppRestoreTransactionsResponse: ::protobuf::SingularPtrField<InAppRestoreTransactionsResponseProto>,
    pub inAppPurchaseInformationResponse: ::protobuf::SingularPtrField<InAppPurchaseInformationResponseProto>,
    pub checkForNotificationsResponse: ::protobuf::SingularPtrField<CheckForNotificationsResponseProto>,
    pub ackNotificationsResponse: ::protobuf::SingularPtrField<AckNotificationsResponseProto>,
    pub purchaseProductResponse: ::protobuf::SingularPtrField<PurchaseProductResponseProto>,
    pub reconstructDatabaseResponse: ::protobuf::SingularPtrField<ReconstructDatabaseResponseProto>,
    pub paypalMassageAddressResponse: ::protobuf::SingularPtrField<PaypalMassageAddressResponseProto>,
    pub getAddressSnippetResponse: ::protobuf::SingularPtrField<GetAddressSnippetResponseProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl ResponseProto_Response {
    pub fn new() -> ResponseProto_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseProto_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.responseProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assetsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commentsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyCommentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchasePostResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseOrderResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentSyncResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAssetResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getImageResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refundResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subCategoriesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uninstallReasonResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateCommentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkLicenseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getMarketMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prefetchedBundle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCategoriesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCarrierInfoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restoreApplicationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestionResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingEventResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalDetailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCreateAccountResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalCredentialsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppRestoreTransactionsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppPurchaseInformationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkForNotificationsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseProductResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reconstructDatabaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalMassageAddressResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAddressSnippetResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ResponsePropertiesProto, _>(wire_type, is, &mut self.responseProperties)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<AssetsResponseProto, _>(wire_type, is, &mut self.assetsResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<CommentsResponseProto, _>(wire_type, is, &mut self.commentsResponse)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<ModifyCommentResponseProto, _>(wire_type, is, &mut self.modifyCommentResponse)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<PurchasePostResponseProto, _>(wire_type, is, &mut self.purchasePostResponse)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseOrderResponseProto, _>(wire_type, is, &mut self.purchaseOrderResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<ContentSyncResponseProto, _>(wire_type, is, &mut self.contentSyncResponse)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<GetAssetResponseProto, _>(wire_type, is, &mut self.getAssetResponse)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<GetImageResponseProto, _>(wire_type, is, &mut self.getImageResponse)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<RefundResponseProto, _>(wire_type, is, &mut self.refundResponse)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseMetadataResponseProto, _>(wire_type, is, &mut self.purchaseMetadataResponse)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<GetSubCategoriesResponseProto, _>(wire_type, is, &mut self.subCategoriesResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into::<UninstallReasonResponseProto, _>(wire_type, is, &mut self.uninstallReasonResponse)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into::<RateCommentResponseProto, _>(wire_type, is, &mut self.rateCommentResponse)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<CheckLicenseResponseProto, _>(wire_type, is, &mut self.checkLicenseResponse)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into::<GetMarketMetadataResponseProto, _>(wire_type, is, &mut self.getMarketMetadataResponse)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.prefetchedBundle)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into::<GetCategoriesResponseProto, _>(wire_type, is, &mut self.getCategoriesResponse)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into::<GetCarrierInfoResponseProto, _>(wire_type, is, &mut self.getCarrierInfoResponse)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into::<RestoreApplicationsResponseProto, _>(wire_type, is, &mut self.restoreApplicationResponse)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into::<QuerySuggestionResponseProto, _>(wire_type, is, &mut self.querySuggestionResponse)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into::<BillingEventResponseProto, _>(wire_type, is, &mut self.billingEventResponse)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalResponseProto, _>(wire_type, is, &mut self.paypalPreapprovalResponse)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalDetailsResponseProto, _>(wire_type, is, &mut self.paypalPreapprovalDetailsResponse)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalCreateAccountResponseProto, _>(wire_type, is, &mut self.paypalCreateAccountResponse)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalCredentialsResponseProto, _>(wire_type, is, &mut self.paypalPreapprovalCredentialsResponse)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into::<InAppRestoreTransactionsResponseProto, _>(wire_type, is, &mut self.inAppRestoreTransactionsResponse)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into::<InAppPurchaseInformationResponseProto, _>(wire_type, is, &mut self.inAppPurchaseInformationResponse)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into::<CheckForNotificationsResponseProto, _>(wire_type, is, &mut self.checkForNotificationsResponse)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into::<AckNotificationsResponseProto, _>(wire_type, is, &mut self.ackNotificationsResponse)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseProductResponseProto, _>(wire_type, is, &mut self.purchaseProductResponse)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into::<ReconstructDatabaseResponseProto, _>(wire_type, is, &mut self.reconstructDatabaseResponse)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalMassageAddressResponseProto, _>(wire_type, is, &mut self.paypalMassageAddressResponse)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into::<GetAddressSnippetResponseProto, _>(wire_type, is, &mut self.getAddressSnippetResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.responseProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.assetsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.commentsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.modifyCommentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchasePostResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseOrderResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.contentSyncResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getAssetResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getImageResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.refundResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.subCategoriesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.uninstallReasonResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rateCommentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkLicenseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getMarketMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.prefetchedBundle {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.getCategoriesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getCarrierInfoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.restoreApplicationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.querySuggestionResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.billingEventResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalDetailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalCreateAccountResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalCredentialsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.inAppRestoreTransactionsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.inAppPurchaseInformationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkForNotificationsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ackNotificationsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseProductResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reconstructDatabaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalMassageAddressResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getAddressSnippetResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.responseProperties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.assetsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.commentsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.modifyCommentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.purchasePostResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.purchaseOrderResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.contentSyncResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.getAssetResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.getImageResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.refundResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.purchaseMetadataResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.subCategoriesResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.uninstallReasonResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.rateCommentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.checkLicenseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.getMarketMetadataResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        for v in &self.prefetchedBundle {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        if let Some(v) = self.getCategoriesResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.getCarrierInfoResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.restoreApplicationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.querySuggestionResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.billingEventResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalDetailsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.paypalCreateAccountResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalCredentialsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.inAppRestoreTransactionsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.inAppPurchaseInformationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.checkForNotificationsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.ackNotificationsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.purchaseProductResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.reconstructDatabaseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.paypalMassageAddressResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.getAddressSnippetResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseProto_Response {
        ResponseProto_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponsePropertiesProto>, _>(
                "responseProperties",
                |m: &ResponseProto_Response| { &m.responseProperties },
                |m: &mut ResponseProto_Response| { &mut m.responseProperties },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetsResponseProto>, _>(
                "assetsResponse",
                |m: &ResponseProto_Response| { &m.assetsResponse },
                |m: &mut ResponseProto_Response| { &mut m.assetsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentsResponseProto>, _>(
                "commentsResponse",
                |m: &ResponseProto_Response| { &m.commentsResponse },
                |m: &mut ResponseProto_Response| { &mut m.commentsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyCommentResponseProto>, _>(
                "modifyCommentResponse",
                |m: &ResponseProto_Response| { &m.modifyCommentResponse },
                |m: &mut ResponseProto_Response| { &mut m.modifyCommentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchasePostResponseProto>, _>(
                "purchasePostResponse",
                |m: &ResponseProto_Response| { &m.purchasePostResponse },
                |m: &mut ResponseProto_Response| { &mut m.purchasePostResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseOrderResponseProto>, _>(
                "purchaseOrderResponse",
                |m: &ResponseProto_Response| { &m.purchaseOrderResponse },
                |m: &mut ResponseProto_Response| { &mut m.purchaseOrderResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentSyncResponseProto>, _>(
                "contentSyncResponse",
                |m: &ResponseProto_Response| { &m.contentSyncResponse },
                |m: &mut ResponseProto_Response| { &mut m.contentSyncResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetResponseProto>, _>(
                "getAssetResponse",
                |m: &ResponseProto_Response| { &m.getAssetResponse },
                |m: &mut ResponseProto_Response| { &mut m.getAssetResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetImageResponseProto>, _>(
                "getImageResponse",
                |m: &ResponseProto_Response| { &m.getImageResponse },
                |m: &mut ResponseProto_Response| { &mut m.getImageResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RefundResponseProto>, _>(
                "refundResponse",
                |m: &ResponseProto_Response| { &m.refundResponse },
                |m: &mut ResponseProto_Response| { &mut m.refundResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseMetadataResponseProto>, _>(
                "purchaseMetadataResponse",
                |m: &ResponseProto_Response| { &m.purchaseMetadataResponse },
                |m: &mut ResponseProto_Response| { &mut m.purchaseMetadataResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSubCategoriesResponseProto>, _>(
                "subCategoriesResponse",
                |m: &ResponseProto_Response| { &m.subCategoriesResponse },
                |m: &mut ResponseProto_Response| { &mut m.subCategoriesResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UninstallReasonResponseProto>, _>(
                "uninstallReasonResponse",
                |m: &ResponseProto_Response| { &m.uninstallReasonResponse },
                |m: &mut ResponseProto_Response| { &mut m.uninstallReasonResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateCommentResponseProto>, _>(
                "rateCommentResponse",
                |m: &ResponseProto_Response| { &m.rateCommentResponse },
                |m: &mut ResponseProto_Response| { &mut m.rateCommentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckLicenseResponseProto>, _>(
                "checkLicenseResponse",
                |m: &ResponseProto_Response| { &m.checkLicenseResponse },
                |m: &mut ResponseProto_Response| { &mut m.checkLicenseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetMarketMetadataResponseProto>, _>(
                "getMarketMetadataResponse",
                |m: &ResponseProto_Response| { &m.getMarketMetadataResponse },
                |m: &mut ResponseProto_Response| { &mut m.getMarketMetadataResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrefetchedBundleProto>>(
                "prefetchedBundle",
                |m: &ResponseProto_Response| { &m.prefetchedBundle },
                |m: &mut ResponseProto_Response| { &mut m.prefetchedBundle },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCategoriesResponseProto>, _>(
                "getCategoriesResponse",
                |m: &ResponseProto_Response| { &m.getCategoriesResponse },
                |m: &mut ResponseProto_Response| { &mut m.getCategoriesResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCarrierInfoResponseProto>, _>(
                "getCarrierInfoResponse",
                |m: &ResponseProto_Response| { &m.getCarrierInfoResponse },
                |m: &mut ResponseProto_Response| { &mut m.getCarrierInfoResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreApplicationsResponseProto>, _>(
                "restoreApplicationResponse",
                |m: &ResponseProto_Response| { &m.restoreApplicationResponse },
                |m: &mut ResponseProto_Response| { &mut m.restoreApplicationResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionResponseProto>, _>(
                "querySuggestionResponse",
                |m: &ResponseProto_Response| { &m.querySuggestionResponse },
                |m: &mut ResponseProto_Response| { &mut m.querySuggestionResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingEventResponseProto>, _>(
                "billingEventResponse",
                |m: &ResponseProto_Response| { &m.billingEventResponse },
                |m: &mut ResponseProto_Response| { &mut m.billingEventResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalResponseProto>, _>(
                "paypalPreapprovalResponse",
                |m: &ResponseProto_Response| { &m.paypalPreapprovalResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalPreapprovalResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalDetailsResponseProto>, _>(
                "paypalPreapprovalDetailsResponse",
                |m: &ResponseProto_Response| { &m.paypalPreapprovalDetailsResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalPreapprovalDetailsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCreateAccountResponseProto>, _>(
                "paypalCreateAccountResponse",
                |m: &ResponseProto_Response| { &m.paypalCreateAccountResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalCreateAccountResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalCredentialsResponseProto>, _>(
                "paypalPreapprovalCredentialsResponse",
                |m: &ResponseProto_Response| { &m.paypalPreapprovalCredentialsResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalPreapprovalCredentialsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppRestoreTransactionsResponseProto>, _>(
                "inAppRestoreTransactionsResponse",
                |m: &ResponseProto_Response| { &m.inAppRestoreTransactionsResponse },
                |m: &mut ResponseProto_Response| { &mut m.inAppRestoreTransactionsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppPurchaseInformationResponseProto>, _>(
                "inAppPurchaseInformationResponse",
                |m: &ResponseProto_Response| { &m.inAppPurchaseInformationResponse },
                |m: &mut ResponseProto_Response| { &mut m.inAppPurchaseInformationResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckForNotificationsResponseProto>, _>(
                "checkForNotificationsResponse",
                |m: &ResponseProto_Response| { &m.checkForNotificationsResponse },
                |m: &mut ResponseProto_Response| { &mut m.checkForNotificationsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationsResponseProto>, _>(
                "ackNotificationsResponse",
                |m: &ResponseProto_Response| { &m.ackNotificationsResponse },
                |m: &mut ResponseProto_Response| { &mut m.ackNotificationsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseProductResponseProto>, _>(
                "purchaseProductResponse",
                |m: &ResponseProto_Response| { &m.purchaseProductResponse },
                |m: &mut ResponseProto_Response| { &mut m.purchaseProductResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconstructDatabaseResponseProto>, _>(
                "reconstructDatabaseResponse",
                |m: &ResponseProto_Response| { &m.reconstructDatabaseResponse },
                |m: &mut ResponseProto_Response| { &mut m.reconstructDatabaseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalMassageAddressResponseProto>, _>(
                "paypalMassageAddressResponse",
                |m: &ResponseProto_Response| { &m.paypalMassageAddressResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalMassageAddressResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressSnippetResponseProto>, _>(
                "getAddressSnippetResponse",
                |m: &ResponseProto_Response| { &m.getAddressSnippetResponse },
                |m: &mut ResponseProto_Response| { &mut m.getAddressSnippetResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<ResponseProto_Response>(
                "ResponseProto_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseProto_Response {
        static instance: ::protobuf::rt::Lazy<ResponseProto_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(ResponseProto_Response::new)
    }
}

impl ::protobuf::Clear for ResponseProto_Response {
    fn clear(&mut self) {
        self.responseProperties.clear();
        self.assetsResponse.clear();
        self.commentsResponse.clear();
        self.modifyCommentResponse.clear();
        self.purchasePostResponse.clear();
        self.purchaseOrderResponse.clear();
        self.contentSyncResponse.clear();
        self.getAssetResponse.clear();
        self.getImageResponse.clear();
        self.refundResponse.clear();
        self.purchaseMetadataResponse.clear();
        self.subCategoriesResponse.clear();
        self.uninstallReasonResponse.clear();
        self.rateCommentResponse.clear();
        self.checkLicenseResponse.clear();
        self.getMarketMetadataResponse.clear();
        self.prefetchedBundle.clear();
        self.getCategoriesResponse.clear();
        self.getCarrierInfoResponse.clear();
        self.restoreApplicationResponse.clear();
        self.querySuggestionResponse.clear();
        self.billingEventResponse.clear();
        self.paypalPreapprovalResponse.clear();
        self.paypalPreapprovalDetailsResponse.clear();
        self.paypalCreateAccountResponse.clear();
        self.paypalPreapprovalCredentialsResponse.clear();
        self.inAppRestoreTransactionsResponse.clear();
        self.inAppPurchaseInformationResponse.clear();
        self.checkForNotificationsResponse.clear();
        self.ackNotificationsResponse.clear();
        self.purchaseProductResponse.clear();
        self.reconstructDatabaseResponse.clear();
        self.paypalMassageAddressResponse.clear();
        self.getAddressSnippetResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseProto_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseProto_Response {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RestoreApplicationsRequestProto {
    // message fields
    pub backupAndroidId: ::protobuf::SingularField<::std::string::String>,
    pub tosVersion: ::protobuf::SingularField<::std::string::String>,
    pub deviceConfiguration: ::protobuf::SingularPtrField<DeviceConfigurationProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RestoreApplicationsRequestProto {
    pub fn new() -> RestoreApplicationsRequestProto {
        ::std::default::Default::default()
    }

    // optional string backupAndroidId = 1;

    pub fn get_backupAndroidId(&self) -> &str {
        match self.backupAndroidId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string tosVersion = 2;

    pub fn get_tosVersion(&self) -> &str {
        match self.tosVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RestoreApplicationsRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.deviceConfiguration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backupAndroidId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosVersion)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<DeviceConfigurationProto, _>(wire_type, is, &mut self.deviceConfiguration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.backupAndroidId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.tosVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.backupAndroidId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.tosVersion.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreApplicationsRequestProto {
        RestoreApplicationsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "backupAndroidId",
                |m: &RestoreApplicationsRequestProto| { &m.backupAndroidId },
                |m: &mut RestoreApplicationsRequestProto| { &mut m.backupAndroidId },
                RestoreApplicationsRequestProto::get_backupAndroidId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tosVersion",
                |m: &RestoreApplicationsRequestProto| { &m.tosVersion },
                |m: &mut RestoreApplicationsRequestProto| { &mut m.tosVersion },
                RestoreApplicationsRequestProto::get_tosVersion,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfigurationProto>, _>(
                "deviceConfiguration",
                |m: &RestoreApplicationsRequestProto| { &m.deviceConfiguration },
                |m: &mut RestoreApplicationsRequestProto| { &mut m.deviceConfiguration },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RestoreApplicationsRequestProto>(
                "RestoreApplicationsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreApplicationsRequestProto {
        static instance: ::protobuf::rt::Lazy<RestoreApplicationsRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RestoreApplicationsRequestProto::new)
    }
}

impl ::protobuf::Clear for RestoreApplicationsRequestProto {
    fn clear(&mut self) {
        self.backupAndroidId.clear();
        self.tosVersion.clear();
        self.deviceConfiguration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreApplicationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreApplicationsRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RestoreApplicationsResponseProto {
    // message fields
    pub asset: ::protobuf::RepeatedField<GetAssetResponseProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RestoreApplicationsResponseProto {
    pub fn new() -> RestoreApplicationsResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RestoreApplicationsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.asset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.asset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.asset {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreApplicationsResponseProto {
        RestoreApplicationsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetResponseProto>>(
                "asset",
                |m: &RestoreApplicationsResponseProto| { &m.asset },
                |m: &mut RestoreApplicationsResponseProto| { &mut m.asset },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RestoreApplicationsResponseProto>(
                "RestoreApplicationsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreApplicationsResponseProto {
        static instance: ::protobuf::rt::Lazy<RestoreApplicationsResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RestoreApplicationsResponseProto::new)
    }
}

impl ::protobuf::Clear for RestoreApplicationsResponseProto {
    fn clear(&mut self) {
        self.asset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreApplicationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreApplicationsResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct RiskHeaderInfoProto {
    // message fields
    pub hashedDeviceInfo: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl RiskHeaderInfoProto {
    pub fn new() -> RiskHeaderInfoProto {
        ::std::default::Default::default()
    }

    // optional string hashedDeviceInfo = 1;

    pub fn get_hashedDeviceInfo(&self) -> &str {
        match self.hashedDeviceInfo.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RiskHeaderInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hashedDeviceInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hashedDeviceInfo.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hashedDeviceInfo.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RiskHeaderInfoProto {
        RiskHeaderInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "hashedDeviceInfo",
                |m: &RiskHeaderInfoProto| { &m.hashedDeviceInfo },
                |m: &mut RiskHeaderInfoProto| { &mut m.hashedDeviceInfo },
                RiskHeaderInfoProto::get_hashedDeviceInfo,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<RiskHeaderInfoProto>(
                "RiskHeaderInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RiskHeaderInfoProto {
        static instance: ::protobuf::rt::Lazy<RiskHeaderInfoProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(RiskHeaderInfoProto::new)
    }
}

impl ::protobuf::Clear for RiskHeaderInfoProto {
    fn clear(&mut self) {
        self.hashedDeviceInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RiskHeaderInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiskHeaderInfoProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SignatureHashProto {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SignatureHashProto {
    pub fn new() -> SignatureHashProto {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;

    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;

    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional bytes hash = 3;

    pub fn get_hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for SignatureHashProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.hash.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignatureHashProto {
        SignatureHashProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "packageName",
                |m: &SignatureHashProto| { &m.packageName },
                |m: &mut SignatureHashProto| { &mut m.packageName },
                SignatureHashProto::get_packageName,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "versionCode",
                |m: &SignatureHashProto| { &m.versionCode },
                |m: &mut SignatureHashProto| { &mut m.versionCode },
                SignatureHashProto::get_versionCode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeBytes, _>(
                "hash",
                |m: &SignatureHashProto| { &m.hash },
                |m: &mut SignatureHashProto| { &mut m.hash },
                SignatureHashProto::get_hash,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SignatureHashProto>(
                "SignatureHashProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignatureHashProto {
        static instance: ::protobuf::rt::Lazy<SignatureHashProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(SignatureHashProto::new)
    }
}

impl ::protobuf::Clear for SignatureHashProto {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignatureHashProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignatureHashProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SignedDataProto {
    // message fields
    pub signedData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SignedDataProto {
    pub fn new() -> SignedDataProto {
        ::std::default::Default::default()
    }

    // optional string signedData = 1;

    pub fn get_signedData(&self) -> &str {
        match self.signedData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string signature = 2;

    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SignedDataProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedData)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.signedData.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.signedData.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedDataProto {
        SignedDataProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signedData",
                |m: &SignedDataProto| { &m.signedData },
                |m: &mut SignedDataProto| { &mut m.signedData },
                SignedDataProto::get_signedData,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "signature",
                |m: &SignedDataProto| { &m.signature },
                |m: &mut SignedDataProto| { &mut m.signature },
                SignedDataProto::get_signature,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SignedDataProto>(
                "SignedDataProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedDataProto {
        static instance: ::protobuf::rt::Lazy<SignedDataProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(SignedDataProto::new)
    }
}

impl ::protobuf::Clear for SignedDataProto {
    fn clear(&mut self) {
        self.signedData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedDataProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedDataProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SingleRequestProto {
    // message fields
    pub requestSpecificProperties: ::protobuf::SingularPtrField<RequestSpecificPropertiesProto>,
    pub assetRequest: ::protobuf::SingularPtrField<AssetsRequestProto>,
    pub commentsRequest: ::protobuf::SingularPtrField<CommentsRequestProto>,
    pub modifyCommentRequest: ::protobuf::SingularPtrField<ModifyCommentRequestProto>,
    pub purchasePostRequest: ::protobuf::SingularPtrField<PurchasePostRequestProto>,
    pub purchaseOrderRequest: ::protobuf::SingularPtrField<PurchaseOrderRequestProto>,
    pub contentSyncRequest: ::protobuf::SingularPtrField<ContentSyncRequestProto>,
    pub getAssetRequest: ::protobuf::SingularPtrField<GetAssetRequestProto>,
    pub getImageRequest: ::protobuf::SingularPtrField<GetImageRequestProto>,
    pub refundRequest: ::protobuf::SingularPtrField<RefundRequestProto>,
    pub purchaseMetadataRequest: ::protobuf::SingularPtrField<PurchaseMetadataRequestProto>,
    pub subCategoriesRequest: ::protobuf::SingularPtrField<GetSubCategoriesRequestProto>,
    pub uninstallReasonRequest: ::protobuf::SingularPtrField<UninstallReasonRequestProto>,
    pub rateCommentRequest: ::protobuf::SingularPtrField<RateCommentRequestProto>,
    pub checkLicenseRequest: ::protobuf::SingularPtrField<CheckLicenseRequestProto>,
    pub getMarketMetadataRequest: ::protobuf::SingularPtrField<GetMarketMetadataRequestProto>,
    pub getCategoriesRequest: ::protobuf::SingularPtrField<GetCategoriesRequestProto>,
    pub getCarrierInfoRequest: ::protobuf::SingularPtrField<GetCarrierInfoRequestProto>,
    pub removeAssetRequest: ::protobuf::SingularPtrField<RemoveAssetRequestProto>,
    pub restoreApplicationsRequest: ::protobuf::SingularPtrField<RestoreApplicationsRequestProto>,
    pub querySuggestionRequest: ::protobuf::SingularPtrField<QuerySuggestionRequestProto>,
    pub billingEventRequest: ::protobuf::SingularPtrField<BillingEventRequestProto>,
    pub paypalPreapprovalRequest: ::protobuf::SingularPtrField<PaypalPreapprovalRequestProto>,
    pub paypalPreapprovalDetailsRequest: ::protobuf::SingularPtrField<PaypalPreapprovalDetailsRequestProto>,
    pub paypalCreateAccountRequest: ::protobuf::SingularPtrField<PaypalCreateAccountRequestProto>,
    pub paypalPreapprovalCredentialsRequest: ::protobuf::SingularPtrField<PaypalPreapprovalCredentialsRequestProto>,
    pub inAppRestoreTransactionsRequest: ::protobuf::SingularPtrField<InAppRestoreTransactionsRequestProto>,
    pub getInAppPurchaseInformationRequest: ::protobuf::SingularPtrField<InAppPurchaseInformationRequestProto>,
    pub checkForNotificationsRequest: ::protobuf::SingularPtrField<CheckForNotificationsRequestProto>,
    pub ackNotificationsRequest: ::protobuf::SingularPtrField<AckNotificationsRequestProto>,
    pub purchaseProductRequest: ::protobuf::SingularPtrField<PurchaseProductRequestProto>,
    pub reconstructDatabaseRequest: ::protobuf::SingularPtrField<ReconstructDatabaseRequestProto>,
    pub paypalMassageAddressRequest: ::protobuf::SingularPtrField<PaypalMassageAddressRequestProto>,
    pub getAddressSnippetRequest: ::protobuf::SingularPtrField<GetAddressSnippetRequestProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SingleRequestProto {
    pub fn new() -> SingleRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SingleRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.requestSpecificProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commentsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyCommentRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchasePostRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseOrderRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentSyncRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAssetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getImageRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refundRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseMetadataRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subCategoriesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uninstallReasonRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateCommentRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkLicenseRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getMarketMetadataRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCategoriesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCarrierInfoRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.removeAssetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restoreApplicationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestionRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingEventRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalDetailsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCreateAccountRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalCredentialsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppRestoreTransactionsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getInAppPurchaseInformationRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkForNotificationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseProductRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reconstructDatabaseRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalMassageAddressRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAddressSnippetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into::<RequestSpecificPropertiesProto, _>(wire_type, is, &mut self.requestSpecificProperties)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<AssetsRequestProto, _>(wire_type, is, &mut self.assetRequest)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<CommentsRequestProto, _>(wire_type, is, &mut self.commentsRequest)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<ModifyCommentRequestProto, _>(wire_type, is, &mut self.modifyCommentRequest)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<PurchasePostRequestProto, _>(wire_type, is, &mut self.purchasePostRequest)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseOrderRequestProto, _>(wire_type, is, &mut self.purchaseOrderRequest)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<ContentSyncRequestProto, _>(wire_type, is, &mut self.contentSyncRequest)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<GetAssetRequestProto, _>(wire_type, is, &mut self.getAssetRequest)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<GetImageRequestProto, _>(wire_type, is, &mut self.getImageRequest)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<RefundRequestProto, _>(wire_type, is, &mut self.refundRequest)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseMetadataRequestProto, _>(wire_type, is, &mut self.purchaseMetadataRequest)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into::<GetSubCategoriesRequestProto, _>(wire_type, is, &mut self.subCategoriesRequest)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into::<UninstallReasonRequestProto, _>(wire_type, is, &mut self.uninstallReasonRequest)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<RateCommentRequestProto, _>(wire_type, is, &mut self.rateCommentRequest)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into::<CheckLicenseRequestProto, _>(wire_type, is, &mut self.checkLicenseRequest)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into::<GetMarketMetadataRequestProto, _>(wire_type, is, &mut self.getMarketMetadataRequest)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into::<GetCategoriesRequestProto, _>(wire_type, is, &mut self.getCategoriesRequest)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into::<GetCarrierInfoRequestProto, _>(wire_type, is, &mut self.getCarrierInfoRequest)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into::<RemoveAssetRequestProto, _>(wire_type, is, &mut self.removeAssetRequest)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into::<RestoreApplicationsRequestProto, _>(wire_type, is, &mut self.restoreApplicationsRequest)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into::<QuerySuggestionRequestProto, _>(wire_type, is, &mut self.querySuggestionRequest)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into::<BillingEventRequestProto, _>(wire_type, is, &mut self.billingEventRequest)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalRequestProto, _>(wire_type, is, &mut self.paypalPreapprovalRequest)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalDetailsRequestProto, _>(wire_type, is, &mut self.paypalPreapprovalDetailsRequest)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalCreateAccountRequestProto, _>(wire_type, is, &mut self.paypalCreateAccountRequest)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalCredentialsRequestProto, _>(wire_type, is, &mut self.paypalPreapprovalCredentialsRequest)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into::<InAppRestoreTransactionsRequestProto, _>(wire_type, is, &mut self.inAppRestoreTransactionsRequest)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into::<InAppPurchaseInformationRequestProto, _>(wire_type, is, &mut self.getInAppPurchaseInformationRequest)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into::<CheckForNotificationsRequestProto, _>(wire_type, is, &mut self.checkForNotificationsRequest)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into::<AckNotificationsRequestProto, _>(wire_type, is, &mut self.ackNotificationsRequest)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseProductRequestProto, _>(wire_type, is, &mut self.purchaseProductRequest)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into::<ReconstructDatabaseRequestProto, _>(wire_type, is, &mut self.reconstructDatabaseRequest)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalMassageAddressRequestProto, _>(wire_type, is, &mut self.paypalMassageAddressRequest)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into::<GetAddressSnippetRequestProto, _>(wire_type, is, &mut self.getAddressSnippetRequest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.requestSpecificProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.assetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.commentsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.modifyCommentRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchasePostRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseOrderRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.contentSyncRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getAssetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getImageRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.refundRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseMetadataRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.subCategoriesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.uninstallReasonRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rateCommentRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkLicenseRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getMarketMetadataRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getCategoriesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getCarrierInfoRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.removeAssetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.restoreApplicationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.querySuggestionRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.billingEventRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalDetailsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalCreateAccountRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalCredentialsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.inAppRestoreTransactionsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getInAppPurchaseInformationRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkForNotificationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ackNotificationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseProductRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reconstructDatabaseRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalMassageAddressRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getAddressSnippetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.requestSpecificProperties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.assetRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.commentsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.modifyCommentRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.purchasePostRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.purchaseOrderRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.contentSyncRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.getAssetRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.getImageRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.refundRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.purchaseMetadataRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.subCategoriesRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.uninstallReasonRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.rateCommentRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.checkLicenseRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.getMarketMetadataRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.getCategoriesRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.getCarrierInfoRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.removeAssetRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.restoreApplicationsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.querySuggestionRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.billingEventRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalDetailsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.paypalCreateAccountRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalCredentialsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.inAppRestoreTransactionsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.getInAppPurchaseInformationRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.checkForNotificationsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.ackNotificationsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.purchaseProductRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.reconstructDatabaseRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.paypalMassageAddressRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.getAddressSnippetRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleRequestProto {
        SingleRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestSpecificPropertiesProto>, _>(
                "requestSpecificProperties",
                |m: &SingleRequestProto| { &m.requestSpecificProperties },
                |m: &mut SingleRequestProto| { &mut m.requestSpecificProperties },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetsRequestProto>, _>(
                "assetRequest",
                |m: &SingleRequestProto| { &m.assetRequest },
                |m: &mut SingleRequestProto| { &mut m.assetRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentsRequestProto>, _>(
                "commentsRequest",
                |m: &SingleRequestProto| { &m.commentsRequest },
                |m: &mut SingleRequestProto| { &mut m.commentsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyCommentRequestProto>, _>(
                "modifyCommentRequest",
                |m: &SingleRequestProto| { &m.modifyCommentRequest },
                |m: &mut SingleRequestProto| { &mut m.modifyCommentRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchasePostRequestProto>, _>(
                "purchasePostRequest",
                |m: &SingleRequestProto| { &m.purchasePostRequest },
                |m: &mut SingleRequestProto| { &mut m.purchasePostRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseOrderRequestProto>, _>(
                "purchaseOrderRequest",
                |m: &SingleRequestProto| { &m.purchaseOrderRequest },
                |m: &mut SingleRequestProto| { &mut m.purchaseOrderRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentSyncRequestProto>, _>(
                "contentSyncRequest",
                |m: &SingleRequestProto| { &m.contentSyncRequest },
                |m: &mut SingleRequestProto| { &mut m.contentSyncRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetRequestProto>, _>(
                "getAssetRequest",
                |m: &SingleRequestProto| { &m.getAssetRequest },
                |m: &mut SingleRequestProto| { &mut m.getAssetRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetImageRequestProto>, _>(
                "getImageRequest",
                |m: &SingleRequestProto| { &m.getImageRequest },
                |m: &mut SingleRequestProto| { &mut m.getImageRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RefundRequestProto>, _>(
                "refundRequest",
                |m: &SingleRequestProto| { &m.refundRequest },
                |m: &mut SingleRequestProto| { &mut m.refundRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseMetadataRequestProto>, _>(
                "purchaseMetadataRequest",
                |m: &SingleRequestProto| { &m.purchaseMetadataRequest },
                |m: &mut SingleRequestProto| { &mut m.purchaseMetadataRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSubCategoriesRequestProto>, _>(
                "subCategoriesRequest",
                |m: &SingleRequestProto| { &m.subCategoriesRequest },
                |m: &mut SingleRequestProto| { &mut m.subCategoriesRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UninstallReasonRequestProto>, _>(
                "uninstallReasonRequest",
                |m: &SingleRequestProto| { &m.uninstallReasonRequest },
                |m: &mut SingleRequestProto| { &mut m.uninstallReasonRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateCommentRequestProto>, _>(
                "rateCommentRequest",
                |m: &SingleRequestProto| { &m.rateCommentRequest },
                |m: &mut SingleRequestProto| { &mut m.rateCommentRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckLicenseRequestProto>, _>(
                "checkLicenseRequest",
                |m: &SingleRequestProto| { &m.checkLicenseRequest },
                |m: &mut SingleRequestProto| { &mut m.checkLicenseRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetMarketMetadataRequestProto>, _>(
                "getMarketMetadataRequest",
                |m: &SingleRequestProto| { &m.getMarketMetadataRequest },
                |m: &mut SingleRequestProto| { &mut m.getMarketMetadataRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCategoriesRequestProto>, _>(
                "getCategoriesRequest",
                |m: &SingleRequestProto| { &m.getCategoriesRequest },
                |m: &mut SingleRequestProto| { &mut m.getCategoriesRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCarrierInfoRequestProto>, _>(
                "getCarrierInfoRequest",
                |m: &SingleRequestProto| { &m.getCarrierInfoRequest },
                |m: &mut SingleRequestProto| { &mut m.getCarrierInfoRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoveAssetRequestProto>, _>(
                "removeAssetRequest",
                |m: &SingleRequestProto| { &m.removeAssetRequest },
                |m: &mut SingleRequestProto| { &mut m.removeAssetRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreApplicationsRequestProto>, _>(
                "restoreApplicationsRequest",
                |m: &SingleRequestProto| { &m.restoreApplicationsRequest },
                |m: &mut SingleRequestProto| { &mut m.restoreApplicationsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionRequestProto>, _>(
                "querySuggestionRequest",
                |m: &SingleRequestProto| { &m.querySuggestionRequest },
                |m: &mut SingleRequestProto| { &mut m.querySuggestionRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingEventRequestProto>, _>(
                "billingEventRequest",
                |m: &SingleRequestProto| { &m.billingEventRequest },
                |m: &mut SingleRequestProto| { &mut m.billingEventRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalRequestProto>, _>(
                "paypalPreapprovalRequest",
                |m: &SingleRequestProto| { &m.paypalPreapprovalRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalPreapprovalRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalDetailsRequestProto>, _>(
                "paypalPreapprovalDetailsRequest",
                |m: &SingleRequestProto| { &m.paypalPreapprovalDetailsRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalPreapprovalDetailsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCreateAccountRequestProto>, _>(
                "paypalCreateAccountRequest",
                |m: &SingleRequestProto| { &m.paypalCreateAccountRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalCreateAccountRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalCredentialsRequestProto>, _>(
                "paypalPreapprovalCredentialsRequest",
                |m: &SingleRequestProto| { &m.paypalPreapprovalCredentialsRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalPreapprovalCredentialsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppRestoreTransactionsRequestProto>, _>(
                "inAppRestoreTransactionsRequest",
                |m: &SingleRequestProto| { &m.inAppRestoreTransactionsRequest },
                |m: &mut SingleRequestProto| { &mut m.inAppRestoreTransactionsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppPurchaseInformationRequestProto>, _>(
                "getInAppPurchaseInformationRequest",
                |m: &SingleRequestProto| { &m.getInAppPurchaseInformationRequest },
                |m: &mut SingleRequestProto| { &mut m.getInAppPurchaseInformationRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckForNotificationsRequestProto>, _>(
                "checkForNotificationsRequest",
                |m: &SingleRequestProto| { &m.checkForNotificationsRequest },
                |m: &mut SingleRequestProto| { &mut m.checkForNotificationsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationsRequestProto>, _>(
                "ackNotificationsRequest",
                |m: &SingleRequestProto| { &m.ackNotificationsRequest },
                |m: &mut SingleRequestProto| { &mut m.ackNotificationsRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseProductRequestProto>, _>(
                "purchaseProductRequest",
                |m: &SingleRequestProto| { &m.purchaseProductRequest },
                |m: &mut SingleRequestProto| { &mut m.purchaseProductRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconstructDatabaseRequestProto>, _>(
                "reconstructDatabaseRequest",
                |m: &SingleRequestProto| { &m.reconstructDatabaseRequest },
                |m: &mut SingleRequestProto| { &mut m.reconstructDatabaseRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalMassageAddressRequestProto>, _>(
                "paypalMassageAddressRequest",
                |m: &SingleRequestProto| { &m.paypalMassageAddressRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalMassageAddressRequest },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressSnippetRequestProto>, _>(
                "getAddressSnippetRequest",
                |m: &SingleRequestProto| { &m.getAddressSnippetRequest },
                |m: &mut SingleRequestProto| { &mut m.getAddressSnippetRequest },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SingleRequestProto>(
                "SingleRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleRequestProto {
        static instance: ::protobuf::rt::Lazy<SingleRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(SingleRequestProto::new)
    }
}

impl ::protobuf::Clear for SingleRequestProto {
    fn clear(&mut self) {
        self.requestSpecificProperties.clear();
        self.assetRequest.clear();
        self.commentsRequest.clear();
        self.modifyCommentRequest.clear();
        self.purchasePostRequest.clear();
        self.purchaseOrderRequest.clear();
        self.contentSyncRequest.clear();
        self.getAssetRequest.clear();
        self.getImageRequest.clear();
        self.refundRequest.clear();
        self.purchaseMetadataRequest.clear();
        self.subCategoriesRequest.clear();
        self.uninstallReasonRequest.clear();
        self.rateCommentRequest.clear();
        self.checkLicenseRequest.clear();
        self.getMarketMetadataRequest.clear();
        self.getCategoriesRequest.clear();
        self.getCarrierInfoRequest.clear();
        self.removeAssetRequest.clear();
        self.restoreApplicationsRequest.clear();
        self.querySuggestionRequest.clear();
        self.billingEventRequest.clear();
        self.paypalPreapprovalRequest.clear();
        self.paypalPreapprovalDetailsRequest.clear();
        self.paypalCreateAccountRequest.clear();
        self.paypalPreapprovalCredentialsRequest.clear();
        self.inAppRestoreTransactionsRequest.clear();
        self.getInAppPurchaseInformationRequest.clear();
        self.checkForNotificationsRequest.clear();
        self.ackNotificationsRequest.clear();
        self.purchaseProductRequest.clear();
        self.reconstructDatabaseRequest.clear();
        self.paypalMassageAddressRequest.clear();
        self.getAddressSnippetRequest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SingleResponseProto {
    // message fields
    pub responseProperties: ::protobuf::SingularPtrField<ResponsePropertiesProto>,
    pub assetsResponse: ::protobuf::SingularPtrField<AssetsResponseProto>,
    pub commentsResponse: ::protobuf::SingularPtrField<CommentsResponseProto>,
    pub modifyCommentResponse: ::protobuf::SingularPtrField<ModifyCommentResponseProto>,
    pub purchasePostResponse: ::protobuf::SingularPtrField<PurchasePostResponseProto>,
    pub purchaseOrderResponse: ::protobuf::SingularPtrField<PurchaseOrderResponseProto>,
    pub contentSyncResponse: ::protobuf::SingularPtrField<ContentSyncResponseProto>,
    pub getAssetResponse: ::protobuf::SingularPtrField<GetAssetResponseProto>,
    pub getImageResponse: ::protobuf::SingularPtrField<GetImageResponseProto>,
    pub refundResponse: ::protobuf::SingularPtrField<RefundResponseProto>,
    pub purchaseMetadataResponse: ::protobuf::SingularPtrField<PurchaseMetadataResponseProto>,
    pub subCategoriesResponse: ::protobuf::SingularPtrField<GetSubCategoriesResponseProto>,
    pub uninstallReasonResponse: ::protobuf::SingularPtrField<UninstallReasonResponseProto>,
    pub rateCommentResponse: ::protobuf::SingularPtrField<RateCommentResponseProto>,
    pub checkLicenseResponse: ::protobuf::SingularPtrField<CheckLicenseResponseProto>,
    pub getMarketMetadataResponse: ::protobuf::SingularPtrField<GetMarketMetadataResponseProto>,
    pub getCategoriesResponse: ::protobuf::SingularPtrField<GetCategoriesResponseProto>,
    pub getCarrierInfoResponse: ::protobuf::SingularPtrField<GetCarrierInfoResponseProto>,
    pub restoreApplicationResponse: ::protobuf::SingularPtrField<RestoreApplicationsResponseProto>,
    pub querySuggestionResponse: ::protobuf::SingularPtrField<QuerySuggestionResponseProto>,
    pub billingEventResponse: ::protobuf::SingularPtrField<BillingEventResponseProto>,
    pub paypalPreapprovalResponse: ::protobuf::SingularPtrField<PaypalPreapprovalResponseProto>,
    pub paypalPreapprovalDetailsResponse: ::protobuf::SingularPtrField<PaypalPreapprovalDetailsResponseProto>,
    pub paypalCreateAccountResponse: ::protobuf::SingularPtrField<PaypalCreateAccountResponseProto>,
    pub paypalPreapprovalCredentialsResponse: ::protobuf::SingularPtrField<PaypalPreapprovalCredentialsResponseProto>,
    pub inAppRestoreTransactionsResponse: ::protobuf::SingularPtrField<InAppRestoreTransactionsResponseProto>,
    pub getInAppPurchaseInformationResponse: ::protobuf::SingularPtrField<InAppPurchaseInformationResponseProto>,
    pub checkForNotificationsResponse: ::protobuf::SingularPtrField<CheckForNotificationsResponseProto>,
    pub ackNotificationsResponse: ::protobuf::SingularPtrField<AckNotificationsResponseProto>,
    pub purchaseProductResponse: ::protobuf::SingularPtrField<PurchaseProductResponseProto>,
    pub reconstructDatabaseResponse: ::protobuf::SingularPtrField<ReconstructDatabaseResponseProto>,
    pub paypalMassageAddressResponse: ::protobuf::SingularPtrField<PaypalMassageAddressResponseProto>,
    pub getAddressSnippetResponse: ::protobuf::SingularPtrField<GetAddressSnippetResponseProto>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl SingleResponseProto {
    pub fn new() -> SingleResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SingleResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.responseProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assetsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commentsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyCommentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchasePostResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseOrderResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentSyncResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAssetResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getImageResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refundResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subCategoriesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uninstallReasonResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateCommentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkLicenseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getMarketMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCategoriesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCarrierInfoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restoreApplicationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestionResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingEventResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalDetailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCreateAccountResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalCredentialsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppRestoreTransactionsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getInAppPurchaseInformationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkForNotificationsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseProductResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reconstructDatabaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalMassageAddressResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAddressSnippetResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into::<ResponsePropertiesProto, _>(wire_type, is, &mut self.responseProperties)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<AssetsResponseProto, _>(wire_type, is, &mut self.assetsResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<CommentsResponseProto, _>(wire_type, is, &mut self.commentsResponse)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<ModifyCommentResponseProto, _>(wire_type, is, &mut self.modifyCommentResponse)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<PurchasePostResponseProto, _>(wire_type, is, &mut self.purchasePostResponse)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseOrderResponseProto, _>(wire_type, is, &mut self.purchaseOrderResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into::<ContentSyncResponseProto, _>(wire_type, is, &mut self.contentSyncResponse)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<GetAssetResponseProto, _>(wire_type, is, &mut self.getAssetResponse)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into::<GetImageResponseProto, _>(wire_type, is, &mut self.getImageResponse)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into::<RefundResponseProto, _>(wire_type, is, &mut self.refundResponse)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseMetadataResponseProto, _>(wire_type, is, &mut self.purchaseMetadataResponse)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into::<GetSubCategoriesResponseProto, _>(wire_type, is, &mut self.subCategoriesResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into::<UninstallReasonResponseProto, _>(wire_type, is, &mut self.uninstallReasonResponse)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into::<RateCommentResponseProto, _>(wire_type, is, &mut self.rateCommentResponse)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into::<CheckLicenseResponseProto, _>(wire_type, is, &mut self.checkLicenseResponse)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into::<GetMarketMetadataResponseProto, _>(wire_type, is, &mut self.getMarketMetadataResponse)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into::<GetCategoriesResponseProto, _>(wire_type, is, &mut self.getCategoriesResponse)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into::<GetCarrierInfoResponseProto, _>(wire_type, is, &mut self.getCarrierInfoResponse)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into::<RestoreApplicationsResponseProto, _>(wire_type, is, &mut self.restoreApplicationResponse)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into::<QuerySuggestionResponseProto, _>(wire_type, is, &mut self.querySuggestionResponse)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into::<BillingEventResponseProto, _>(wire_type, is, &mut self.billingEventResponse)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalResponseProto, _>(wire_type, is, &mut self.paypalPreapprovalResponse)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalDetailsResponseProto, _>(wire_type, is, &mut self.paypalPreapprovalDetailsResponse)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalCreateAccountResponseProto, _>(wire_type, is, &mut self.paypalCreateAccountResponse)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalPreapprovalCredentialsResponseProto, _>(wire_type, is, &mut self.paypalPreapprovalCredentialsResponse)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into::<InAppRestoreTransactionsResponseProto, _>(wire_type, is, &mut self.inAppRestoreTransactionsResponse)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into::<InAppPurchaseInformationResponseProto, _>(wire_type, is, &mut self.getInAppPurchaseInformationResponse)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into::<CheckForNotificationsResponseProto, _>(wire_type, is, &mut self.checkForNotificationsResponse)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into::<AckNotificationsResponseProto, _>(wire_type, is, &mut self.ackNotificationsResponse)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into::<PurchaseProductResponseProto, _>(wire_type, is, &mut self.purchaseProductResponse)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into::<ReconstructDatabaseResponseProto, _>(wire_type, is, &mut self.reconstructDatabaseResponse)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into::<PaypalMassageAddressResponseProto, _>(wire_type, is, &mut self.paypalMassageAddressResponse)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into::<GetAddressSnippetResponseProto, _>(wire_type, is, &mut self.getAddressSnippetResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.responseProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.assetsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.commentsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.modifyCommentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchasePostResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseOrderResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.contentSyncResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getAssetResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getImageResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.refundResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.subCategoriesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.uninstallReasonResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rateCommentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkLicenseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getMarketMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getCategoriesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getCarrierInfoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.restoreApplicationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.querySuggestionResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.billingEventResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalDetailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalCreateAccountResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalPreapprovalCredentialsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.inAppRestoreTransactionsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getInAppPurchaseInformationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkForNotificationsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ackNotificationsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchaseProductResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reconstructDatabaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.paypalMassageAddressResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.getAddressSnippetResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.responseProperties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.assetsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.commentsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.modifyCommentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.purchasePostResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.purchaseOrderResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.contentSyncResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.getAssetResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.getImageResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.refundResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.purchaseMetadataResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.subCategoriesResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.uninstallReasonResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.rateCommentResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.checkLicenseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.getMarketMetadataResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.getCategoriesResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.getCarrierInfoResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.restoreApplicationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.querySuggestionResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.billingEventResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalDetailsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.paypalCreateAccountResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.paypalPreapprovalCredentialsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.inAppRestoreTransactionsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.getInAppPurchaseInformationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.checkForNotificationsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.ackNotificationsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.purchaseProductResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.reconstructDatabaseResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.paypalMassageAddressResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.getAddressSnippetResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleResponseProto {
        SingleResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponsePropertiesProto>, _>(
                "responseProperties",
                |m: &SingleResponseProto| { &m.responseProperties },
                |m: &mut SingleResponseProto| { &mut m.responseProperties },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetsResponseProto>, _>(
                "assetsResponse",
                |m: &SingleResponseProto| { &m.assetsResponse },
                |m: &mut SingleResponseProto| { &mut m.assetsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentsResponseProto>, _>(
                "commentsResponse",
                |m: &SingleResponseProto| { &m.commentsResponse },
                |m: &mut SingleResponseProto| { &mut m.commentsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyCommentResponseProto>, _>(
                "modifyCommentResponse",
                |m: &SingleResponseProto| { &m.modifyCommentResponse },
                |m: &mut SingleResponseProto| { &mut m.modifyCommentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchasePostResponseProto>, _>(
                "purchasePostResponse",
                |m: &SingleResponseProto| { &m.purchasePostResponse },
                |m: &mut SingleResponseProto| { &mut m.purchasePostResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseOrderResponseProto>, _>(
                "purchaseOrderResponse",
                |m: &SingleResponseProto| { &m.purchaseOrderResponse },
                |m: &mut SingleResponseProto| { &mut m.purchaseOrderResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentSyncResponseProto>, _>(
                "contentSyncResponse",
                |m: &SingleResponseProto| { &m.contentSyncResponse },
                |m: &mut SingleResponseProto| { &mut m.contentSyncResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetResponseProto>, _>(
                "getAssetResponse",
                |m: &SingleResponseProto| { &m.getAssetResponse },
                |m: &mut SingleResponseProto| { &mut m.getAssetResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetImageResponseProto>, _>(
                "getImageResponse",
                |m: &SingleResponseProto| { &m.getImageResponse },
                |m: &mut SingleResponseProto| { &mut m.getImageResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RefundResponseProto>, _>(
                "refundResponse",
                |m: &SingleResponseProto| { &m.refundResponse },
                |m: &mut SingleResponseProto| { &mut m.refundResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseMetadataResponseProto>, _>(
                "purchaseMetadataResponse",
                |m: &SingleResponseProto| { &m.purchaseMetadataResponse },
                |m: &mut SingleResponseProto| { &mut m.purchaseMetadataResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSubCategoriesResponseProto>, _>(
                "subCategoriesResponse",
                |m: &SingleResponseProto| { &m.subCategoriesResponse },
                |m: &mut SingleResponseProto| { &mut m.subCategoriesResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UninstallReasonResponseProto>, _>(
                "uninstallReasonResponse",
                |m: &SingleResponseProto| { &m.uninstallReasonResponse },
                |m: &mut SingleResponseProto| { &mut m.uninstallReasonResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateCommentResponseProto>, _>(
                "rateCommentResponse",
                |m: &SingleResponseProto| { &m.rateCommentResponse },
                |m: &mut SingleResponseProto| { &mut m.rateCommentResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckLicenseResponseProto>, _>(
                "checkLicenseResponse",
                |m: &SingleResponseProto| { &m.checkLicenseResponse },
                |m: &mut SingleResponseProto| { &mut m.checkLicenseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetMarketMetadataResponseProto>, _>(
                "getMarketMetadataResponse",
                |m: &SingleResponseProto| { &m.getMarketMetadataResponse },
                |m: &mut SingleResponseProto| { &mut m.getMarketMetadataResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCategoriesResponseProto>, _>(
                "getCategoriesResponse",
                |m: &SingleResponseProto| { &m.getCategoriesResponse },
                |m: &mut SingleResponseProto| { &mut m.getCategoriesResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCarrierInfoResponseProto>, _>(
                "getCarrierInfoResponse",
                |m: &SingleResponseProto| { &m.getCarrierInfoResponse },
                |m: &mut SingleResponseProto| { &mut m.getCarrierInfoResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreApplicationsResponseProto>, _>(
                "restoreApplicationResponse",
                |m: &SingleResponseProto| { &m.restoreApplicationResponse },
                |m: &mut SingleResponseProto| { &mut m.restoreApplicationResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionResponseProto>, _>(
                "querySuggestionResponse",
                |m: &SingleResponseProto| { &m.querySuggestionResponse },
                |m: &mut SingleResponseProto| { &mut m.querySuggestionResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingEventResponseProto>, _>(
                "billingEventResponse",
                |m: &SingleResponseProto| { &m.billingEventResponse },
                |m: &mut SingleResponseProto| { &mut m.billingEventResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalResponseProto>, _>(
                "paypalPreapprovalResponse",
                |m: &SingleResponseProto| { &m.paypalPreapprovalResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalPreapprovalResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalDetailsResponseProto>, _>(
                "paypalPreapprovalDetailsResponse",
                |m: &SingleResponseProto| { &m.paypalPreapprovalDetailsResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalPreapprovalDetailsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCreateAccountResponseProto>, _>(
                "paypalCreateAccountResponse",
                |m: &SingleResponseProto| { &m.paypalCreateAccountResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalCreateAccountResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalCredentialsResponseProto>, _>(
                "paypalPreapprovalCredentialsResponse",
                |m: &SingleResponseProto| { &m.paypalPreapprovalCredentialsResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalPreapprovalCredentialsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppRestoreTransactionsResponseProto>, _>(
                "inAppRestoreTransactionsResponse",
                |m: &SingleResponseProto| { &m.inAppRestoreTransactionsResponse },
                |m: &mut SingleResponseProto| { &mut m.inAppRestoreTransactionsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppPurchaseInformationResponseProto>, _>(
                "getInAppPurchaseInformationResponse",
                |m: &SingleResponseProto| { &m.getInAppPurchaseInformationResponse },
                |m: &mut SingleResponseProto| { &mut m.getInAppPurchaseInformationResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckForNotificationsResponseProto>, _>(
                "checkForNotificationsResponse",
                |m: &SingleResponseProto| { &m.checkForNotificationsResponse },
                |m: &mut SingleResponseProto| { &mut m.checkForNotificationsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationsResponseProto>, _>(
                "ackNotificationsResponse",
                |m: &SingleResponseProto| { &m.ackNotificationsResponse },
                |m: &mut SingleResponseProto| { &mut m.ackNotificationsResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseProductResponseProto>, _>(
                "purchaseProductResponse",
                |m: &SingleResponseProto| { &m.purchaseProductResponse },
                |m: &mut SingleResponseProto| { &mut m.purchaseProductResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconstructDatabaseResponseProto>, _>(
                "reconstructDatabaseResponse",
                |m: &SingleResponseProto| { &m.reconstructDatabaseResponse },
                |m: &mut SingleResponseProto| { &mut m.reconstructDatabaseResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalMassageAddressResponseProto>, _>(
                "paypalMassageAddressResponse",
                |m: &SingleResponseProto| { &m.paypalMassageAddressResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalMassageAddressResponse },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressSnippetResponseProto>, _>(
                "getAddressSnippetResponse",
                |m: &SingleResponseProto| { &m.getAddressSnippetResponse },
                |m: &mut SingleResponseProto| { &mut m.getAddressSnippetResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<SingleResponseProto>(
                "SingleResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleResponseProto {
        static instance: ::protobuf::rt::Lazy<SingleResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(SingleResponseProto::new)
    }
}

impl ::protobuf::Clear for SingleResponseProto {
    fn clear(&mut self) {
        self.responseProperties.clear();
        self.assetsResponse.clear();
        self.commentsResponse.clear();
        self.modifyCommentResponse.clear();
        self.purchasePostResponse.clear();
        self.purchaseOrderResponse.clear();
        self.contentSyncResponse.clear();
        self.getAssetResponse.clear();
        self.getImageResponse.clear();
        self.refundResponse.clear();
        self.purchaseMetadataResponse.clear();
        self.subCategoriesResponse.clear();
        self.uninstallReasonResponse.clear();
        self.rateCommentResponse.clear();
        self.checkLicenseResponse.clear();
        self.getMarketMetadataResponse.clear();
        self.getCategoriesResponse.clear();
        self.getCarrierInfoResponse.clear();
        self.restoreApplicationResponse.clear();
        self.querySuggestionResponse.clear();
        self.billingEventResponse.clear();
        self.paypalPreapprovalResponse.clear();
        self.paypalPreapprovalDetailsResponse.clear();
        self.paypalCreateAccountResponse.clear();
        self.paypalPreapprovalCredentialsResponse.clear();
        self.inAppRestoreTransactionsResponse.clear();
        self.getInAppPurchaseInformationResponse.clear();
        self.checkForNotificationsResponse.clear();
        self.ackNotificationsResponse.clear();
        self.purchaseProductResponse.clear();
        self.reconstructDatabaseResponse.clear();
        self.paypalMassageAddressResponse.clear();
        self.getAddressSnippetResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct StatusBarNotificationProto {
    // message fields
    pub tickerText: ::protobuf::SingularField<::std::string::String>,
    pub contentTitle: ::protobuf::SingularField<::std::string::String>,
    pub contentText: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl StatusBarNotificationProto {
    pub fn new() -> StatusBarNotificationProto {
        ::std::default::Default::default()
    }

    // optional string tickerText = 1;

    pub fn get_tickerText(&self) -> &str {
        match self.tickerText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string contentTitle = 2;

    pub fn get_contentTitle(&self) -> &str {
        match self.contentTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional string contentText = 3;

    pub fn get_contentText(&self) -> &str {
        match self.contentText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for StatusBarNotificationProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tickerText)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentTitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentText)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tickerText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.contentTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.contentText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tickerText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.contentTitle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.contentText.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusBarNotificationProto {
        StatusBarNotificationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "tickerText",
                |m: &StatusBarNotificationProto| { &m.tickerText },
                |m: &mut StatusBarNotificationProto| { &mut m.tickerText },
                StatusBarNotificationProto::get_tickerText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contentTitle",
                |m: &StatusBarNotificationProto| { &m.contentTitle },
                |m: &mut StatusBarNotificationProto| { &mut m.contentTitle },
                StatusBarNotificationProto::get_contentTitle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "contentText",
                |m: &StatusBarNotificationProto| { &m.contentText },
                |m: &mut StatusBarNotificationProto| { &mut m.contentText },
                StatusBarNotificationProto::get_contentText,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<StatusBarNotificationProto>(
                "StatusBarNotificationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusBarNotificationProto {
        static instance: ::protobuf::rt::Lazy<StatusBarNotificationProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(StatusBarNotificationProto::new)
    }
}

impl ::protobuf::Clear for StatusBarNotificationProto {
    fn clear(&mut self) {
        self.tickerText.clear();
        self.contentTitle.clear();
        self.contentText.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusBarNotificationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusBarNotificationProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UninstallReasonRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub reason: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UninstallReasonRequestProto {
    pub fn new() -> UninstallReasonRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;

    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional int32 reason = 2;

    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }
}

impl ::protobuf::Message for UninstallReasonRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UninstallReasonRequestProto {
        UninstallReasonRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "assetId",
                |m: &UninstallReasonRequestProto| { &m.assetId },
                |m: &mut UninstallReasonRequestProto| { &mut m.assetId },
                UninstallReasonRequestProto::get_assetId,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeInt32, _>(
                "reason",
                |m: &UninstallReasonRequestProto| { &m.reason },
                |m: &mut UninstallReasonRequestProto| { &mut m.reason },
                UninstallReasonRequestProto::get_reason,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<UninstallReasonRequestProto>(
                "UninstallReasonRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UninstallReasonRequestProto {
        static instance: ::protobuf::rt::Lazy<UninstallReasonRequestProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(UninstallReasonRequestProto::new)
    }
}

impl ::protobuf::Clear for UninstallReasonRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UninstallReasonRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UninstallReasonRequestProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct UninstallReasonResponseProto {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl UninstallReasonResponseProto {
    pub fn new() -> UninstallReasonResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UninstallReasonResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UninstallReasonResponseProto {
        UninstallReasonResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<UninstallReasonResponseProto>(
                "UninstallReasonResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UninstallReasonResponseProto {
        static instance: ::protobuf::rt::Lazy<UninstallReasonResponseProto> = ::protobuf::rt::Lazy::INIT;
        instance.get(UninstallReasonResponseProto::new)
    }
}

impl ::protobuf::Clear for UninstallReasonResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UninstallReasonResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UninstallReasonResponseProto {
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct CriticReviewsResponse {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub aggregateSentiment: ::protobuf::SingularPtrField<Image>,
    pub totalNumReviews: ::std::option::Option<u32>,
    pub percentFavorable: ::std::option::Option<u32>,
    pub sourceText: ::protobuf::SingularField<::std::string::String>,
    pub source: ::protobuf::SingularPtrField<Link>,
    pub review: ::protobuf::RepeatedField<Review>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl CriticReviewsResponse {
    pub fn new() -> CriticReviewsResponse {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    // optional uint32 totalNumReviews = 3;

    pub fn get_totalNumReviews(&self) -> u32 {
        self.totalNumReviews.unwrap_or(0)
    }

    // optional uint32 percentFavorable = 4;

    pub fn get_percentFavorable(&self) -> u32 {
        self.percentFavorable.unwrap_or(0)
    }

    // optional string sourceText = 5;

    pub fn get_sourceText(&self) -> &str {
        match self.sourceText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CriticReviewsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregateSentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.review {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<Image, _>(wire_type, is, &mut self.aggregateSentiment)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.totalNumReviews = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.percentFavorable = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceText)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<Link, _>(wire_type, is, &mut self.source)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.review)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.aggregateSentiment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.totalNumReviews {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.percentFavorable {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sourceText.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.review {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.aggregateSentiment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.totalNumReviews {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.percentFavorable {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sourceText.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.review {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CriticReviewsResponse {
        CriticReviewsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "title",
                |m: &CriticReviewsResponse| { &m.title },
                |m: &mut CriticReviewsResponse| { &mut m.title },
                CriticReviewsResponse::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>, _>(
                "aggregateSentiment",
                |m: &CriticReviewsResponse| { &m.aggregateSentiment },
                |m: &mut CriticReviewsResponse| { &mut m.aggregateSentiment },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint32, _>(
                "totalNumReviews",
                |m: &CriticReviewsResponse| { &m.totalNumReviews },
                |m: &mut CriticReviewsResponse| { &mut m.totalNumReviews },
                CriticReviewsResponse::get_totalNumReviews,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::types::ProtobufTypeUint32, _>(
                "percentFavorable",
                |m: &CriticReviewsResponse| { &m.percentFavorable },
                |m: &mut CriticReviewsResponse| { &mut m.percentFavorable },
                CriticReviewsResponse::get_percentFavorable,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::types::ProtobufTypeString, _>(
                "sourceText",
                |m: &CriticReviewsResponse| { &m.sourceText },
                |m: &mut CriticReviewsResponse| { &mut m.sourceText },
                CriticReviewsResponse::get_sourceText,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Link>, _>(
                "source",
                |m: &CriticReviewsResponse| { &m.source },
                |m: &mut CriticReviewsResponse| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "review",
                |m: &CriticReviewsResponse| { &m.review },
                |m: &mut CriticReviewsResponse| { &mut m.review },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CriticReviewsResponse>(
                "CriticReviewsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CriticReviewsResponse {
        static instance: ::protobuf::rt::Lazy<CriticReviewsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CriticReviewsResponse::new)
    }
}

impl ::protobuf::Clear for CriticReviewsResponse {
    fn clear(&mut self) {
        self.title.clear();
        self.aggregateSentiment.clear();
        self.totalNumReviews = ::std::option::Option::None;
        self.percentFavorable = ::std::option::Option::None;
        self.sourceText.clear();
        self.source.clear();
        self.review.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CriticReviewsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CriticReviewsResponse {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10googleplay.proto\"\x19\n\x17AckNotificationResponse\"\xa4\x06\n\
    \x16AndroidAppDeliveryData\x12\"\n\x0cdownloadSize\x18\x01\x20\x01(\x03R\
    \x0cdownloadSize\x12\x1c\n\tsignature\x18\x02\x20\x01(\tR\tsignature\x12\
    \x20\n\x0bdownloadUrl\x18\x03\x20\x01(\tR\x0bdownloadUrl\x128\n\x0eaddit\
    ionalFile\x18\x04\x20\x03(\x0b2\x10.AppFileMetadataR\x0eadditionalFile\
    \x12;\n\x12downloadAuthCookie\x18\x05\x20\x03(\x0b2\x0b.HttpCookieR\x12d\
    ownloadAuthCookie\x12$\n\rforwardLocked\x18\x06\x20\x01(\x08R\rforwardLo\
    cked\x12$\n\rrefundTimeout\x18\x07\x20\x01(\x03R\rrefundTimeout\x12(\n\
    \x0fserverInitiated\x18\x08\x20\x01(\x08R\x0fserverInitiated\x12D\n\x1dp\
    ostInstallRefundWindowMillis\x18\t\x20\x01(\x03R\x1dpostInstallRefundWin\
    dowMillis\x122\n\x14immediateStartNeeded\x18\n\x20\x01(\x08R\x14immediat\
    eStartNeeded\x122\n\tpatchData\x18\x0b\x20\x01(\x0b2\x14.AndroidAppPatch\
    DataR\tpatchData\x12=\n\x10encryptionParams\x18\x0c\x20\x01(\x0b2\x11.En\
    cryptionParamsR\x10encryptionParams\x12.\n\x12gzippedDownloadUrl\x18\r\
    \x20\x01(\tR\x12gzippedDownloadUrl\x120\n\x13gzippedDownloadSize\x18\x0e\
    \x20\x01(\x03R\x13gzippedDownloadSize\x12@\n\x11splitDeliveryData\x18\
    \x0f\x20\x03(\x0b2\x12.SplitDeliveryDataR\x11splitDeliveryData\x12(\n\
    \x0finstallLocation\x18\x10\x20\x01(\x05R\x0finstallLocation\"\x9d\x02\n\
    \x11SplitDeliveryData\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\"\n\
    \x0cdownloadSize\x18\x02\x20\x01(\x03R\x0cdownloadSize\x120\n\x13gzipped\
    DownloadSize\x18\x03\x20\x01(\x03R\x13gzippedDownloadSize\x12\x1c\n\tsig\
    nature\x18\x04\x20\x01(\tR\tsignature\x12\x20\n\x0bdownloadUrl\x18\x05\
    \x20\x01(\tR\x0bdownloadUrl\x12.\n\x12gzippedDownloadUrl\x18\x06\x20\x01\
    (\tR\x12gzippedDownloadUrl\x122\n\tpatchData\x18\x07\x20\x01(\x0b2\x14.A\
    ndroidAppPatchDataR\tpatchData\"\xcd\x01\n\x13AndroidAppPatchData\x12(\n\
    \x0fbaseVersionCode\x18\x01\x20\x01(\x05R\x0fbaseVersionCode\x12$\n\rbas\
    eSignature\x18\x02\x20\x01(\tR\rbaseSignature\x12\x20\n\x0bdownloadUrl\
    \x18\x03\x20\x01(\tR\x0bdownloadUrl\x12\x20\n\x0bpatchFormat\x18\x04\x20\
    \x01(\x05R\x0bpatchFormat\x12\"\n\x0cmaxPatchSize\x18\x05\x20\x01(\x03R\
    \x0cmaxPatchSize\"\x85\x01\n\x0fAppFileMetadata\x12\x1a\n\x08fileType\
    \x18\x01\x20\x01(\x05R\x08fileType\x12\x20\n\x0bversionCode\x18\x02\x20\
    \x01(\x05R\x0bversionCode\x12\x12\n\x04size\x18\x03\x20\x01(\x03R\x04siz\
    e\x12\x20\n\x0bdownloadUrl\x18\x04\x20\x01(\tR\x0bdownloadUrl\"l\n\x10En\
    cryptionParams\x12\x18\n\x07version\x18\x01\x20\x01(\x05R\x07version\x12\
    $\n\rencryptionKey\x18\x02\x20\x01(\tR\rencryptionKey\x12\x18\n\x07hmacK\
    ey\x18\x03\x20\x01(\tR\x07hmacKey\"6\n\nHttpCookie\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \"\xed\x03\n\x07Address\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\"\n\x0caddressLine1\x18\x02\x20\x01(\tR\x0caddressLine1\x12\"\n\x0c\
    addressLine2\x18\x03\x20\x01(\tR\x0caddressLine2\x12\x12\n\x04city\x18\
    \x04\x20\x01(\tR\x04city\x12\x14\n\x05state\x18\x05\x20\x01(\tR\x05state\
    \x12\x1e\n\npostalCode\x18\x06\x20\x01(\tR\npostalCode\x12$\n\rpostalCou\
    ntry\x18\x07\x20\x01(\tR\rpostalCountry\x12,\n\x11dependentLocality\x18\
    \x08\x20\x01(\tR\x11dependentLocality\x12\x20\n\x0bsortingCode\x18\t\x20\
    \x01(\tR\x0bsortingCode\x12\"\n\x0clanguageCode\x18\n\x20\x01(\tR\x0clan\
    guageCode\x12\x20\n\x0bphoneNumber\x18\x0b\x20\x01(\tR\x0bphoneNumber\
    \x120\n\x13deprecatedIsReduced\x18\x0c\x20\x01(\x08R\x13deprecatedIsRedu\
    ced\x12\x1c\n\tfirstName\x18\r\x20\x01(\tR\tfirstName\x12\x1a\n\x08lastN\
    ame\x18\x0e\x20\x01(\tR\x08lastName\x12\x14\n\x05email\x18\x0f\x20\x01(\
    \tR\x05email\"h\n\nBookAuthor\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x12(\n\x0fdeprecatedQuery\x18\x02\x20\x01(\tR\x0fdeprecatedQuery\x12\
    \x1c\n\x05docid\x18\x03\x20\x01(\x0b2\x06.DocidR\x05docid\"\xa9\x06\n\
    \x0bBookDetails\x12&\n\x07subject\x18\x03\x20\x03(\x0b2\x0c.BookSubjectR\
    \x07subject\x12\x1c\n\tpublisher\x18\x04\x20\x01(\tR\tpublisher\x12(\n\
    \x0fpublicationDate\x18\x05\x20\x01(\tR\x0fpublicationDate\x12\x12\n\x04\
    isbn\x18\x06\x20\x01(\tR\x04isbn\x12$\n\rnumberOfPages\x18\x07\x20\x01(\
    \x05R\rnumberOfPages\x12\x1a\n\x08subtitle\x18\x08\x20\x01(\tR\x08subtit\
    le\x12#\n\x06author\x18\t\x20\x03(\x0b2\x0b.BookAuthorR\x06author\x12\
    \x1c\n\treaderUrl\x18\n\x20\x01(\tR\treaderUrl\x12(\n\x0fdownloadEpubUrl\
    \x18\x0b\x20\x01(\tR\x0fdownloadEpubUrl\x12&\n\x0edownloadPdfUrl\x18\x0c\
    \x20\x01(\tR\x0edownloadPdfUrl\x12(\n\x0facsEpubTokenUrl\x18\r\x20\x01(\
    \tR\x0facsEpubTokenUrl\x12&\n\x0eacsPdfTokenUrl\x18\x0e\x20\x01(\tR\x0ea\
    csPdfTokenUrl\x12$\n\repubAvailable\x18\x0f\x20\x01(\x08R\repubAvailable\
    \x12\"\n\x0cpdfAvailable\x18\x10\x20\x01(\x08R\x0cpdfAvailable\x12&\n\
    \x0eaboutTheAuthor\x18\x11\x20\x01(\tR\x0eaboutTheAuthor\x127\n\nidentif\
    ier\x18\x12\x20\x03(\n2\x17.BookDetails.IdentifierR\nidentifier\x12.\n\
    \x12fixedLayoutContent\x18\x15\x20\x01(\x08R\x12fixedLayoutContent\x12,\
    \n\x11audioVideoContent\x18\x16\x20\x01(\x08R\x11audioVideoContent\x12\"\
    \n\x0cisAgencyBook\x18\x17\x20\x01(\x08R\x0cisAgencyBook\x1a@\n\nIdentif\
    ier\x12\x12\n\x04type\x18\x13\x20\x01(\x05R\x04type\x12\x1e\n\nidentifie\
    r\x18\x14\x20\x01(\tR\nidentifier\"U\n\x0bBookSubject\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05query\x18\x02\x20\x01(\tR\x05q\
    uery\x12\x1c\n\tsubjectId\x18\x03\x20\x01(\tR\tsubjectId\"f\n\nBrowseLin\
    k\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07dataUrl\x18\
    \x03\x20\x01(\tR\x07dataUrl\x12*\n\x10serverLogsCookie\x18\x04\x20\x01(\
    \x0cR\x10serverLogsCookie\"\xfa\x01\n\x0eBrowseResponse\x12\x20\n\x0bcon\
    tentsUrl\x18\x01\x20\x01(\tR\x0bcontentsUrl\x12\x1a\n\x08promoUrl\x18\
    \x02\x20\x01(\tR\x08promoUrl\x12'\n\x08category\x18\x03\x20\x03(\x0b2\
    \x0b.BrowseLinkR\x08category\x12+\n\nbreadcrumb\x18\x04\x20\x03(\x0b2\
    \x0b.BrowseLinkR\nbreadcrumb\x12(\n\tquickLink\x18\x05\x20\x03(\x0b2\n.Q\
    uickLinkR\tquickLink\x12*\n\x10serverLogsCookie\x18\x06\x20\x01(\x0cR\
    \x10serverLogsCookie\"\xf4\x01\n\tQuickLink\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x1c\n\x05image\x18\x02\x20\x01(\x0b2\x06.ImageR\
    \x05image\x12!\n\x04link\x18\x03\x20\x01(\x0b2\r.ResolvedLinkR\x04link\
    \x12(\n\x0fdisplayRequired\x18\x04\x20\x01(\x08R\x0fdisplayRequired\x12*\
    \n\x10serverLogsCookie\x18\x05\x20\x01(\x0cR\x10serverLogsCookie\x12\x1c\
    \n\tbackendId\x18\x06\x20\x01(\x05R\tbackendId\x12\x1e\n\nprismStyle\x18\
    \x07\x20\x01(\x08R\nprismStyle\"\xb2\x0f\n\x0bBuyResponse\x12I\n\x10purc\
    haseResponse\x18\x01\x20\x01(\x0b2\x1d.PurchaseNotificationResponseR\x10\
    purchaseResponse\x12=\n\x0ccheckoutinfo\x18\x02\x20\x01(\n2\x19.BuyRespo\
    nse.CheckoutInfoR\x0ccheckoutinfo\x12&\n\x0econtinueViaUrl\x18\x08\x20\
    \x01(\tR\x0econtinueViaUrl\x12,\n\x11purchaseStatusUrl\x18\t\x20\x01(\tR\
    \x11purchaseStatusUrl\x12,\n\x11checkoutServiceId\x18\x0c\x20\x01(\tR\
    \x11checkoutServiceId\x124\n\x15checkoutTokenRequired\x18\r\x20\x01(\x08\
    R\x15checkoutTokenRequired\x12(\n\x0fbaseCheckoutUrl\x18\x0e\x20\x01(\tR\
    \x0fbaseCheckoutUrl\x12(\n\x0ftosCheckboxHtml\x18%\x20\x03(\tR\x0ftosChe\
    ckboxHtml\x12(\n\x0fpermissionError\x18&\x20\x01(\x05R\x0fpermissionErro\
    r\x12O\n\x16purchaseStatusResponse\x18'\x20\x01(\x0b2\x17.PurchaseStatus\
    ResponseR\x16purchaseStatusResponse\x12&\n\x0epurchaseCookie\x18.\x20\
    \x01(\tR\x0epurchaseCookie\x12(\n\tchallenge\x181\x20\x01(\x0b2\n.Challe\
    ngeR\tchallenge\x128\n\x17addInstrumentPromptHtml\x182\x20\x01(\tR\x17ad\
    dInstrumentPromptHtml\x12,\n\x11confirmButtonText\x183\x20\x01(\tR\x11co\
    nfirmButtonText\x12:\n\x18permissionErrorTitleText\x184\x20\x01(\tR\x18p\
    ermissionErrorTitleText\x12>\n\x1apermissionErrorMessageText\x185\x20\
    \x01(\tR\x1apermissionErrorMessageText\x12*\n\x10serverLogsCookie\x186\
    \x20\x01(\x0cR\x10serverLogsCookie\x122\n\x14encodedDeliveryToken\x187\
    \x20\x01(\tR\x14encodedDeliveryToken\x1a\xf9\x07\n\x0cCheckoutInfo\x12\
    \x1d\n\x04item\x18\x03\x20\x01(\x0b2\t.LineItemR\x04item\x12#\n\x07subIt\
    em\x18\x04\x20\x03(\x0b2\t.LineItemR\x07subItem\x12P\n\x0echeckoutoption\
    \x18\x05\x20\x03(\n2(.BuyResponse.CheckoutInfo.CheckoutOptionR\x0echecko\
    utoption\x124\n\x15deprecatedCheckoutUrl\x18\n\x20\x01(\tR\x15deprecated\
    CheckoutUrl\x12*\n\x10addInstrumentUrl\x18\x0b\x20\x01(\tR\x10addInstrum\
    entUrl\x12\x1e\n\nfooterHtml\x18\x14\x20\x03(\tR\nfooterHtml\x12:\n\x18e\
    ligibleInstrumentFamily\x18\x1f\x20\x03(\x05R\x18eligibleInstrumentFamil\
    y\x12\"\n\x0cfootnoteHtml\x18$\x20\x03(\tR\x0cfootnoteHtml\x12;\n\x12eli\
    gibleInstrument\x18,\x20\x03(\x0b2\x0b.InstrumentR\x12eligibleInstrument\
    \x1a\xb3\x04\n\x0eCheckoutOption\x12$\n\rformOfPayment\x18\x06\x20\x01(\
    \tR\rformOfPayment\x120\n\x13encodedAdjustedCart\x18\x07\x20\x01(\tR\x13\
    encodedAdjustedCart\x12\"\n\x0cinstrumentId\x18\x0f\x20\x01(\tR\x0cinstr\
    umentId\x12\x1d\n\x04item\x18\x10\x20\x03(\x0b2\t.LineItemR\x04item\x12#\
    \n\x07subItem\x18\x11\x20\x03(\x0b2\t.LineItemR\x07subItem\x12\x1f\n\x05\
    total\x18\x12\x20\x01(\x0b2\t.LineItemR\x05total\x12\x1e\n\nfooterHtml\
    \x18\x13\x20\x03(\tR\nfooterHtml\x12*\n\x10instrumentFamily\x18\x1d\x20\
    \x01(\x05R\x10instrumentFamily\x12.\n\x12selectedInstrument\x18\x20\x20\
    \x01(\x08R\x12selectedInstrument\x12#\n\x07summary\x18!\x20\x01(\x0b2\t.\
    LineItemR\x07summary\x12\"\n\x0cfootnoteHtml\x18#\x20\x03(\tR\x0cfootnot\
    eHtml\x12+\n\ninstrument\x18+\x20\x01(\x0b2\x0b.InstrumentR\ninstrument\
    \x12&\n\x0epurchaseCookie\x18-\x20\x01(\tR\x0epurchaseCookie\x12&\n\x0ed\
    isabledReason\x180\x20\x03(\tR\x0edisabledReason\"~\n\x08LineItem\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\
    \x02\x20\x01(\tR\x0bdescription\x12\x1c\n\x05offer\x18\x03\x20\x01(\x0b2\
    \x06.OfferR\x05offer\x12\x1e\n\x06amount\x18\x04\x20\x01(\x0b2\x06.Money\
    R\x06amount\"m\n\x05Money\x12\x16\n\x06micros\x18\x01\x20\x01(\x03R\x06m\
    icros\x12\"\n\x0ccurrencyCode\x18\x02\x20\x01(\tR\x0ccurrencyCode\x12(\n\
    \x0fformattedAmount\x18\x03\x20\x01(\tR\x0fformattedAmount\"\xb6\x01\n\
    \x1cPurchaseNotificationResponse\x12\x16\n\x06status\x18\x01\x20\x01(\
    \x05R\x06status\x12(\n\tdebugInfo\x18\x02\x20\x01(\x0b2\n.DebugInfoR\tde\
    bugInfo\x124\n\x15localizedErrorMessage\x18\x03\x20\x01(\tR\x15localized\
    ErrorMessage\x12\x1e\n\npurchaseId\x18\x04\x20\x01(\tR\npurchaseId\"\xe4\
    \x02\n\x16PurchaseStatusResponse\x12\x16\n\x06status\x18\x01\x20\x01(\
    \x05R\x06status\x12\x1c\n\tstatusMsg\x18\x02\x20\x01(\tR\tstatusMsg\x12\
    \x20\n\x0bstatusTitle\x18\x03\x20\x01(\tR\x0bstatusTitle\x12\"\n\x0cbrie\
    fMessage\x18\x04\x20\x01(\tR\x0cbriefMessage\x12\x18\n\x07infoUrl\x18\
    \x05\x20\x01(\tR\x07infoUrl\x124\n\rlibraryUpdate\x18\x06\x20\x01(\x0b2\
    \x0e.LibraryUpdateR\rlibraryUpdate\x12;\n\x12rejectedInstrument\x18\x07\
    \x20\x01(\x0b2\x0b.InstrumentR\x12rejectedInstrument\x12A\n\x0fappDelive\
    ryData\x18\x08\x20\x01(\x0b2\x17.AndroidAppDeliveryDataR\x0fappDeliveryD\
    ata\"\x93\x01\n\x16BillingProfileResponse\x12\x16\n\x06result\x18\x01\
    \x20\x01(\x05R\x06result\x127\n\x0ebillingProfile\x18\x02\x20\x01(\x0b2\
    \x0f.BillingProfileR\x0ebillingProfile\x12(\n\x0fuserMessageHtml\x18\x03\
    \x20\x01(\tR\x0fuserMessageHtml\"\xf1\x01\n\x17CheckInstrumentResponse\
    \x126\n\x16userHasValidInstrument\x18\x01\x20\x01(\x08R\x16userHasValidI\
    nstrument\x124\n\x15checkoutTokenRequired\x18\x02\x20\x01(\x08R\x15check\
    outTokenRequired\x12+\n\ninstrument\x18\x04\x20\x03(\x0b2\x0b.Instrument\
    R\ninstrument\x12;\n\x12eligibleInstrument\x18\x05\x20\x03(\x0b2\x0b.Ins\
    trumentR\x12eligibleInstrument\"\x87\x01\n\x1bInstrumentSetupInfoRespons\
    e\x122\n\tsetupInfo\x18\x01\x20\x03(\x0b2\x14.InstrumentSetupInfoR\tsetu\
    pInfo\x124\n\x15checkoutTokenRequired\x18\x02\x20\x01(\x08R\x15checkoutT\
    okenRequired\"\xbd\x01\n\x15RedeemGiftCardRequest\x12\x20\n\x0bgiftCardP\
    in\x18\x01\x20\x01(\tR\x0bgiftCardPin\x12\"\n\x07address\x18\x02\x20\x01\
    (\x0b2\x08.AddressR\x07address\x128\n\x17acceptedLegalDocumentId\x18\x03\
    \x20\x03(\tR\x17acceptedLegalDocumentId\x12$\n\rcheckoutToken\x18\x04\
    \x20\x01(\tR\rcheckoutToken\"\xf1\x01\n\x16RedeemGiftCardResponse\x12\
    \x16\n\x06result\x18\x01\x20\x01(\x05R\x06result\x12(\n\x0fuserMessageHt\
    ml\x18\x02\x20\x01(\tR\x0fuserMessageHtml\x12\x20\n\x0bbalanceHtml\x18\
    \x03\x20\x01(\tR\x0bbalanceHtml\x12=\n\x10addressChallenge\x18\x04\x20\
    \x01(\x0b2\x11.AddressChallengeR\x10addressChallenge\x124\n\x15checkoutT\
    okenRequired\x18\x05\x20\x01(\x08R\x15checkoutTokenRequired\"l\n\x17Upda\
    teInstrumentRequest\x12+\n\ninstrument\x18\x01\x20\x01(\x0b2\x0b.Instrum\
    entR\ninstrument\x12$\n\rcheckoutToken\x18\x02\x20\x01(\tR\rcheckoutToke\
    n\"\xb2\x02\n\x18UpdateInstrumentResponse\x12\x16\n\x06result\x18\x01\
    \x20\x01(\x05R\x06result\x12\"\n\x0cinstrumentId\x18\x02\x20\x01(\tR\x0c\
    instrumentId\x12(\n\x0fuserMessageHtml\x18\x03\x20\x01(\tR\x0fuserMessag\
    eHtml\x12?\n\x0ferrorInputField\x18\x04\x20\x03(\x0b2\x15.InputValidatio\
    nErrorR\x0ferrorInputField\x124\n\x15checkoutTokenRequired\x18\x05\x20\
    \x01(\x08R\x15checkoutTokenRequired\x129\n\rredeemedOffer\x18\x06\x20\
    \x01(\x0b2\x13.RedeemedPromoOfferR\rredeemedOffer\";\n\x1bInitiateAssoci\
    ationResponse\x12\x1c\n\tuserToken\x18\x01\x20\x01(\tR\tuserToken\"\xc4\
    \x01\n\x19VerifyAssociationResponse\x12\x16\n\x06status\x18\x01\x20\x01(\
    \x05R\x06status\x120\n\x0ebillingAddress\x18\x02\x20\x01(\x0b2\x08.Addre\
    ssR\x0ebillingAddress\x12+\n\ncarrierTos\x18\x03\x20\x01(\x0b2\x0b.Carri\
    erTosR\ncarrierTos\x120\n\x13carrierErrorMessage\x18\x04\x20\x01(\tR\x13\
    carrierErrorMessage\"\xca\x03\n\x10AddressChallenge\x122\n\x14responseAd\
    dressParam\x18\x01\x20\x01(\tR\x14responseAddressParam\x128\n\x17respons\
    eCheckboxesParam\x18\x02\x20\x01(\tR\x17responseCheckboxesParam\x12\x14\
    \n\x05title\x18\x03\x20\x01(\tR\x05title\x12(\n\x0fdescriptionHtml\x18\
    \x04\x20\x01(\tR\x0fdescriptionHtml\x12)\n\x08checkbox\x18\x05\x20\x03(\
    \x0b2\r.FormCheckboxR\x08checkbox\x12\"\n\x07address\x18\x06\x20\x01(\
    \x0b2\x08.AddressR\x07address\x12?\n\x0ferrorInputField\x18\x07\x20\x03(\
    \x0b2\x15.InputValidationErrorR\x0ferrorInputField\x12\x1c\n\terrorHtml\
    \x18\x08\x20\x01(\tR\terrorHtml\x12$\n\rrequiredField\x18\t\x20\x03(\x05\
    R\rrequiredField\x124\n\x10supportedCountry\x18\n\x20\x03(\x0b2\x08.Coun\
    tryR\x10supportedCountry\"\xe4\x03\n\x17AuthenticationChallenge\x12.\n\
    \x12authenticationType\x18\x01\x20\x01(\x05R\x12authenticationType\x12H\
    \n\x1fresponseAuthenticationTypeParam\x18\x02\x20\x01(\tR\x1fresponseAut\
    henticationTypeParam\x128\n\x17responseRetryCountParam\x18\x03\x20\x01(\
    \tR\x17responseRetryCountParam\x12&\n\x0egaiaHeaderText\x18\x06\x20\x01(\
    \tR\x0egaiaHeaderText\x128\n\x17gaiaDescriptionTextHtml\x18\x07\x20\x01(\
    \tR\x17gaiaDescriptionTextHtml\x12.\n\x12gaiaFooterTextHtml\x18\x08\x20\
    \x01(\tR\x12gaiaFooterTextHtml\x12=\n\x12gaiaOptOutCheckbox\x18\t\x20\
    \x01(\x0b2\r.FormCheckboxR\x12gaiaOptOutCheckbox\x12D\n\x1dgaiaOptOutDes\
    criptionTextHtml\x18\n\x20\x01(\tR\x1dgaiaOptOutDescriptionTextHtml\"\
    \xdd\x01\n\tChallenge\x12=\n\x10addressChallenge\x18\x01\x20\x01(\x0b2\
    \x11.AddressChallengeR\x10addressChallenge\x12R\n\x17authenticationChall\
    enge\x18\x02\x20\x01(\x0b2\x18.AuthenticationChallengeR\x17authenticatio\
    nChallenge\x12=\n\x10webViewChallenge\x18\x03\x20\x01(\x0b2\x11.WebViewC\
    hallengeR\x10webViewChallenge\"K\n\x07Country\x12\x1e\n\nregionCode\x18\
    \x01\x20\x01(\tR\nregionCode\x12\x20\n\x0bdisplayName\x18\x02\x20\x01(\t\
    R\x0bdisplayName\"v\n\x0cFormCheckbox\x12\x20\n\x0bdescription\x18\x01\
    \x20\x01(\tR\x0bdescription\x12\x18\n\x07checked\x18\x02\x20\x01(\x08R\
    \x07checked\x12\x1a\n\x08required\x18\x03\x20\x01(\x08R\x08required\x12\
    \x0e\n\x02id\x18\x04\x20\x01(\tR\x02id\"Z\n\x14InputValidationError\x12\
    \x1e\n\ninputField\x18\x01\x20\x01(\x05R\ninputField\x12\"\n\x0cerrorMes\
    sage\x18\x02\x20\x01(\tR\x0cerrorMessage\"\x8c\x02\n\x10WebViewChallenge\
    \x12\x1a\n\x08startUrl\x18\x01\x20\x01(\tR\x08startUrl\x12(\n\x0ftargetU\
    rlRegexp\x18\x02\x20\x01(\tR\x0ftargetUrlRegexp\x12:\n\x18cancelButtonDi\
    splayLabel\x18\x03\x20\x01(\tR\x18cancelButtonDisplayLabel\x126\n\x16res\
    ponseTargetUrlParam\x18\x04\x20\x01(\tR\x16responseTargetUrlParam\x12(\n\
    \x0fcancelUrlRegexp\x18\x05\x20\x01(\tR\x0fcancelUrlRegexp\x12\x14\n\x05\
    title\x18\x06\x20\x01(\tR\x05title\"\xbf\x02\n\x17AddCreditCardPromoOffe\
    r\x12\x1e\n\nheaderText\x18\x01\x20\x01(\tR\nheaderText\x12(\n\x0fdescri\
    ptionHtml\x18\x02\x20\x01(\tR\x0fdescriptionHtml\x12\x1c\n\x05image\x18\
    \x03\x20\x01(\x0b2\x06.ImageR\x05image\x122\n\x14introductoryTextHtml\
    \x18\x04\x20\x01(\tR\x14introductoryTextHtml\x12\x1e\n\nofferTitle\x18\
    \x05\x20\x01(\tR\nofferTitle\x120\n\x13noActionDescription\x18\x06\x20\
    \x01(\tR\x13noActionDescription\x126\n\x16termsAndConditionsHtml\x18\x07\
    \x20\x01(\tR\x16termsAndConditionsHtml\"_\n\x13AvailablePromoOffer\x12H\
    \n\x12addCreditCardOffer\x18\x01\x20\x01(\x0b2\x18.AddCreditCardPromoOff\
    erR\x12addCreditCardOffer\"\xc8\x01\n\x17CheckPromoOfferResponse\x12<\n\
    \x0eavailableOffer\x18\x01\x20\x03(\x0b2\x14.AvailablePromoOfferR\x0eava\
    ilableOffer\x129\n\rredeemedOffer\x18\x02\x20\x01(\x0b2\x13.RedeemedProm\
    oOfferR\rredeemedOffer\x124\n\x15checkoutTokenRequired\x18\x03\x20\x01(\
    \x08R\x15checkoutTokenRequired\"|\n\x12RedeemedPromoOffer\x12\x1e\n\nhea\
    derText\x18\x01\x20\x01(\tR\nheaderText\x12(\n\x0fdescriptionHtml\x18\
    \x02\x20\x01(\tR\x0fdescriptionHtml\x12\x1c\n\x05image\x18\x03\x20\x01(\
    \x0b2\x06.ImageR\x05image\"\x9f\x01\n\x11ActiveExperiments\x12:\n\x18cli\
    entAlteringExperiment\x18\x01\x20\x03(\tR\x18clientAlteringExperiment\
    \x12(\n\x0fotherExperiment\x18\x02\x20\x03(\tR\x0fotherExperiment\x12$\n\
    \rgwsExperiment\x18\x03\x20\x03(\x05R\rgwsExperiment\"\xe3\x02\n\x11Andr\
    oidClientInfo\x12\x1c\n\tandroidId\x18\x01\x20\x01(\x03R\tandroidId\x12\
    \x1c\n\tloggingId\x18\x02\x20\x01(\tR\tloggingId\x12\x1e\n\nsdkVersion\
    \x18\x03\x20\x01(\x05R\nsdkVersion\x12\x14\n\x05model\x18\x04\x20\x01(\t\
    R\x05model\x12\x18\n\x07product\x18\x05\x20\x01(\tR\x07product\x12\x18\n\
    \x07osBuild\x18\x06\x20\x01(\tR\x07osBuild\x12*\n\x10applicationBuild\
    \x18\x07\x20\x01(\tR\x10applicationBuild\x12\x1a\n\x08hardware\x18\x08\
    \x20\x01(\tR\x08hardware\x12\x16\n\x06device\x18\t\x20\x01(\tR\x06device\
    \x12\x16\n\x06mccMnc\x18\n\x20\x01(\tR\x06mccMnc\x12\x16\n\x06locale\x18\
    \x0b\x20\x01(\tR\x06locale\x12\x18\n\x07country\x18\x0c\x20\x01(\tR\x07c\
    ountry\"\xe6\x01\n\nClientInfo\x12\x1e\n\nclientType\x18\x01\x20\x01(\
    \x05R\nclientType\x12@\n\x11androidClientInfo\x18\x02\x20\x01(\x0b2\x12.\
    AndroidClientInfoR\x11androidClientInfo\x12@\n\x11desktopClientInfo\x18\
    \x03\x20\x01(\x0b2\x12.DesktopClientInfoR\x11desktopClientInfo\x124\n\ri\
    osClientInfo\x18\x04\x20\x01(\x0b2\x0e.IosClientInfoR\riosClientInfo\"\
    \xd7\x01\n\x11DesktopClientInfo\x12\x1a\n\x08clientId\x18\x01\x20\x01(\t\
    R\x08clientId\x12\x1c\n\tloggingId\x18\x02\x20\x01(\tR\tloggingId\x12\
    \x0e\n\x02os\x18\x03\x20\x01(\tR\x02os\x12&\n\x0eosMajorVersion\x18\x04\
    \x20\x01(\tR\x0eosMajorVersion\x12$\n\rosFullVersion\x18\x05\x20\x01(\tR\
    \rosFullVersion\x12*\n\x10applicationBuild\x18\x06\x20\x01(\tR\x10applic\
    ationBuild\"\"\n\x10ExperimentIdList\x12\x0e\n\x02id\x18\x01\x20\x03(\tR\
    \x02id\"\xc3\x01\n\rIosClientInfo\x12\x1a\n\x08clientId\x18\x01\x20\x01(\
    \tR\x08clientId\x12\x1c\n\tloggingId\x18\x02\x20\x01(\tR\tloggingId\x12&\
    \n\x0eosMajorVersion\x18\x03\x20\x01(\tR\x0eosMajorVersion\x12$\n\rosFul\
    lVersion\x18\x04\x20\x01(\tR\rosFullVersion\x12*\n\x10applicationBuild\
    \x18\x05\x20\x01(\tR\x10applicationBuild\"\xe2\x01\n\x08LogEvent\x12\x20\
    \n\x0beventTimeMs\x18\x01\x20\x01(\x03R\x0beventTimeMs\x12\x10\n\x03tag\
    \x18\x02\x20\x01(\tR\x03tag\x12(\n\x05value\x18\x03\x20\x03(\x0b2\x12.Lo\
    gEventKeyValuesR\x05value\x12(\n\x05store\x18\x04\x20\x01(\x0b2\x12.Play\
    StoreLogEventR\x05store\x12(\n\x0fsourceExtension\x18\x06\x20\x01(\x0cR\
    \x0fsourceExtension\x12$\n\x03exp\x18\x07\x20\x01(\x0b2\x12.ActiveExperi\
    mentsR\x03exp\";\n\x11LogEventKeyValues\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\xd6\x01\n\
    \nLogRequest\x12+\n\nclientInfo\x18\x01\x20\x01(\x0b2\x0b.ClientInfoR\nc\
    lientInfo\x12\x1c\n\tlogSource\x18\x02\x20\x01(\x05R\tlogSource\x12%\n\
    \x08logEvent\x18\x03\x20\x03(\x0b2\t.LogEventR\x08logEvent\x12$\n\rreque\
    stTimeMs\x18\x04\x20\x01(\x03R\rrequestTimeMs\x120\n\x13serializedLogEve\
    nts\x18\x05\x20\x01(\x0cR\x13serializedLogEvents\"x\n\x0bLogResponse\x12\
    4\n\x15nextRequestWaitMillis\x18\x01\x20\x01(\x03R\x15nextRequestWaitMil\
    lis\x123\n\x0bexperiments\x18\x02\x20\x01(\x0b2\x11.ExperimentIdListR\
    \x0bexperiments\"Y\n\x05Docid\x12\"\n\x0cbackendDocid\x18\x01\x20\x01(\t\
    R\x0cbackendDocid\x12\x12\n\x04type\x18\x02\x20\x01(\x05R\x04type\x12\
    \x18\n\x07backend\x18\x03\x20\x01(\x05R\x07backend\"u\n\x07Install\x12\
    \x1c\n\tandroidId\x18\x01\x20\x01(\x06R\tandroidId\x12\x18\n\x07version\
    \x18\x02\x20\x01(\x05R\x07version\x12\x18\n\x07bundled\x18\x03\x20\x01(\
    \x08R\x07bundled\x12\x18\n\x07pending\x18\x04\x20\x01(\x08R\x07pending\"\
    \x11\n\x0fGroupLicenseKey\"J\n\x0cLicenseTerms\x12:\n\x0fgroupLicenseKey\
    \x18\x01\x20\x01(\x0b2\x10.GroupLicenseKeyR\x0fgroupLicenseKey\"\x85\n\n\
    \x05Offer\x12\x16\n\x06micros\x18\x01\x20\x01(\x03R\x06micros\x12\"\n\
    \x0ccurrencyCode\x18\x02\x20\x01(\tR\x0ccurrencyCode\x12(\n\x0fformatted\
    Amount\x18\x03\x20\x01(\tR\x0fformattedAmount\x12.\n\x0econvertedPrice\
    \x18\x04\x20\x03(\x0b2\x06.OfferR\x0econvertedPrice\x122\n\x14checkoutFl\
    owRequired\x18\x05\x20\x01(\x08R\x14checkoutFlowRequired\x12(\n\x0ffullP\
    riceMicros\x18\x06\x20\x01(\x03R\x0ffullPriceMicros\x120\n\x13formattedF\
    ullAmount\x18\x07\x20\x01(\tR\x13formattedFullAmount\x12\x1c\n\tofferTyp\
    e\x18\x08\x20\x01(\x05R\tofferType\x12.\n\x0brentalTerms\x18\t\x20\x01(\
    \x0b2\x0c.RentalTermsR\x0brentalTerms\x12\x1e\n\nonSaleDate\x18\n\x20\
    \x01(\x03R\nonSaleDate\x12&\n\x0epromotionLabel\x18\x0b\x20\x03(\tR\x0ep\
    romotionLabel\x12@\n\x11subscriptionTerms\x18\x0c\x20\x01(\x0b2\x12.Subs\
    criptionTermsR\x11subscriptionTerms\x12$\n\rformattedName\x18\r\x20\x01(\
    \tR\rformattedName\x122\n\x14formattedDescription\x18\x0e\x20\x01(\tR\
    \x14formattedDescription\x12\x1a\n\x08preorder\x18\x0f\x20\x01(\x08R\x08\
    preorder\x12P\n#onSaleDateDisplayTimeZoneOffsetMsec\x18\x10\x20\x01(\x05\
    R#onSaleDateDisplayTimeZoneOffsetMsec\x12,\n\x11licensedOfferType\x18\
    \x11\x20\x01(\x05R\x11licensedOfferType\x12U\n\x18subscriptionContentTer\
    ms\x18\x12\x20\x01(\x0b2\x19.SubscriptionContentTermsR\x18subscriptionCo\
    ntentTerms\x12\x18\n\x07offerId\x18\x13\x20\x01(\tR\x07offerId\x12F\n\
    \x1epreorderFulfillmentDisplayDate\x18\x14\x20\x01(\x03R\x1epreorderFulf\
    illmentDisplayDate\x121\n\x0clicenseTerms\x18\x15\x20\x01(\x0b2\r.Licens\
    eTermsR\x0clicenseTerms\x12(\n\x0ftemporarilyFree\x18\x16\x20\x01(\x08R\
    \x0ftemporarilyFree\x121\n\x0cvoucherTerms\x18\x17\x20\x01(\x0b2\r.Vouch\
    erTermsR\x0cvoucherTerms\x121\n\x0cofferPayment\x18\x18\x20\x03(\x0b2\r.\
    OfferPaymentR\x0cofferPayment\x12,\n\x11repeatLastPayment\x18\x19\x20\
    \x01(\x08R\x11repeatLastPayment\x12&\n\x0ebuyButtonLabel\x18\x1a\x20\x01\
    (\tR\x0ebuyButtonLabel\x126\n\x16instantPurchaseEnabled\x18\x1b\x20\x01(\
    \x08R\x16instantPurchaseEnabled\"5\n\x0bMonthAndDay\x12\x14\n\x05month\
    \x18\x01\x20\x01(\rR\x05month\x12\x10\n\x03day\x18\x02\x20\x01(\rR\x03da\
    y\"\x81\x01\n\x12OfferPaymentPeriod\x12'\n\x08duration\x18\x01\x20\x01(\
    \x0b2\x0b.TimePeriodR\x08duration\x12\"\n\x05start\x18\x02\x20\x01(\x0b2\
    \x0c.MonthAndDayR\x05start\x12\x1e\n\x03end\x18\x03\x20\x01(\x0b2\x0c.Mo\
    nthAndDayR\x03end\"r\n\x14OfferPaymentOverride\x12\x16\n\x06micros\x18\
    \x01\x20\x01(\x03R\x06micros\x12\"\n\x05start\x18\x02\x20\x01(\x0b2\x0c.\
    MonthAndDayR\x05start\x12\x1e\n\x03end\x18\x03\x20\x01(\x0b2\x0c.MonthAn\
    dDayR\x03end\"\xda\x01\n\x0cOfferPayment\x12\x16\n\x06micros\x18\x01\x20\
    \x01(\x03R\x06micros\x12\"\n\x0ccurrencyCode\x18\x02\x20\x01(\tR\x0ccurr\
    encyCode\x12C\n\x12offerPaymentPeriod\x18\x03\x20\x01(\x0b2\x13.OfferPay\
    mentPeriodR\x12offerPaymentPeriod\x12I\n\x14offerPaymentOverride\x18\x04\
    \x20\x03(\x0b2\x15.OfferPaymentOverrideR\x14offerPaymentOverride\"\x0e\n\
    \x0cVoucherTerms\"\xff\x01\n\x0bRentalTerms\x12B\n\x1cdEPRECATEDGrantPer\
    iodSeconds\x18\x01\x20\x01(\x05R\x1cdEPRECATEDGrantPeriodSeconds\x12H\n\
    \x1fdEPRECATEDActivatePeriodSeconds\x18\x02\x20\x01(\x05R\x1fdEPRECATEDA\
    ctivatePeriodSeconds\x12-\n\x0bgrantPeriod\x18\x03\x20\x01(\x0b2\x0b.Tim\
    ePeriodR\x0bgrantPeriod\x123\n\x0eactivatePeriod\x18\x04\x20\x01(\x0b2\
    \x0b.TimePeriodR\x0eactivatePeriod\"J\n\nSignedData\x12\x1e\n\nsignedDat\
    a\x18\x01\x20\x01(\tR\nsignedData\x12\x1c\n\tsignature\x18\x02\x20\x01(\
    \tR\tsignature\"V\n\x18SubscriptionContentTerms\x12:\n\x14requiredSubscr\
    iption\x18\x01\x20\x01(\x0b2\x06.DocidR\x14requiredSubscription\"y\n\x11\
    SubscriptionTerms\x125\n\x0frecurringPeriod\x18\x01\x20\x01(\x0b2\x0b.Ti\
    mePeriodR\x0frecurringPeriod\x12-\n\x0btrialPeriod\x18\x02\x20\x01(\x0b2\
    \x0b.TimePeriodR\x0btrialPeriod\"6\n\nTimePeriod\x12\x12\n\x04unit\x18\
    \x01\x20\x01(\x05R\x04unit\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05c\
    ount\"j\n\x12BillingAddressSpec\x12.\n\x12billingAddressType\x18\x01\x20\
    \x01(\x05R\x12billingAddressType\x12$\n\rrequiredField\x18\x02\x20\x03(\
    \x05R\rrequiredField\"\xcc\x01\n\x0eBillingProfile\x12+\n\ninstrument\
    \x18\x01\x20\x03(\x0b2\x0b.InstrumentR\ninstrument\x12B\n\x1cselectedExt\
    ernalInstrumentId\x18\x02\x20\x01(\tR\x1cselectedExternalInstrumentId\
    \x12I\n\x14billingProfileOption\x18\x03\x20\x03(\x0b2\x15.BillingProfile\
    OptionR\x14billingProfileOption\"\x95\x02\n\x14BillingProfileOption\x12\
    \x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\"\n\x0cdisplayTitle\x18\
    \x02\x20\x01(\tR\x0cdisplayTitle\x122\n\x14externalInstrumentId\x18\x03\
    \x20\x01(\tR\x14externalInstrumentId\x12(\n\ttopupInfo\x18\x04\x20\x01(\
    \x0b2\n.TopupInfoR\ttopupInfo\x12g\n\x1ecarrierBillingInstrumentStatus\
    \x18\x05\x20\x01(\x0b2\x1f.CarrierBillingInstrumentStatusR\x1ecarrierBil\
    lingInstrumentStatus\"Q\n\x19CarrierBillingCredentials\x12\x14\n\x05valu\
    e\x18\x01\x20\x01(\tR\x05value\x12\x1e\n\nexpiration\x18\x02\x20\x01(\
    \x03R\nexpiration\"\xb5\x03\n\x18CarrierBillingInstrument\x12$\n\rinstru\
    mentKey\x18\x01\x20\x01(\tR\rinstrumentKey\x12\x20\n\x0baccountType\x18\
    \x02\x20\x01(\tR\x0baccountType\x12\"\n\x0ccurrencyCode\x18\x03\x20\x01(\
    \tR\x0ccurrencyCode\x12*\n\x10transactionLimit\x18\x04\x20\x01(\x03R\x10\
    transactionLimit\x122\n\x14subscriberIdentifier\x18\x05\x20\x01(\tR\x14s\
    ubscriberIdentifier\x12R\n\x17encryptedSubscriberInfo\x18\x06\x20\x01(\
    \x0b2\x18.EncryptedSubscriberInfoR\x17encryptedSubscriberInfo\x12<\n\x0b\
    credentials\x18\x07\x20\x01(\x0b2\x1a.CarrierBillingCredentialsR\x0bcred\
    entials\x12;\n\x12acceptedCarrierTos\x18\x08\x20\x01(\x0b2\x0b.CarrierTo\
    sR\x12acceptedCarrierTos\"\xa6\x03\n\x1eCarrierBillingInstrumentStatus\
    \x12+\n\ncarrierTos\x18\x01\x20\x01(\x0b2\x0b.CarrierTosR\ncarrierTos\
    \x120\n\x13associationRequired\x18\x02\x20\x01(\x08R\x13associationRequi\
    red\x12*\n\x10passwordRequired\x18\x03\x20\x01(\x08R\x10passwordRequired\
    \x12E\n\x15carrierPasswordPrompt\x18\x04\x20\x01(\x0b2\x0f.PasswordPromp\
    tR\x15carrierPasswordPrompt\x12\x1e\n\napiVersion\x18\x05\x20\x01(\x05R\
    \napiVersion\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\x12@\n\x11dev\
    iceAssociation\x18\x07\x20\x01(\x0b2\x12.DeviceAssociationR\x11deviceAss\
    ociation\x12<\n\x19carrierSupportPhoneNumber\x18\x08\x20\x01(\tR\x19carr\
    ierSupportPhoneNumber\"\xcc\x01\n\nCarrierTos\x12(\n\x06dcbTos\x18\x01\
    \x20\x01(\x0b2\x10.CarrierTosEntryR\x06dcbTos\x12(\n\x06piiTos\x18\x02\
    \x20\x01(\x0b2\x10.CarrierTosEntryR\x06piiTos\x124\n\x15needsDcbTosAccep\
    tance\x18\x03\x20\x01(\x08R\x15needsDcbTosAcceptance\x124\n\x15needsPiiT\
    osAcceptance\x18\x04\x20\x01(\x08R\x15needsPiiTosAcceptance\"=\n\x0fCarr\
    ierTosEntry\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x18\n\x07ver\
    sion\x18\x02\x20\x01(\tR\x07version\"\xf3\x01\n\x14CreditCardInstrument\
    \x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\"\n\x0cescrowHandle\
    \x18\x02\x20\x01(\tR\x0cescrowHandle\x12\x1e\n\nlastDigits\x18\x03\x20\
    \x01(\tR\nlastDigits\x12(\n\x0fexpirationMonth\x18\x04\x20\x01(\x05R\x0f\
    expirationMonth\x12&\n\x0eexpirationYear\x18\x05\x20\x01(\x05R\x0eexpira\
    tionYear\x121\n\x0eescrowEfeParam\x18\x06\x20\x03(\x0b2\t.EfeParamR\x0ee\
    scrowEfeParam\"\x87\x01\n\x11DeviceAssociation\x128\n\x17userTokenReques\
    tMessage\x18\x01\x20\x01(\tR\x17userTokenRequestMessage\x128\n\x17userTo\
    kenRequestAddress\x18\x02\x20\x01(\tR\x17userTokenRequestAddress\"\x8c\
    \x01\n\x0cDisabledInfo\x12&\n\x0edisabledReason\x18\x01\x20\x01(\x05R\
    \x0edisabledReason\x120\n\x13disabledMessageHtml\x18\x02\x20\x01(\tR\x13\
    disabledMessageHtml\x12\"\n\x0cerrorMessage\x18\x03\x20\x01(\tR\x0cerror\
    Message\"2\n\x08EfeParam\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x9b\x05\n\nInstrument\
    \x122\n\x14externalInstrumentId\x18\x01\x20\x01(\tR\x14externalInstrumen\
    tId\x120\n\x0ebillingAddress\x18\x02\x20\x01(\x0b2\x08.AddressR\x0ebilli\
    ngAddress\x125\n\ncreditCard\x18\x03\x20\x01(\x0b2\x15.CreditCardInstrum\
    entR\ncreditCard\x12A\n\x0ecarrierBilling\x18\x04\x20\x01(\x0b2\x19.Carr\
    ierBillingInstrumentR\x0ecarrierBilling\x12C\n\x12billingAddressSpec\x18\
    \x05\x20\x01(\x0b2\x13.BillingAddressSpecR\x12billingAddressSpec\x12*\n\
    \x10instrumentFamily\x18\x06\x20\x01(\x05R\x10instrumentFamily\x12S\n\
    \x14carrierBillingStatus\x18\x07\x20\x01(\x0b2\x1f.CarrierBillingInstrum\
    entStatusR\x14carrierBillingStatus\x12\"\n\x0cdisplayTitle\x18\x08\x20\
    \x01(\tR\x0cdisplayTitle\x12<\n\x13topupInfoDeprecated\x18\t\x20\x01(\
    \x0b2\n.TopupInfoR\x13topupInfoDeprecated\x12\x18\n\x07version\x18\n\x20\
    \x01(\x05R\x07version\x128\n\x0bstoredValue\x18\x0b\x20\x01(\x0b2\x16.St\
    oredValueInstrumentR\x0bstoredValue\x121\n\x0cdisabledInfo\x18\x0c\x20\
    \x03(\x0b2\r.DisabledInfoR\x0cdisabledInfo\"\xe0\x01\n\x13InstrumentSetu\
    pInfo\x12*\n\x10instrumentFamily\x18\x01\x20\x01(\x05R\x10instrumentFami\
    ly\x12\x1c\n\tsupported\x18\x02\x20\x01(\x08R\tsupported\x12=\n\x10addre\
    ssChallenge\x18\x03\x20\x01(\x0b2\x11.AddressChallengeR\x10addressChalle\
    nge\x12\x20\n\x07balance\x18\x04\x20\x01(\x0b2\x06.MoneyR\x07balance\x12\
    \x1e\n\nfooterHtml\x18\x05\x20\x03(\tR\nfooterHtml\"V\n\x0ePasswordPromp\
    t\x12\x16\n\x06prompt\x18\x01\x20\x01(\tR\x06prompt\x12,\n\x11forgotPass\
    wordUrl\x18\x02\x20\x01(\tR\x11forgotPasswordUrl\"w\n\x15StoredValueInst\
    rument\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\x20\n\x07bala\
    nce\x18\x02\x20\x01(\x0b2\x06.MoneyR\x07balance\x12(\n\ttopupInfo\x18\
    \x03\x20\x01(\x0b2\n.TopupInfoR\ttopupInfo\"\xd7\x01\n\tTopupInfo\x12H\n\
    \x1foptionsContainerDocidDeprecated\x18\x01\x20\x01(\tR\x1foptionsContai\
    nerDocidDeprecated\x12&\n\x0eoptionsListUrl\x18\x02\x20\x01(\tR\x0eoptio\
    nsListUrl\x12\x1a\n\x08subtitle\x18\x03\x20\x01(\tR\x08subtitle\x12<\n\
    \x15optionsContainerDocid\x18\x04\x20\x01(\x0b2\x06.DocidR\x15optionsCon\
    tainerDocid\"g\n\x17ConsumePurchaseResponse\x124\n\rlibraryUpdate\x18\
    \x01\x20\x01(\x0b2\x0e.LibraryUpdateR\rlibraryUpdate\x12\x16\n\x06status\
    \x18\x02\x20\x01(\x05R\x06status\"\x97\x02\n\x11ContainerMetadata\x12\
    \x1c\n\tbrowseUrl\x18\x01\x20\x01(\tR\tbrowseUrl\x12\x20\n\x0bnextPageUr\
    l\x18\x02\x20\x01(\tR\x0bnextPageUrl\x12\x1c\n\trelevance\x18\x03\x20\
    \x01(\x01R\trelevance\x12*\n\x10estimatedResults\x18\x04\x20\x01(\x03R\
    \x10estimatedResults\x12(\n\x0fanalyticsCookie\x18\x05\x20\x01(\tR\x0fan\
    alyticsCookie\x12\x18\n\x07ordered\x18\x06\x20\x01(\x08R\x07ordered\x124\
    \n\rcontainerView\x18\x07\x20\x03(\x0b2\x0e.ContainerViewR\rcontainerVie\
    w\"\x87\x01\n\rContainerView\x12\x1a\n\x08selected\x18\x01\x20\x01(\x08R\
    \x08selected\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x18\n\
    \x07listUrl\x18\x03\x20\x01(\tR\x07listUrl\x12*\n\x10serverLogsCookie\
    \x18\x04\x20\x01(\x0cR\x10serverLogsCookie\"\x15\n\x13FlagContentRespons\
    e\"\xd8\n\n\x15ClientDownloadRequest\x12\x10\n\x03url\x18\x01\x20\x01(\t\
    R\x03url\x128\n\x07digests\x18\x02\x20\x01(\x0b2\x1e.ClientDownloadReque\
    st.DigestsR\x07digests\x12\x16\n\x06length\x18\x03\x20\x01(\x03R\x06leng\
    th\x12=\n\tresources\x18\x04\x20\x03(\x0b2\x1f.ClientDownloadRequest.Res\
    ourceR\tresources\x12B\n\tsignature\x18\x05\x20\x01(\x0b2$.ClientDownloa\
    dRequest.SignatureInfoR\tsignature\x12$\n\ruserInitiated\x18\x06\x20\x01\
    (\x08R\ruserInitiated\x12\x1c\n\tclientAsn\x18\x08\x20\x03(\tR\tclientAs\
    n\x12\"\n\x0cfileBasename\x18\t\x20\x01(\tR\x0cfileBasename\x12\"\n\x0cd\
    ownloadType\x18\n\x20\x01(\x05R\x0cdownloadType\x12\x16\n\x06locale\x18\
    \x0b\x20\x01(\tR\x06locale\x128\n\x07apkInfo\x18\x0c\x20\x01(\x0b2\x1e.C\
    lientDownloadRequest.ApkInfoR\x07apkInfo\x12\x1c\n\tandroidId\x18\r\x20\
    \x01(\x06R\tandroidId\x120\n\x13originatingPackages\x18\x0f\x20\x03(\tR\
    \x13originatingPackages\x12X\n\x14originatingSignature\x18\x11\x20\x01(\
    \x0b2$.ClientDownloadRequest.SignatureInfoR\x14originatingSignature\x1aM\
    \n\x07ApkInfo\x12\x20\n\x0bpackageName\x18\x01\x20\x01(\tR\x0bpackageNam\
    e\x12\x20\n\x0bversionCode\x18\x02\x20\x01(\x05R\x0bversionCode\x1a\xcd\
    \x02\n\x10CertificateChain\x12I\n\x07element\x18\x01\x20\x03(\x0b2/.Clie\
    ntDownloadRequest.CertificateChain.ElementR\x07element\x1a\xed\x01\n\x07\
    Element\x12\x20\n\x0bcertificate\x18\x01\x20\x01(\x0cR\x0bcertificate\
    \x12.\n\x12parsedSuccessfully\x18\x02\x20\x01(\x08R\x12parsedSuccessfull\
    y\x12\x18\n\x07subject\x18\x03\x20\x01(\x0cR\x07subject\x12\x16\n\x06iss\
    uer\x18\x04\x20\x01(\x0cR\x06issuer\x12\x20\n\x0bfingerprint\x18\x05\x20\
    \x01(\x0cR\x0bfingerprint\x12\x1e\n\nexpiryTime\x18\x06\x20\x01(\x03R\ne\
    xpiryTime\x12\x1c\n\tstartTime\x18\x07\x20\x01(\x03R\tstartTime\x1aG\n\
    \x07Digests\x12\x16\n\x06sha256\x18\x01\x20\x01(\x0cR\x06sha256\x12\x12\
    \n\x04sha1\x18\x02\x20\x01(\x0cR\x04sha1\x12\x10\n\x03md5\x18\x03\x20\
    \x01(\x0cR\x03md5\x1ah\n\x08Resource\x12\x10\n\x03url\x18\x01\x20\x01(\t\
    R\x03url\x12\x12\n\x04type\x18\x02\x20\x01(\x05R\x04type\x12\x1a\n\x08re\
    moteIp\x18\x03\x20\x01(\x0cR\x08remoteIp\x12\x1a\n\x08referrer\x18\x04\
    \x20\x01(\tR\x08referrer\x1a~\n\rSignatureInfo\x12S\n\x10certificateChai\
    n\x18\x01\x20\x03(\x0b2'.ClientDownloadRequest.CertificateChainR\x10cert\
    ificateChain\x12\x18\n\x07trusted\x18\x02\x20\x01(\x08R\x07trusted\"\xc6\
    \x01\n\x16ClientDownloadResponse\x12\x18\n\x07verdict\x18\x01\x20\x01(\
    \x05R\x07verdict\x12<\n\x08moreInfo\x18\x02\x20\x01(\x0b2\x20.ClientDown\
    loadResponse.MoreInfoR\x08moreInfo\x12\x14\n\x05token\x18\x03\x20\x01(\
    \x0cR\x05token\x1a>\n\x08MoreInfo\x12\x20\n\x0bdescription\x18\x01\x20\
    \x01(\tR\x0bdescription\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\"V\n\
    \x1aClientDownloadStatsRequest\x12\"\n\x0cuserDecision\x18\x01\x20\x01(\
    \x05R\x0cuserDecision\x12\x14\n\x05token\x18\x02\x20\x01(\x0cR\x05token\
    \"\x8a\x01\n\tDebugInfo\x12\x18\n\x07message\x18\x01\x20\x03(\tR\x07mess\
    age\x12)\n\x06timing\x18\x02\x20\x03(\n2\x11.DebugInfo.TimingR\x06timing\
    \x1a8\n\x06Timing\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1a\
    \n\x08timeInMs\x18\x04\x20\x01(\x01R\x08timeInMs\"}\n\x15DebugSettingsRe\
    sponse\x120\n\x13playCountryOverride\x18\x01\x20\x01(\tR\x13playCountryO\
    verride\x122\n\x14playCountryDebugInfo\x18\x02\x20\x01(\tR\x14playCountr\
    yDebugInfo\"m\n\x10DeliveryResponse\x12\x16\n\x06status\x18\x01\x20\x01(\
    \x05R\x06status\x12A\n\x0fappDeliveryData\x18\x02\x20\x01(\x0b2\x17.Andr\
    oidAppDeliveryDataR\x0fappDeliveryData\",\n\x10BulkDetailsEntry\x12\x18\
    \n\x03doc\x18\x01\x20\x01(\x0b2\x06.DocV2R\x03doc\"\xe0\x01\n\x12BulkDet\
    ailsRequest\x12\x14\n\x05docid\x18\x01\x20\x03(\tR\x05docid\x12*\n\x10in\
    cludeChildDocs\x18\x02\x20\x01(\x08R\x10includeChildDocs\x12&\n\x0einclu\
    deDetails\x18\x03\x20\x01(\x08R\x0eincludeDetails\x12,\n\x11sourcePackag\
    eName\x18\x04\x20\x01(\tR\x11sourcePackageName\x122\n\x14installedVersio\
    nCode\x18\x05\x20\x03(\x05R\x14installedVersionCode\">\n\x13BulkDetailsR\
    esponse\x12'\n\x05entry\x18\x01\x20\x03(\x0b2\x11.BulkDetailsEntryR\x05e\
    ntry\"\xa5\x02\n\x0fDetailsResponse\x12\x1c\n\x05docV1\x18\x01\x20\x01(\
    \x0b2\x06.DocV1R\x05docV1\x12(\n\x0fanalyticsCookie\x18\x02\x20\x01(\tR\
    \x0fanalyticsCookie\x12'\n\nuserReview\x18\x03\x20\x01(\x0b2\x07.ReviewR\
    \nuserReview\x12\x1c\n\x05docV2\x18\x04\x20\x01(\x0b2\x06.DocV2R\x05docV\
    2\x12\x1e\n\nfooterHtml\x18\x05\x20\x01(\tR\nfooterHtml\x12*\n\x10server\
    LogsCookie\x18\x06\x20\x01(\x0cR\x10serverLogsCookie\x127\n\x0ediscovery\
    Badge\x18\x07\x20\x03(\x0b2\x0f.DiscoveryBadgeR\x0ediscoveryBadge\"\xcb\
    \x03\n\x0eDiscoveryBadge\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\
    \x12\x1c\n\x05image\x18\x02\x20\x01(\x0b2\x06.ImageR\x05image\x12(\n\x0f\
    backgroundColor\x18\x03\x20\x01(\x05R\x0fbackgroundColor\x12C\n\x12disco\
    veryBadgeLink\x18\x04\x20\x01(\x0b2\x13.DiscoveryBadgeLinkR\x12discovery\
    BadgeLink\x12*\n\x10serverLogsCookie\x18\x05\x20\x01(\x0cR\x10serverLogs\
    Cookie\x12\x1c\n\tisPlusOne\x18\x06\x20\x01(\x08R\tisPlusOne\x12(\n\x0fa\
    ggregateRating\x18\x07\x20\x01(\x02R\x0faggregateRating\x12&\n\x0euserSt\
    arRating\x18\x08\x20\x01(\x05R\x0euserStarRating\x12$\n\rdownloadCount\
    \x18\t\x20\x01(\tR\rdownloadCount\x12$\n\rdownloadUnits\x18\n\x20\x01(\t\
    R\rdownloadUnits\x12.\n\x12contentDescription\x18\x0b\x20\x01(\tR\x12con\
    tentDescription\"\x83\x01\n\x12DiscoveryBadgeLink\x12\x19\n\x04link\x18\
    \x01\x20\x01(\x0b2\x05.LinkR\x04link\x12&\n\x0euserReviewsUrl\x18\x02\
    \x20\x01(\tR\x0euserReviewsUrl\x12*\n\x10criticReviewsUrl\x18\x03\x20\
    \x01(\tR\x10criticReviewsUrl\"\xc8\x05\n\x18DeviceConfigurationProto\x12\
    \x20\n\x0btouchScreen\x18\x01\x20\x01(\x05R\x0btouchScreen\x12\x1a\n\x08\
    keyboard\x18\x02\x20\x01(\x05R\x08keyboard\x12\x1e\n\nnavigation\x18\x03\
    \x20\x01(\x05R\nnavigation\x12\"\n\x0cscreenLayout\x18\x04\x20\x01(\x05R\
    \x0cscreenLayout\x12(\n\x0fhasHardKeyboard\x18\x05\x20\x01(\x08R\x0fhasH\
    ardKeyboard\x122\n\x14hasFiveWayNavigation\x18\x06\x20\x01(\x08R\x14hasF\
    iveWayNavigation\x12$\n\rscreenDensity\x18\x07\x20\x01(\x05R\rscreenDens\
    ity\x12\x20\n\x0bglEsVersion\x18\x08\x20\x01(\x05R\x0bglEsVersion\x120\n\
    \x13systemSharedLibrary\x18\t\x20\x03(\tR\x13systemSharedLibrary\x126\n\
    \x16systemAvailableFeature\x18\n\x20\x03(\tR\x16systemAvailableFeature\
    \x12&\n\x0enativePlatform\x18\x0b\x20\x03(\tR\x0enativePlatform\x12\x20\
    \n\x0bscreenWidth\x18\x0c\x20\x01(\x05R\x0bscreenWidth\x12\"\n\x0cscreen\
    Height\x18\r\x20\x01(\x05R\x0cscreenHeight\x124\n\x15systemSupportedLoca\
    le\x18\x0e\x20\x03(\tR\x15systemSupportedLocale\x12\x20\n\x0bglExtension\
    \x18\x0f\x20\x03(\tR\x0bglExtension\x12\x20\n\x0bdeviceClass\x18\x10\x20\
    \x01(\x05R\x0bdeviceClass\x122\n\x14maxApkDownloadSizeMb\x18\x11\x20\x01\
    (\x05R\x14maxApkDownloadSizeMb\"\xc7\x06\n\x08Document\x12\x1c\n\x05doci\
    d\x18\x01\x20\x01(\x0b2\x06.DocidR\x05docid\x12&\n\nfetchDocid\x18\x02\
    \x20\x01(\x0b2\x06.DocidR\nfetchDocid\x12(\n\x0bsampleDocid\x18\x03\x20\
    \x01(\x0b2\x06.DocidR\x0bsampleDocid\x12\x14\n\x05title\x18\x04\x20\x01(\
    \tR\x05title\x12\x10\n\x03url\x18\x05\x20\x01(\tR\x03url\x12\x18\n\x07sn\
    ippet\x18\x06\x20\x03(\tR\x07snippet\x120\n\x0fpriceDeprecated\x18\x07\
    \x20\x01(\x0b2\x06.OfferR\x0fpriceDeprecated\x121\n\x0cavailability\x18\
    \t\x20\x01(\x0b2\r.AvailabilityR\x0cavailability\x12\x1c\n\x05image\x18\
    \n\x20\x03(\x0b2\x06.ImageR\x05image\x12\x1f\n\x05child\x18\x0b\x20\x03(\
    \x0b2\t.DocumentR\x05child\x12:\n\x0faggregateRating\x18\r\x20\x01(\x0b2\
    \x10.AggregateRatingR\x0faggregateRating\x12\x1c\n\x05offer\x18\x0e\x20\
    \x03(\x0b2\x06.OfferR\x05offer\x12=\n\x11translatedSnippet\x18\x0f\x20\
    \x03(\x0b2\x0f.TranslatedTextR\x11translatedSnippet\x12:\n\x0fdocumentVa\
    riant\x18\x10\x20\x03(\x0b2\x10.DocumentVariantR\x0fdocumentVariant\x12\
    \x1e\n\ncategoryId\x18\x11\x20\x03(\tR\ncategoryId\x12)\n\ndecoration\
    \x18\x12\x20\x03(\x0b2\t.DocumentR\ndecoration\x12!\n\x06parent\x18\x13\
    \x20\x03(\x0b2\t.DocumentR\x06parent\x12*\n\x10privacyPolicyUrl\x18\x14\
    \x20\x01(\tR\x10privacyPolicyUrl\x12&\n\x0econsumptionUrl\x18\x15\x20\
    \x01(\tR\x0econsumptionUrl\x122\n\x14estimatedNumChildren\x18\x16\x20\
    \x01(\x05R\x14estimatedNumChildren\x12\x1a\n\x08subtitle\x18\x17\x20\x01\
    (\tR\x08subtitle\"\xc5\x03\n\x0fDocumentVariant\x12$\n\rvariationType\
    \x18\x01\x20\x01(\x05R\rvariationType\x12\x19\n\x04rule\x18\x02\x20\x01(\
    \x0b2\x05.RuleR\x04rule\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\
    \x12\x18\n\x07snippet\x18\x04\x20\x03(\tR\x07snippet\x12$\n\rrecentChang\
    es\x18\x05\x20\x01(\tR\rrecentChanges\x129\n\x0fautoTranslation\x18\x06\
    \x20\x03(\x0b2\x0f.TranslatedTextR\x0fautoTranslation\x12\x1c\n\x05offer\
    \x18\x07\x20\x03(\x0b2\x06.OfferR\x05offer\x12\x1c\n\tchannelId\x18\t\
    \x20\x01(\x03R\tchannelId\x12\x1f\n\x05child\x18\n\x20\x03(\x0b2\t.Docum\
    entR\x05child\x12)\n\ndecoration\x18\x0b\x20\x03(\x0b2\t.DocumentR\ndeco\
    ration\x12\x1c\n\x05image\x18\x0c\x20\x03(\x0b2\x06.ImageR\x05image\x12\
    \x1e\n\ncategoryId\x18\r\x20\x03(\tR\ncategoryId\x12\x1a\n\x08subtitle\
    \x18\x0e\x20\x01(\tR\x08subtitle\"\xa4\x06\n\x05Image\x12\x1c\n\timageTy\
    pe\x18\x01\x20\x01(\x05R\timageType\x12.\n\tdimension\x18\x02\x20\x01(\n\
    2\x10.Image.DimensionR\tdimension\x12\x1a\n\x08imageUrl\x18\x05\x20\x01(\
    \tR\x08imageUrl\x12*\n\x10altTextLocalized\x18\x06\x20\x01(\tR\x10altTex\
    tLocalized\x12\x1c\n\tsecureUrl\x18\x07\x20\x01(\tR\tsecureUrl\x12.\n\
    \x12positionInSequence\x18\x08\x20\x01(\x05R\x12positionInSequence\x126\
    \n\x16supportsFifeUrlOptions\x18\t\x20\x01(\x08R\x16supportsFifeUrlOptio\
    ns\x12+\n\x08citation\x18\n\x20\x01(\n2\x0f.Image.CitationR\x08citation\
    \x12(\n\x0fdurationSeconds\x18\x0e\x20\x01(\x05R\x0fdurationSeconds\x12\
    \"\n\x0cfillColorRgb\x18\x0f\x20\x01(\tR\x0cfillColorRgb\x12\x18\n\x07au\
    togen\x18\x10\x20\x01(\x08R\x07autogen\x12.\n\x0battribution\x18\x11\x20\
    \x01(\x0b2\x0c.AttributionR\x0battribution\x12.\n\x12backgroundColorRgb\
    \x18\x13\x20\x01(\tR\x12backgroundColorRgb\x12'\n\x07palette\x18\x14\x20\
    \x01(\x0b2\r.ImagePaletteR\x07palette\x12\x20\n\x0bdeviceClass\x18\x15\
    \x20\x01(\x05R\x0bdeviceClass\x12>\n\x1asupportsFifeMonogramOption\x18\
    \x16\x20\x01(\x08R\x1asupportsFifeMonogramOption\x1a9\n\tDimension\x12\
    \x14\n\x05width\x18\x03\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\
    \x04\x20\x01(\x05R\x06height\x1aD\n\x08Citation\x12&\n\x0etitleLocalized\
    \x18\x0b\x20\x01(\tR\x0etitleLocalized\x12\x10\n\x03url\x18\x0c\x20\x01(\
    \tR\x03url\"\x0e\n\x0cImagePalette\"\x91\x01\n\x0bAttribution\x12\x20\n\
    \x0bsourceTitle\x18\x01\x20\x01(\tR\x0bsourceTitle\x12\x1c\n\tsourceUrl\
    \x18\x02\x20\x01(\tR\tsourceUrl\x12\"\n\x0clicenseTitle\x18\x03\x20\x01(\
    \tR\x0clicenseTitle\x12\x1e\n\nlicenseUrl\x18\x04\x20\x01(\tR\nlicenseUr\
    l\"l\n\x0eTranslatedText\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\
    \x12\"\n\x0csourceLocale\x18\x02\x20\x01(\tR\x0csourceLocale\x12\"\n\x0c\
    targetLocale\x18\x03\x20\x01(\tR\x0ctargetLocale\"{\n\x05Badge\x12\x14\n\
    \x05title\x18\x01\x20\x01(\tR\x05title\x12\x1c\n\x05image\x18\x02\x20\
    \x03(\x0b2\x06.ImageR\x05image\x12\x1c\n\tbrowseUrl\x18\x03\x20\x01(\tR\
    \tbrowseUrl\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\x0bdescription\
    \"b\n\x0eBadgeContainer\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\
    \x12\x1c\n\x05image\x18\x02\x20\x03(\x0b2\x06.ImageR\x05image\x12\x1c\n\
    \x05badge\x18\x03\x20\x03(\x0b2\x06.BadgeR\x05badge\"=\n\x13ContainerWit\
    hBanner\x12&\n\x0ecolorThemeArgb\x18\x01\x20\x01(\tR\x0ecolorThemeArgb\"\
    ^\n\x0cDealOfTheDay\x12&\n\x0efeaturedHeader\x18\x01\x20\x01(\tR\x0efeat\
    uredHeader\x12&\n\x0ecolorThemeArgb\x18\x02\x20\x01(\tR\x0ecolorThemeArg\
    b\"G\n\tDismissal\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12(\n\x0f\
    descriptionHtml\x18\x02\x20\x01(\tR\x0fdescriptionHtml\"\x8d\x02\n\x18Ed\
    itorialSeriesContainer\x12\x20\n\x0bseriesTitle\x18\x01\x20\x01(\tR\x0bs\
    eriesTitle\x12&\n\x0eseriesSubtitle\x18\x02\x20\x01(\tR\x0eseriesSubtitl\
    e\x12\"\n\x0cepisodeTitle\x18\x03\x20\x01(\tR\x0cepisodeTitle\x12(\n\x0f\
    episodeSubtitle\x18\x04\x20\x01(\tR\x0fepisodeSubtitle\x12&\n\x0ecolorTh\
    emeArgb\x18\x05\x20\x01(\tR\x0ecolorThemeArgb\x121\n\x0cvideoSnippet\x18\
    \x06\x20\x03(\x0b2\r.VideoSnippetR\x0cvideoSnippet\"k\n\x04Link\x12\x10\
    \n\x03uri\x18\x01\x20\x01(\tR\x03uri\x121\n\x0cresolvedLink\x18\x02\x20\
    \x01(\x0b2\r.ResolvedLinkR\x0cresolvedLink\x12\x1e\n\nuriBackend\x18\x03\
    \x20\x01(\x05R\nuriBackend\"d\n\nNextBanner\x12\x14\n\x05title\x18\x01\
    \x20\x01(\tR\x05title\x12\x1a\n\x08subtitle\x18\x02\x20\x01(\tR\x08subti\
    tle\x12$\n\rcolorTextArgb\x18\x03\x20\x01(\tR\rcolorTextArgb\"\x87\x01\n\
    \x0fOBSOLETE_Reason\x12\x20\n\x0bbriefReason\x18\x01\x20\x01(\tR\x0bbrie\
    fReason\x126\n\x16oBSOLETEDetailedReason\x18\x02\x20\x01(\tR\x16oBSOLETE\
    DetailedReason\x12\x1a\n\x08uniqueId\x18\x03\x20\x01(\tR\x08uniqueId\"\
    \x9d\x01\n\x0bPlusOneData\x12\x1c\n\tsetByUser\x18\x01\x20\x01(\x08R\tse\
    tByUser\x12\x14\n\x05total\x18\x02\x20\x01(\x03R\x05total\x12\"\n\x0ccir\
    clesTotal\x18\x03\x20\x01(\x03R\x0ccirclesTotal\x126\n\x0fcirclesProfile\
    s\x18\x04\x20\x03(\x0b2\x0c.PlusProfileR\x0fcirclesProfiles\"\xa7\x01\n\
    \x0bPromotedDoc\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x1a\
    \n\x08subtitle\x18\x02\x20\x01(\tR\x08subtitle\x12\x1c\n\x05image\x18\
    \x03\x20\x03(\x0b2\x06.ImageR\x05image\x12(\n\x0fdescriptionHtml\x18\x04\
    \x20\x01(\tR\x0fdescriptionHtml\x12\x1e\n\ndetailsUrl\x18\x05\x20\x01(\t\
    R\ndetailsUrl\"\xd4\x01\n\x06Reason\x12(\n\x0fdescriptionHtml\x18\x03\
    \x20\x01(\tR\x0fdescriptionHtml\x12C\n\x12reasonPlusProfiles\x18\x04\x20\
    \x01(\x0b2\x13.ReasonPlusProfilesR\x12reasonPlusProfiles\x121\n\x0creaso\
    nReview\x18\x05\x20\x01(\x0b2\r.ReasonReviewR\x0creasonReview\x12(\n\tdi\
    smissal\x18\x07\x20\x01(\x0b2\n.DismissalR\tdismissal\"\x80\x01\n\x12Rea\
    sonPlusProfiles\x12:\n\x18localizedDescriptionHtml\x18\x01\x20\x01(\tR\
    \x18localizedDescriptionHtml\x12.\n\x0bplusProfile\x18\x02\x20\x03(\x0b2\
    \x0c.PlusProfileR\x0bplusProfile\"/\n\x0cReasonReview\x12\x1f\n\x06revie\
    w\x18\x01\x20\x01(\x0b2\x07.ReviewR\x06review\"\x1a\n\x18Recommendations\
    Container\"\x8b\x01\n\x0fSectionMetadata\x12\x16\n\x06header\x18\x01\x20\
    \x01(\tR\x06header\x12\x18\n\x07listUrl\x18\x02\x20\x01(\tR\x07listUrl\
    \x12\x1c\n\tbrowseUrl\x18\x03\x20\x01(\tR\tbrowseUrl\x12(\n\x0fdescripti\
    onHtml\x18\x04\x20\x01(\tR\x0fdescriptionHtml\"\xbf\x02\n\rSeriesAntenna\
    \x12\x20\n\x0bseriesTitle\x18\x01\x20\x01(\tR\x0bseriesTitle\x12&\n\x0es\
    eriesSubtitle\x18\x02\x20\x01(\tR\x0eseriesSubtitle\x12\"\n\x0cepisodeTi\
    tle\x18\x03\x20\x01(\tR\x0cepisodeTitle\x12(\n\x0fepisodeSubtitle\x18\
    \x04\x20\x01(\tR\x0fepisodeSubtitle\x12&\n\x0ecolorThemeArgb\x18\x05\x20\
    \x01(\tR\x0ecolorThemeArgb\x126\n\rsectionTracks\x18\x06\x20\x01(\x0b2\
    \x10.SectionMetadataR\rsectionTracks\x126\n\rsectionAlbums\x18\x07\x20\
    \x01(\x0b2\x10.SectionMetadataR\rsectionAlbums\"\xa6\x01\n\x11Suggestion\
    Reasons\x12\x1f\n\x06reason\x18\x02\x20\x03(\x0b2\x07.ReasonR\x06reason\
    \x126\n\x10neutralDismissal\x18\x04\x20\x01(\x0b2\n.DismissalR\x10neutra\
    lDismissal\x128\n\x11positiveDismissal\x18\x05\x20\x01(\x0b2\n.Dismissal\
    R\x11positiveDismissal\"\x87\x07\n\x08Template\x124\n\rseriesAntenna\x18\
    \x01\x20\x01(\x0b2\x0e.SeriesAntennaR\rseriesAntenna\x125\n\x0etileGraph\
    ic2X1\x18\x02\x20\x01(\x0b2\r.TileTemplateR\x0etileGraphic2X1\x125\n\x0e\
    tileGraphic4X2\x18\x03\x20\x01(\x0b2\r.TileTemplateR\x0etileGraphic4X2\
    \x12M\n\x1atileGraphicColoredTitle2X1\x18\x04\x20\x01(\x0b2\r.TileTempla\
    teR\x1atileGraphicColoredTitle2X1\x12Q\n\x1ctileGraphicUpperLeftTitle2X1\
    \x18\x05\x20\x01(\x0b2\r.TileTemplateR\x1ctileGraphicUpperLeftTitle2X1\
    \x12U\n\x1etileDetailsReflectedGraphic2X2\x18\x06\x20\x01(\x0b2\r.TileTe\
    mplateR\x1etileDetailsReflectedGraphic2X2\x129\n\x10tileFourBlock4X2\x18\
    \x07\x20\x01(\x0b2\r.TileTemplateR\x10tileFourBlock4X2\x12F\n\x13contain\
    erWithBanner\x18\x08\x20\x01(\x0b2\x14.ContainerWithBannerR\x13container\
    WithBanner\x121\n\x0cdealOfTheDay\x18\t\x20\x01(\x0b2\r.DealOfTheDayR\
    \x0cdealOfTheDay\x12M\n\x1atileGraphicColoredTitle4X2\x18\n\x20\x01(\x0b\
    2\r.TileTemplateR\x1atileGraphicColoredTitle4X2\x12U\n\x18editorialSerie\
    sContainer\x18\x0b\x20\x01(\x0b2\x19.EditorialSeriesContainerR\x18editor\
    ialSeriesContainer\x12U\n\x18recommendationsContainer\x18\x0c\x20\x01(\
    \x0b2\x19.RecommendationsContainerR\x18recommendationsContainer\x12+\n\n\
    nextBanner\x18\r\x20\x01(\x0b2\x0b.NextBannerR\nnextBanner\"\\\n\x0cTile\
    Template\x12&\n\x0ecolorThemeArgb\x18\x01\x20\x01(\tR\x0ecolorThemeArgb\
    \x12$\n\rcolorTextArgb\x18\x02\x20\x01(\tR\rcolorTextArgb\"d\n\x0cVideoS\
    nippet\x12\x1c\n\x05image\x18\x01\x20\x03(\x0b2\x06.ImageR\x05image\x12\
    \x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x20\n\x0bdescription\
    \x18\x03\x20\x01(\tR\x0bdescription\"5\n\x07Warning\x12*\n\x10localizedM\
    essage\x18\x01\x20\x01(\tR\x10localizedMessage\"\x81\x01\n\x0cAlbumDetai\
    ls\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12'\n\x07details\x18\
    \x02\x20\x01(\x0b2\r.MusicDetailsR\x07details\x124\n\rdisplayArtist\x18\
    \x03\x20\x01(\x0b2\x0e.ArtistDetailsR\rdisplayArtist\"\xaa\x01\n\nDepend\
    ency\x12\x20\n\x0bpackageName\x18\x01\x20\x01(\tR\x0bpackageName\x12&\n\
    \x0eminVersionCode\x18\x02\x20\x01(\x05R\x0eminVersionCode\x12(\n\x0fver\
    sionCodeMask\x18\x03\x20\x01(\x05R\x0fversionCodeMask\x12(\n\x0fskipPerm\
    issions\x18\x04\x20\x01(\x08R\x0fskipPermissions\"\xa7\x01\n\x0eInstallD\
    etails\x12(\n\x0finstallLocation\x18\x01\x20\x01(\x05R\x0finstallLocatio\
    n\x12\x12\n\x04size\x18\x02\x20\x01(\x03R\x04size\x12+\n\ndependency\x18\
    \x03\x20\x01(\x0b2\x0b.DependencyR\ndependency\x12*\n\x10targetSdkVersio\
    n\x18\x04\x20\x01(\x05R\x10targetSdkVersion\"\xa7\n\n\nAppDetails\x12$\n\
    \rdeveloperName\x18\x01\x20\x01(\tR\rdeveloperName\x12.\n\x12majorVersio\
    nNumber\x18\x02\x20\x01(\x05R\x12majorVersionNumber\x12\x20\n\x0bversion\
    Code\x18\x03\x20\x01(\x05R\x0bversionCode\x12$\n\rversionString\x18\x04\
    \x20\x01(\tR\rversionString\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05ti\
    tle\x12\x20\n\x0bappCategory\x18\x07\x20\x03(\tR\x0bappCategory\x12$\n\r\
    contentRating\x18\x08\x20\x01(\x05R\rcontentRating\x12*\n\x10installatio\
    nSize\x18\t\x20\x01(\x03R\x10installationSize\x12\x1e\n\npermission\x18\
    \n\x20\x03(\tR\npermission\x12&\n\x0edeveloperEmail\x18\x0b\x20\x01(\tR\
    \x0edeveloperEmail\x12*\n\x10developerWebsite\x18\x0c\x20\x01(\tR\x10dev\
    eloperWebsite\x12\"\n\x0cnumDownloads\x18\r\x20\x01(\tR\x0cnumDownloads\
    \x12\x20\n\x0bpackageName\x18\x0e\x20\x01(\tR\x0bpackageName\x12,\n\x11r\
    ecentChangesHtml\x18\x0f\x20\x01(\tR\x11recentChangesHtml\x12\x1e\n\nupl\
    oadDate\x18\x10\x20\x01(\tR\nuploadDate\x12!\n\x04file\x18\x11\x20\x03(\
    \x0b2\r.FileMetadataR\x04file\x12\x18\n\x07appType\x18\x12\x20\x01(\tR\
    \x07appType\x12(\n\x0fcertificateHash\x18\x13\x20\x03(\tR\x0fcertificate\
    Hash\x12(\n\x0fvariesByAccount\x18\x15\x20\x01(\x08R\x0fvariesByAccount\
    \x127\n\x0ecertificateSet\x18\x16\x20\x03(\x0b2\x0f.CertificateSetR\x0ec\
    ertificateSet\x12d\n-autoAcquireFreeAppIfHigherVersionAvailableTag\x18\
    \x17\x20\x03(\tR-autoAcquireFreeAppIfHigherVersionAvailableTag\x12\x20\n\
    \x0bdeclaresIab\x18\x18\x20\x01(\x08R\x0bdeclaresIab\x12\x18\n\x07splitI\
    d\x18\x19\x20\x03(\tR\x07splitId\x12(\n\x0fgamepadRequired\x18\x1a\x20\
    \x01(\x08R\x0fgamepadRequired\x12*\n\x10externallyHosted\x18\x1b\x20\x01\
    (\x08R\x10externallyHosted\x122\n\x14everExternallyHosted\x18\x1c\x20\
    \x01(\x08R\x14everExternallyHosted\x12\"\n\x0cinstallNotes\x18\x1e\x20\
    \x01(\tR\x0cinstallNotes\x12(\n\x0finstallLocation\x18\x1f\x20\x01(\x05R\
    \x0finstallLocation\x12*\n\x10targetSdkVersion\x18\x20\x20\x01(\x05R\x10\
    targetSdkVersion\x12@\n\x1bhasPreregistrationPromoCode\x18!\x20\x01(\tR\
    \x1bhasPreregistrationPromoCode\x127\n\x0einstallDetails\x18\"\x20\x01(\
    \x0b2\x0f.InstallDetailsR\x0einstallDetails\":\n\x0eCertificateSet\x12(\
    \n\x0fcertificateHash\x18\x01\x20\x03(\tR\x0fcertificateHash\"Q\n\rAppPe\
    rmission\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12.\n\x12permissio\
    nRequired\x18\x02\x20\x01(\x08R\x12permissionRequired\"\x7f\n\rArtistDet\
    ails\x12\x1e\n\ndetailsUrl\x18\x01\x20\x01(\tR\ndetailsUrl\x12\x12\n\x04\
    name\x18\x02\x20\x01(\tR\x04name\x12:\n\rexternalLinks\x18\x03\x20\x01(\
    \x0b2\x14.ArtistExternalLinksR\rexternalLinks\"\x97\x01\n\x13ArtistExter\
    nalLinks\x12\x1e\n\nwebsiteUrl\x18\x01\x20\x03(\tR\nwebsiteUrl\x122\n\
    \x14googlePlusProfileUrl\x18\x02\x20\x01(\tR\x14googlePlusProfileUrl\x12\
    ,\n\x11youtubeChannelUrl\x18\x03\x20\x01(\tR\x11youtubeChannelUrl\"\xef\
    \x04\n\x0fDocumentDetails\x12+\n\nappDetails\x18\x01\x20\x01(\x0b2\x0b.A\
    ppDetailsR\nappDetails\x121\n\x0calbumDetails\x18\x02\x20\x01(\x0b2\r.Al\
    bumDetailsR\x0calbumDetails\x124\n\rartistDetails\x18\x03\x20\x01(\x0b2\
    \x0e.ArtistDetailsR\rartistDetails\x12.\n\x0bsongDetails\x18\x04\x20\x01\
    (\x0b2\x0c.SongDetailsR\x0bsongDetails\x12.\n\x0bbookDetails\x18\x05\x20\
    \x01(\x0b2\x0c.BookDetailsR\x0bbookDetails\x121\n\x0cvideoDetails\x18\
    \x06\x20\x01(\x0b2\r.VideoDetailsR\x0cvideoDetails\x12F\n\x13subscriptio\
    nDetails\x18\x07\x20\x01(\x0b2\x14.SubscriptionDetailsR\x13subscriptionD\
    etails\x12:\n\x0fmagazineDetails\x18\x08\x20\x01(\x0b2\x10.MagazineDetai\
    lsR\x0fmagazineDetails\x124\n\rtvShowDetails\x18\t\x20\x01(\x0b2\x0e.TvS\
    howDetailsR\rtvShowDetails\x12:\n\x0ftvSeasonDetails\x18\n\x20\x01(\x0b2\
    \x10.TvSeasonDetailsR\x0ftvSeasonDetails\x12=\n\x10tvEpisodeDetails\x18\
    \x0b\x20\x01(\x0b2\x11.TvEpisodeDetailsR\x10tvEpisodeDetails\"L\n\x0cPat\
    chDetails\x12(\n\x0fbaseVersionCode\x18\x01\x20\x01(\x05R\x0fbaseVersion\
    Code\x12\x12\n\x04size\x18\x02\x20\x01(\x03R\x04size\"\xd5\x01\n\x0cFile\
    Metadata\x12\x1a\n\x08fileType\x18\x01\x20\x01(\x05R\x08fileType\x12\x20\
    \n\x0bversionCode\x18\x02\x20\x01(\x05R\x0bversionCode\x12\x12\n\x04size\
    \x18\x03\x20\x01(\x03R\x04size\x12\x18\n\x07splitId\x18\x04\x20\x01(\tR\
    \x07splitId\x12&\n\x0ecompressedSize\x18\x05\x20\x01(\x03R\x0ecompressed\
    Size\x121\n\x0cpatchDetails\x18\x06\x20\x03(\x0b2\r.PatchDetailsR\x0cpat\
    chDetails\"\xf7\x01\n\x0fMagazineDetails\x12*\n\x10parentDetailsUrl\x18\
    \x01\x20\x01(\tR\x10parentDetailsUrl\x12L\n!deviceAvailabilityDescriptio\
    nHtml\x18\x02\x20\x01(\tR!deviceAvailabilityDescriptionHtml\x12&\n\x0eps\
    vDescription\x18\x03\x20\x01(\tR\x0epsvDescription\x12B\n\x1cdeliveryFre\
    quencyDescription\x18\x04\x20\x01(\tR\x1cdeliveryFrequencyDescription\"\
    \x98\x02\n\x0cMusicDetails\x12\x1c\n\tcensoring\x18\x01\x20\x01(\x05R\tc\
    ensoring\x12\x20\n\x0bdurationSec\x18\x02\x20\x01(\x05R\x0bdurationSec\
    \x120\n\x13originalReleaseDate\x18\x03\x20\x01(\tR\x13originalReleaseDat\
    e\x12\x14\n\x05label\x18\x04\x20\x01(\tR\x05label\x12&\n\x06artist\x18\
    \x05\x20\x03(\x0b2\x0e.ArtistDetailsR\x06artist\x12\x14\n\x05genre\x18\
    \x06\x20\x03(\tR\x05genre\x12\x20\n\x0breleaseDate\x18\x07\x20\x01(\tR\
    \x0breleaseDate\x12\x20\n\x0breleaseType\x18\x08\x20\x03(\x05R\x0breleas\
    eType\"a\n\x0bNewsDetails\x12*\n\x10parentDetailsUrl\x18\x01\x20\x01(\tR\
    \x10parentDetailsUrl\x12&\n\x0epsvDescription\x18\x03\x20\x01(\tR\x0epsv\
    Description\"\xfe\x01\n\x0bSongDetails\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\x12'\n\x07details\x18\x02\x20\x01(\x0b2\r.MusicDetailsR\x07\
    details\x12\x1c\n\talbumName\x18\x03\x20\x01(\tR\talbumName\x12\x20\n\
    \x0btrackNumber\x18\x04\x20\x01(\x05R\x0btrackNumber\x12\x1e\n\npreviewU\
    rl\x18\x05\x20\x01(\tR\npreviewUrl\x124\n\rdisplayArtist\x18\x06\x20\x01\
    (\x0b2\x0e.ArtistDetailsR\rdisplayArtist\x12\x1c\n\x05badge\x18\x07\x20\
    \x01(\x0b2\x06.BadgeR\x05badge\"E\n\x13SubscriptionDetails\x12.\n\x12sub\
    scriptionPeriod\x18\x01\x20\x01(\x05R\x12subscriptionPeriod\"\x99\x01\n\
    \x07Trailer\x12\x1c\n\ttrailerId\x18\x01\x20\x01(\tR\ttrailerId\x12\x14\
    \n\x05title\x18\x02\x20\x01(\tR\x05title\x12\"\n\x0cthumbnailUrl\x18\x03\
    \x20\x01(\tR\x0cthumbnailUrl\x12\x1a\n\x08watchUrl\x18\x04\x20\x01(\tR\
    \x08watchUrl\x12\x1a\n\x08duration\x18\x05\x20\x01(\tR\x08duration\"\x84\
    \x01\n\x10TvEpisodeDetails\x12*\n\x10parentDetailsUrl\x18\x01\x20\x01(\t\
    R\x10parentDetailsUrl\x12\"\n\x0cepisodeIndex\x18\x02\x20\x01(\x05R\x0ce\
    pisodeIndex\x12\x20\n\x0breleaseDate\x18\x03\x20\x01(\tR\x0breleaseDate\
    \"\xfb\x01\n\x0fTvSeasonDetails\x12*\n\x10parentDetailsUrl\x18\x01\x20\
    \x01(\tR\x10parentDetailsUrl\x12\x20\n\x0bseasonIndex\x18\x02\x20\x01(\
    \x05R\x0bseasonIndex\x12\x20\n\x0breleaseDate\x18\x03\x20\x01(\tR\x0brel\
    easeDate\x12\x20\n\x0bbroadcaster\x18\x04\x20\x01(\tR\x0bbroadcaster\x12\
    \"\n\x0cepisodeCount\x18\x05\x20\x01(\x05R\x0cepisodeCount\x122\n\x14exp\
    ectedEpisodeCount\x18\x06\x20\x01(\x05R\x14expectedEpisodeCount\"\x8b\
    \x01\n\rTvShowDetails\x12\x20\n\x0bseasonCount\x18\x01\x20\x01(\x05R\x0b\
    seasonCount\x12\x1c\n\tstartYear\x18\x02\x20\x01(\x05R\tstartYear\x12\
    \x18\n\x07endYear\x18\x03\x20\x01(\x05R\x07endYear\x12\x20\n\x0bbroadcas\
    ter\x18\x04\x20\x01(\tR\x0bbroadcaster\"Y\n\x0bVideoCredit\x12\x1e\n\ncr\
    editType\x18\x01\x20\x01(\x05R\ncreditType\x12\x16\n\x06credit\x18\x02\
    \x20\x01(\tR\x06credit\x12\x12\n\x04name\x18\x03\x20\x03(\tR\x04name\"\
    \x86\x03\n\x0cVideoDetails\x12$\n\x06credit\x18\x01\x20\x03(\x0b2\x0c.Vi\
    deoCreditR\x06credit\x12\x1a\n\x08duration\x18\x02\x20\x01(\tR\x08durati\
    on\x12\x20\n\x0breleaseDate\x18\x03\x20\x01(\tR\x0breleaseDate\x12$\n\rc\
    ontentRating\x18\x04\x20\x01(\tR\rcontentRating\x12\x14\n\x05likes\x18\
    \x05\x20\x01(\x03R\x05likes\x12\x1a\n\x08dislikes\x18\x06\x20\x01(\x03R\
    \x08dislikes\x12\x14\n\x05genre\x18\x07\x20\x03(\tR\x05genre\x12\"\n\x07\
    trailer\x18\x08\x20\x03(\x0b2\x08.TrailerR\x07trailer\x120\n\nrentalTerm\
    \x18\t\x20\x03(\x0b2\x10.VideoRentalTermR\nrentalTerm\x12$\n\raudioLangu\
    age\x18\n\x20\x03(\tR\raudioLanguage\x12(\n\x0fcaptionLanguage\x18\x0b\
    \x20\x03(\tR\x0fcaptionLanguage\"\xe0\x01\n\x0fVideoRentalTerm\x12\x1c\n\
    \tofferType\x18\x01\x20\x01(\x05R\tofferType\x12,\n\x11offerAbbreviation\
    \x18\x02\x20\x01(\tR\x11offerAbbreviation\x12\"\n\x0crentalHeader\x18\
    \x03\x20\x01(\tR\x0crentalHeader\x12)\n\x04term\x18\x04\x20\x03(\n2\x15.\
    VideoRentalTerm.TermR\x04term\x1a2\n\x04Term\x12\x16\n\x06header\x18\x05\
    \x20\x01(\tR\x06header\x12\x12\n\x04body\x18\x06\x20\x01(\tR\x04body\"\
    \x8a\x03\n\x06Bucket\x12\"\n\x08document\x18\x01\x20\x03(\x0b2\x06.DocV1\
    R\x08document\x12\x20\n\x0bmultiCorpus\x18\x02\x20\x01(\x08R\x0bmultiCor\
    pus\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x18\n\x07iconUrl\
    \x18\x04\x20\x01(\tR\x07iconUrl\x12(\n\x0ffullContentsUrl\x18\x05\x20\
    \x01(\tR\x0ffullContentsUrl\x12\x1c\n\trelevance\x18\x06\x20\x01(\x01R\t\
    relevance\x12*\n\x10estimatedResults\x18\x07\x20\x01(\x03R\x10estimatedR\
    esults\x12(\n\x0fanalyticsCookie\x18\x08\x20\x01(\tR\x0fanalyticsCookie\
    \x120\n\x13fullContentsListUrl\x18\t\x20\x01(\tR\x13fullContentsListUrl\
    \x12\x20\n\x0bnextPageUrl\x18\n\x20\x01(\tR\x0bnextPageUrl\x12\x18\n\x07\
    ordered\x18\x0b\x20\x01(\x08R\x07ordered\"I\n\x0cListResponse\x12\x1f\n\
    \x06bucket\x18\x01\x20\x03(\x0b2\x07.BucketR\x06bucket\x12\x18\n\x03doc\
    \x18\x02\x20\x03(\x0b2\x06.DocV2R\x03doc\"\xee\x04\n\x05DocV1\x12'\n\tfi\
    nskyDoc\x18\x01\x20\x01(\x0b2\t.DocumentR\tfinskyDoc\x12\x14\n\x05docid\
    \x18\x02\x20\x01(\tR\x05docid\x12\x1e\n\ndetailsUrl\x18\x03\x20\x01(\tR\
    \ndetailsUrl\x12\x1e\n\nreviewsUrl\x18\x04\x20\x01(\tR\nreviewsUrl\x12&\
    \n\x0erelatedListUrl\x18\x05\x20\x01(\tR\x0erelatedListUrl\x12$\n\rmoreB\
    yListUrl\x18\x06\x20\x01(\tR\rmoreByListUrl\x12\x1a\n\x08shareUrl\x18\
    \x07\x20\x01(\tR\x08shareUrl\x12\x18\n\x07creator\x18\x08\x20\x01(\tR\
    \x07creator\x12*\n\x07details\x18\t\x20\x01(\x0b2\x10.DocumentDetailsR\
    \x07details\x12(\n\x0fdescriptionHtml\x18\n\x20\x01(\tR\x0fdescriptionHt\
    ml\x12*\n\x10relatedBrowseUrl\x18\x0b\x20\x01(\tR\x10relatedBrowseUrl\
    \x12(\n\x0fmoreByBrowseUrl\x18\x0c\x20\x01(\tR\x0fmoreByBrowseUrl\x12$\n\
    \rrelatedHeader\x18\r\x20\x01(\tR\rrelatedHeader\x12\"\n\x0cmoreByHeader\
    \x18\x0e\x20\x01(\tR\x0cmoreByHeader\x12\x14\n\x05title\x18\x0f\x20\x01(\
    \tR\x05title\x12.\n\x0bplusOneData\x18\x10\x20\x01(\x0b2\x0c.PlusOneData\
    R\x0bplusOneData\x12&\n\x0ewarningMessage\x18\x11\x20\x01(\tR\x0ewarning\
    Message\"\xdd\n\n\x0bAnnotations\x128\n\x0esectionRelated\x18\x01\x20\
    \x01(\x0b2\x10.SectionMetadataR\x0esectionRelated\x126\n\rsectionMoreBy\
    \x18\x02\x20\x01(\x0b2\x10.SectionMetadataR\rsectionMoreBy\x12.\n\x0bplu\
    sOneData\x18\x03\x20\x01(\x0b2\x0c.PlusOneDataR\x0bplusOneData\x12\"\n\
    \x07warning\x18\x04\x20\x03(\x0b2\x08.WarningR\x07warning\x12>\n\x11sect\
    ionBodyOfWork\x18\x05\x20\x01(\x0b2\x10.SectionMetadataR\x11sectionBodyO\
    fWork\x12@\n\x12sectionCoreContent\x18\x06\x20\x01(\x0b2\x10.SectionMeta\
    dataR\x12sectionCoreContent\x12%\n\x08template\x18\x07\x20\x01(\x0b2\t.T\
    emplateR\x08template\x120\n\x0fbadgeForCreator\x18\x08\x20\x03(\x0b2\x06\
    .BadgeR\x0fbadgeForCreator\x12(\n\x0bbadgeForDoc\x18\t\x20\x03(\x0b2\x06\
    .BadgeR\x0bbadgeForDoc\x12\x19\n\x04link\x18\n\x20\x01(\x0b2\x05.LinkR\
    \x04link\x12<\n\x10sectionCrossSell\x18\x0b\x20\x01(\x0b2\x10.SectionMet\
    adataR\x10sectionCrossSell\x12F\n\x15sectionRelatedDocType\x18\x0c\x20\
    \x01(\x0b2\x10.SectionMetadataR\x15sectionRelatedDocType\x12.\n\x0bpromo\
    tedDoc\x18\r\x20\x03(\x0b2\x0c.PromotedDocR\x0bpromotedDoc\x12\x1c\n\tof\
    ferNote\x18\x0e\x20\x01(\tR\tofferNote\x12*\n\x0csubscription\x18\x10\
    \x20\x03(\x0b2\x06.DocV2R\x0csubscription\x128\n\x0eoBSOLETEReason\x18\
    \x11\x20\x01(\x0b2\x10.OBSOLETE_ReasonR\x0eoBSOLETEReason\x12*\n\x10priv\
    acyPolicyUrl\x18\x12\x20\x01(\tR\x10privacyPolicyUrl\x12@\n\x11suggestio\
    nReasons\x18\x13\x20\x01(\x0b2\x12.SuggestionReasonsR\x11suggestionReaso\
    ns\x12F\n\x19optimalDeviceClassWarning\x18\x14\x20\x01(\x0b2\x08.Warning\
    R\x19optimalDeviceClassWarning\x12=\n\x11docBadgeContainer\x18\x15\x20\
    \x03(\x0b2\x0f.BadgeContainerR\x11docBadgeContainer\x12J\n\x17sectionSug\
    gestForRating\x18\x16\x20\x01(\x0b2\x10.SectionMetadataR\x17sectionSugge\
    stForRating\x12D\n\x14sectionRateAndReview\x18\x17\x20\x01(\x0b2\x10.Sec\
    tionMetadataR\x14sectionRateAndReview\x12L\n\x18sectionPurchaseCrossSell\
    \x18\x18\x20\x01(\x0b2\x10.SectionMetadataR\x18sectionPurchaseCrossSell\
    \x121\n\x0coverflowLink\x18\x19\x20\x03(\x0b2\r.OverflowLinkR\x0coverflo\
    wLink\x12&\n\ncreatorDoc\x18\x1a\x20\x01(\x0b2\x06.DocV2R\ncreatorDoc\"?\
    \n\x0cOverflowLink\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\
    \x19\n\x04link\x18\x02\x20\x01(\x0b2\x05.LinkR\x04link\"u\n\tReviewTip\
    \x12\x16\n\x06tipUrl\x18\x01\x20\x01(\tR\x06tipUrl\x12\x12\n\x04text\x18\
    \x02\x20\x01(\tR\x04text\x12\x1a\n\x08polarity\x18\x03\x20\x01(\x05R\x08\
    polarity\x12\x20\n\x0breviewCount\x18\x04\x20\x01(\x03R\x0breviewCount\"\
    \x91\n\n\x05DocV2\x12\x14\n\x05docid\x18\x01\x20\x01(\tR\x05docid\x12\"\
    \n\x0cbackendDocid\x18\x02\x20\x01(\tR\x0cbackendDocid\x12\x18\n\x07docT\
    ype\x18\x03\x20\x01(\x05R\x07docType\x12\x1c\n\tbackendId\x18\x04\x20\
    \x01(\x05R\tbackendId\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05title\
    \x12\x18\n\x07creator\x18\x06\x20\x01(\tR\x07creator\x12(\n\x0fdescripti\
    onHtml\x18\x07\x20\x01(\tR\x0fdescriptionHtml\x12\x1c\n\x05offer\x18\x08\
    \x20\x03(\x0b2\x06.OfferR\x05offer\x121\n\x0cavailability\x18\t\x20\x01(\
    \x0b2\r.AvailabilityR\x0cavailability\x12\x1c\n\x05image\x18\n\x20\x03(\
    \x0b2\x06.ImageR\x05image\x12\x1c\n\x05child\x18\x0b\x20\x03(\x0b2\x06.D\
    ocV2R\x05child\x12@\n\x11containerMetadata\x18\x0c\x20\x01(\x0b2\x12.Con\
    tainerMetadataR\x11containerMetadata\x12*\n\x07details\x18\r\x20\x01(\
    \x0b2\x10.DocumentDetailsR\x07details\x12:\n\x0faggregateRating\x18\x0e\
    \x20\x01(\x0b2\x10.AggregateRatingR\x0faggregateRating\x12.\n\x0bannotat\
    ions\x18\x0f\x20\x01(\x0b2\x0c.AnnotationsR\x0bannotations\x12\x1e\n\nde\
    tailsUrl\x18\x10\x20\x01(\tR\ndetailsUrl\x12\x1a\n\x08shareUrl\x18\x11\
    \x20\x01(\tR\x08shareUrl\x12\x1e\n\nreviewsUrl\x18\x12\x20\x01(\tR\nrevi\
    ewsUrl\x12\x1e\n\nbackendUrl\x18\x13\x20\x01(\tR\nbackendUrl\x12.\n\x12p\
    urchaseDetailsUrl\x18\x14\x20\x01(\tR\x12purchaseDetailsUrl\x12(\n\x0fde\
    tailsReusable\x18\x15\x20\x01(\x08R\x0fdetailsReusable\x12\x1a\n\x08subt\
    itle\x18\x16\x20\x01(\tR\x08subtitle\x12<\n\x19translatedDescriptionHtml\
    \x18\x17\x20\x01(\tR\x19translatedDescriptionHtml\x12*\n\x10serverLogsCo\
    okie\x18\x18\x20\x01(\x0cR\x10serverLogsCookie\x127\n\x0eproductDetails\
    \x18\x19\x20\x01(\x0b2\x0f.ProductDetailsR\x0eproductDetails\x12\x16\n\
    \x06mature\x18\x1a\x20\x01(\x08R\x06mature\x126\n\x16promotionalDescript\
    ion\x18\x1b\x20\x01(\tR\x16promotionalDescription\x12B\n\x1cavailabileFo\
    rPreregistration\x18\x1d\x20\x01(\x08R\x1cavailabileForPreregistration\
    \x12\x1c\n\x03tip\x18\x1e\x20\x03(\x0b2\n.ReviewTipR\x03tip\x12\x20\n\
    \x0bsnippetsUrl\x18\x1f\x20\x01(\tR\x0bsnippetsUrl\x12,\n\x11forceSharea\
    bility\x18\x20\x20\x01(\x08R\x11forceShareability\x12>\n\x1auseWishlistA\
    sPrimaryAction\x18!\x20\x01(\x08R\x1auseWishlistAsPrimaryAction\"X\n\x0e\
    ProductDetails\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x120\n\
    \x07section\x18\x02\x20\x03(\x0b2\x16.ProductDetailsSectionR\x07section\
    \"k\n\x15ProductDetailsSection\x12\x14\n\x05title\x18\x01\x20\x01(\tR\
    \x05title\x12<\n\x0bdescription\x18\x03\x20\x03(\x0b2\x1a.ProductDetails\
    DescriptionR\x0bdescription\"[\n\x19ProductDetailsDescription\x12\x1c\n\
    \x05image\x18\x01\x20\x01(\x0b2\x06.ImageR\x05image\x12\x20\n\x0bdescrip\
    tion\x18\x02\x20\x01(\tR\x0bdescription\"\xe9\x01\n\x17EncryptedSubscrib\
    erInfo\x12\x12\n\x04data\x18\x01\x20\x01(\tR\x04data\x12\"\n\x0cencrypte\
    dKey\x18\x02\x20\x01(\tR\x0cencryptedKey\x12\x1c\n\tsignature\x18\x03\
    \x20\x01(\tR\tsignature\x12\x1e\n\ninitVector\x18\x04\x20\x01(\tR\ninitV\
    ector\x12*\n\x10googleKeyVersion\x18\x05\x20\x01(\x05R\x10googleKeyVersi\
    on\x12,\n\x11carrierKeyVersion\x18\x06\x20\x01(\x05R\x11carrierKeyVersio\
    n\"\xc8\x05\n\x0cAvailability\x12\x20\n\x0brestriction\x18\x05\x20\x01(\
    \x05R\x0brestriction\x12\x1c\n\tofferType\x18\x06\x20\x01(\x05R\tofferTy\
    pe\x12\x19\n\x04rule\x18\x07\x20\x01(\x0b2\x05.RuleR\x04rule\x12z\n\x20p\
    erdeviceavailabilityrestriction\x18\t\x20\x03(\n2..Availability.PerDevic\
    eAvailabilityRestrictionR\x20perdeviceavailabilityrestriction\x12*\n\x10\
    availableIfOwned\x18\r\x20\x01(\x08R\x10availableIfOwned\x12\"\n\x07inst\
    all\x18\x0e\x20\x03(\x0b2\x08.InstallR\x07install\x125\n\nfilterInfo\x18\
    \x10\x20\x01(\x0b2\x15.FilterEvaluationInfoR\nfilterInfo\x124\n\rownersh\
    ipInfo\x18\x11\x20\x01(\x0b2\x0e.OwnershipInfoR\rownershipInfo\x12F\n\
    \x13availabilityProblem\x18\x12\x20\x03(\x0b2\x14.AvailabilityProblemR\
    \x13availabilityProblem\x12\x16\n\x06hidden\x18\x15\x20\x01(\x08R\x06hid\
    den\x1a\xc3\x01\n\x20PerDeviceAvailabilityRestriction\x12\x1c\n\tandroid\
    Id\x18\n\x20\x01(\x06R\tandroidId\x12,\n\x11deviceRestriction\x18\x0b\
    \x20\x01(\x05R\x11deviceRestriction\x12\x1c\n\tchannelId\x18\x0c\x20\x01\
    (\x03R\tchannelId\x125\n\nfilterInfo\x18\x0f\x20\x01(\x0b2\x15.FilterEva\
    luationInfoR\nfilterInfo\"[\n\x13AvailabilityProblem\x12\x20\n\x0bproble\
    mType\x18\x01\x20\x01(\x05R\x0bproblemType\x12\"\n\x0cmissingValue\x18\
    \x02\x20\x03(\tR\x0cmissingValue\"O\n\x14FilterEvaluationInfo\x127\n\x0e\
    ruleEvaluation\x18\x01\x20\x03(\x0b2\x0f.RuleEvaluationR\x0eruleEvaluati\
    on\"\xb1\x03\n\x04Rule\x12\x16\n\x06negate\x18\x01\x20\x01(\x08R\x06nega\
    te\x12\x1a\n\x08operator\x18\x02\x20\x01(\x05R\x08operator\x12\x10\n\x03\
    key\x18\x03\x20\x01(\x05R\x03key\x12\x1c\n\tstringArg\x18\x04\x20\x03(\t\
    R\tstringArg\x12\x18\n\x07longArg\x18\x05\x20\x03(\x03R\x07longArg\x12\
    \x1c\n\tdoubleArg\x18\x06\x20\x03(\x01R\tdoubleArg\x12\x1f\n\x07subrule\
    \x18\x07\x20\x03(\x0b2\x05.RuleR\x07subrule\x12\"\n\x0cresponseCode\x18\
    \x08\x20\x01(\x05R\x0cresponseCode\x12\x18\n\x07comment\x18\t\x20\x01(\t\
    R\x07comment\x12$\n\rstringArgHash\x18\n\x20\x03(\x06R\rstringArgHash\
    \x12\x1a\n\x08constArg\x18\x0b\x20\x03(\x05R\x08constArg\x128\n\x17avail\
    abilityProblemType\x18\x0c\x20\x01(\x05R\x17availabilityProblemType\x122\
    \n\x14includeMissingValues\x18\r\x20\x01(\x08R\x14includeMissingValues\"\
    \xdb\x01\n\x0eRuleEvaluation\x12\x19\n\x04rule\x18\x01\x20\x01(\x0b2\x05\
    .RuleR\x04rule\x12,\n\x11actualStringValue\x18\x02\x20\x03(\tR\x11actual\
    StringValue\x12(\n\x0factualLongValue\x18\x03\x20\x03(\x03R\x0factualLon\
    gValue\x12(\n\x0factualBoolValue\x18\x04\x20\x03(\x08R\x0factualBoolValu\
    e\x12,\n\x11actualDoubleValue\x18\x05\x20\x03(\x01R\x11actualDoubleValue\
    \"b\n\x10GroupLicenseInfo\x12,\n\x11licensedOfferType\x18\x01\x20\x01(\
    \x05R\x11licensedOfferType\x12\x20\n\x0bgaiaGroupId\x18\x02\x20\x01(\x06\
    R\x0bgaiaGroupId\"8\n\x14LicensedDocumentInfo\x12\x20\n\x0bgaiaGroupId\
    \x18\x01\x20\x03(\x06R\x0bgaiaGroupId\"\xc1\x01\n\x11LibraryAppDetails\
    \x12(\n\x0fcertificateHash\x18\x02\x20\x01(\tR\x0fcertificateHash\x12>\n\
    \x1arefundTimeoutTimestampMsec\x18\x03\x20\x01(\x03R\x1arefundTimeoutTim\
    estampMsec\x12B\n\x1cpostDeliveryRefundWindowMsec\x18\x04\x20\x01(\x03R\
    \x1cpostDeliveryRefundWindowMsec\"c\n\x13LibraryInAppDetails\x12.\n\x12s\
    ignedPurchaseData\x18\x01\x20\x01(\tR\x12signedPurchaseData\x12\x1c\n\ts\
    ignature\x18\x02\x20\x01(\tR\tsignature\"\x82\x03\n\x0fLibraryMutation\
    \x12\x1c\n\x05docid\x18\x01\x20\x01(\x0b2\x06.DocidR\x05docid\x12\x1c\n\
    \tofferType\x18\x02\x20\x01(\x05R\tofferType\x12\"\n\x0cdocumentHash\x18\
    \x03\x20\x01(\x03R\x0cdocumentHash\x12\x18\n\x07deleted\x18\x04\x20\x01(\
    \x08R\x07deleted\x122\n\nappDetails\x18\x05\x20\x01(\x0b2\x12.LibraryApp\
    DetailsR\nappDetails\x12M\n\x13subscriptionDetails\x18\x06\x20\x01(\x0b2\
    \x1b.LibrarySubscriptionDetailsR\x13subscriptionDetails\x128\n\x0cinAppD\
    etails\x18\x07\x20\x01(\x0b2\x14.LibraryInAppDetailsR\x0cinAppDetails\
    \x128\n\x17validUntilTimestampMsec\x18\x08\x20\x01(\x03R\x17validUntilTi\
    mestampMsec\"\xd0\x02\n\x1aLibrarySubscriptionDetails\x128\n\x17initiati\
    onTimestampMsec\x18\x01\x20\x01(\x03R\x17initiationTimestampMsec\x12L\n!\
    deprecatedValidUntilTimestampMsec\x18\x02\x20\x01(\x03R!deprecatedValidU\
    ntilTimestampMsec\x12\"\n\x0cautoRenewing\x18\x03\x20\x01(\x08R\x0cautoR\
    enewing\x128\n\x17trialUntilTimestampMsec\x18\x04\x20\x01(\x03R\x17trial\
    UntilTimestampMsec\x12.\n\x12signedPurchaseData\x18\x05\x20\x01(\tR\x12s\
    ignedPurchaseData\x12\x1c\n\tsignature\x18\x06\x20\x01(\tR\tsignature\"\
    \xc7\x01\n\rLibraryUpdate\x12\x16\n\x06status\x18\x01\x20\x01(\x05R\x06s\
    tatus\x12\x16\n\x06corpus\x18\x02\x20\x01(\x05R\x06corpus\x12\x20\n\x0bs\
    erverToken\x18\x03\x20\x01(\x0cR\x0bserverToken\x12,\n\x08mutation\x18\
    \x04\x20\x03(\x0b2\x10.LibraryMutationR\x08mutation\x12\x18\n\x07hasMore\
    \x18\x05\x20\x01(\x08R\x07hasMore\x12\x1c\n\tlibraryId\x18\x06\x20\x01(\
    \tR\tlibraryId\"\xb0\x01\n\x12ClientLibraryState\x12\x16\n\x06corpus\x18\
    \x01\x20\x01(\x05R\x06corpus\x12\x20\n\x0bserverToken\x18\x02\x20\x01(\
    \x0cR\x0bserverToken\x12\x20\n\x0bhashCodeSum\x18\x03\x20\x01(\x03R\x0bh\
    ashCodeSum\x12\x20\n\x0blibrarySize\x18\x04\x20\x01(\x05R\x0blibrarySize\
    \x12\x1c\n\tlibraryId\x18\x05\x20\x01(\tR\tlibraryId\"T\n\x19LibraryRepl\
    icationRequest\x127\n\x0clibraryState\x18\x01\x20\x03(\x0b2\x13.ClientLi\
    braryStateR\x0clibraryState\"D\n\x1aLibraryReplicationResponse\x12&\n\
    \x06update\x18\x01\x20\x03(\x0b2\x0e.LibraryUpdateR\x06update\"\xa1\x01\
    \n\rClickLogEvent\x12\x1c\n\teventTime\x18\x01\x20\x01(\x03R\teventTime\
    \x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x16\n\x06listId\x18\x03\
    \x20\x01(\tR\x06listId\x12\x20\n\x0breferrerUrl\x18\x04\x20\x01(\tR\x0br\
    eferrerUrl\x12&\n\x0ereferrerListId\x18\x05\x20\x01(\tR\x0ereferrerListI\
    d\"\xaa\x01\n\x14ModifyLibraryRequest\x12\x1c\n\tlibraryId\x18\x01\x20\
    \x01(\tR\tlibraryId\x12\x20\n\x0bforAddDocid\x18\x02\x20\x03(\tR\x0bforA\
    ddDocid\x12(\n\x0fforRemovalDocid\x18\x03\x20\x03(\tR\x0fforRemovalDocid\
    \x12(\n\x0fforArchiveDocid\x18\x04\x20\x03(\tR\x0fforArchiveDocid\"M\n\
    \x15ModifyLibraryResponse\x124\n\rlibraryUpdate\x18\x01\x20\x01(\x0b2\
    \x0e.LibraryUpdateR\rlibraryUpdate\"X\n\x1aAndroidAppNotificationData\
    \x12\x20\n\x0bversionCode\x18\x01\x20\x01(\x05R\x0bversionCode\x12\x18\n\
    \x07assetId\x18\x02\x20\x01(\tR\x07assetId\"s\n\x15InAppNotificationData\
    \x12(\n\x0fcheckoutOrderId\x18\x01\x20\x01(\tR\x0fcheckoutOrderId\x120\n\
    \x13inAppNotificationId\x18\x02\x20\x01(\tR\x13inAppNotificationId\"J\n\
    \x10LibraryDirtyData\x12\x18\n\x07backend\x18\x01\x20\x01(\x05R\x07backe\
    nd\x12\x1c\n\tlibraryId\x18\x02\x20\x01(\tR\tlibraryId\"\xf3\x05\n\x0cNo\
    tification\x12*\n\x10notificationType\x18\x01\x20\x01(\x05R\x10notificat\
    ionType\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\ttimestamp\x12\x1c\n\
    \x05docid\x18\x04\x20\x01(\x0b2\x06.DocidR\x05docid\x12\x1a\n\x08docTitl\
    e\x18\x05\x20\x01(\tR\x08docTitle\x12\x1c\n\tuserEmail\x18\x06\x20\x01(\
    \tR\tuserEmail\x125\n\x07appData\x18\x07\x20\x01(\x0b2\x1b.AndroidAppNot\
    ificationDataR\x07appData\x12A\n\x0fappDeliveryData\x18\x08\x20\x01(\x0b\
    2\x17.AndroidAppDeliveryDataR\x0fappDeliveryData\x12F\n\x13purchaseRemov\
    alData\x18\t\x20\x01(\x0b2\x14.PurchaseRemovalDataR\x13purchaseRemovalDa\
    ta\x12I\n\x14userNotificationData\x18\n\x20\x01(\x0b2\x15.UserNotificati\
    onDataR\x14userNotificationData\x12L\n\x15inAppNotificationData\x18\x0b\
    \x20\x01(\x0b2\x16.InAppNotificationDataR\x15inAppNotificationData\x12I\
    \n\x14purchaseDeclinedData\x18\x0c\x20\x01(\x0b2\x15.PurchaseDeclinedDat\
    aR\x14purchaseDeclinedData\x12&\n\x0enotificationId\x18\r\x20\x01(\tR\
    \x0enotificationId\x124\n\rlibraryUpdate\x18\x0e\x20\x01(\x0b2\x0e.Libra\
    ryUpdateR\rlibraryUpdate\x12=\n\x10libraryDirtyData\x18\x0f\x20\x01(\x0b\
    2\x11.LibraryDirtyDataR\x10libraryDirtyData\"Z\n\x14PurchaseDeclinedData\
    \x12\x16\n\x06reason\x18\x01\x20\x01(\x05R\x06reason\x12*\n\x10showNotif\
    ication\x18\x02\x20\x01(\x08R\x10showNotification\"3\n\x13PurchaseRemova\
    lData\x12\x1c\n\tmalicious\x18\x01\x20\x01(\x08R\tmalicious\"\xd2\x01\n\
    \x14UserNotificationData\x12,\n\x11notificationTitle\x18\x01\x20\x01(\tR\
    \x11notificationTitle\x12*\n\x10notificationText\x18\x02\x20\x01(\tR\x10\
    notificationText\x12\x1e\n\ntickerText\x18\x03\x20\x01(\tR\ntickerText\
    \x12\x20\n\x0bdialogTitle\x18\x04\x20\x01(\tR\x0bdialogTitle\x12\x1e\n\n\
    dialogText\x18\x05\x20\x01(\tR\ndialogText\"\xc4\x05\n\rOwnershipInfo\
    \x128\n\x17initiationTimestampMsec\x18\x01\x20\x01(\x03R\x17initiationTi\
    mestampMsec\x128\n\x17validUntilTimestampMsec\x18\x02\x20\x01(\x03R\x17v\
    alidUntilTimestampMsec\x12\"\n\x0cautoRenewing\x18\x03\x20\x01(\x08R\x0c\
    autoRenewing\x12>\n\x1arefundTimeoutTimestampMsec\x18\x04\x20\x01(\x03R\
    \x1arefundTimeoutTimestampMsec\x12B\n\x1cpostDeliveryRefundWindowMsec\
    \x18\x05\x20\x01(\x03R\x1cpostDeliveryRefundWindowMsec\x12A\n\x15develop\
    erPurchaseInfo\x18\x06\x20\x01(\x0b2\x0b.SignedDataR\x15developerPurchas\
    eInfo\x12\x1e\n\npreordered\x18\x07\x20\x01(\x08R\npreordered\x12\x16\n\
    \x06hidden\x18\x08\x20\x01(\x08R\x06hidden\x12.\n\x0brentalTerms\x18\t\
    \x20\x01(\x0b2\x0c.RentalTermsR\x0brentalTerms\x12=\n\x10groupLicenseInf\
    o\x18\n\x20\x01(\x0b2\x11.GroupLicenseInfoR\x10groupLicenseInfo\x12I\n\
    \x14licensedDocumentInfo\x18\x0b\x20\x01(\x0b2\x15.LicensedDocumentInfoR\
    \x14licensedDocumentInfo\x12\x1a\n\x08quantity\x18\x0c\x20\x01(\x05R\x08\
    quantity\x12F\n\x1elibraryExpirationTimestampMsec\x18\x0e\x20\x01(\x03R\
    \x1elibraryExpirationTimestampMsec\"a\n\x07AppData\x12\x18\n\x07version\
    \x18\x01\x20\x01(\x05R\x07version\x12\x1e\n\noldVersion\x18\x02\x20\x01(\
    \x05R\noldVersion\x12\x1c\n\tsystemApp\x18\x03\x20\x01(\x08R\tsystemApp\
    \"\xe7\x03\n\x1ePlayStoreBackgroundActionEvent\x12\x12\n\x04type\x18\x01\
    \x20\x01(\x05R\x04type\x12\x1a\n\x08document\x18\x02\x20\x01(\tR\x08docu\
    ment\x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12\x1c\n\terrorC\
    ode\x18\x04\x20\x01(\x05R\terrorCode\x12$\n\rexceptionType\x18\x05\x20\
    \x01(\tR\rexceptionType\x12*\n\x10serverLogsCookie\x18\x06\x20\x01(\x0cR\
    \x10serverLogsCookie\x12\x1c\n\tofferType\x18\x07\x20\x01(\x05R\tofferTy\
    pe\x12\x20\n\x0bfromSetting\x18\x08\x20\x01(\x05R\x0bfromSetting\x12\x1c\
    \n\ttoSetting\x18\t\x20\x01(\x05R\ttoSetting\x127\n\x0bsessionInfo\x18\n\
    \x20\x01(\x0b2\x15.PlayStoreSessionDataR\x0bsessionInfo\x12\"\n\x07appDa\
    ta\x18\x0b\x20\x01(\x0b2\x08.AppDataR\x07appData\x12(\n\x0fserverLatency\
    Ms\x18\x0c\x20\x01(\x03R\x0fserverLatencyMs\x12(\n\x0fclientLatencyMs\
    \x18\r\x20\x01(\x03R\x0fclientLatencyMs\"L\n\x13PlayStoreClickEvent\x125\
    \n\x0belementPath\x18\x01\x20\x03(\x0b2\x13.PlayStoreUiElementR\x0beleme\
    ntPath\"^\n\x16PlayStoreDeepLinkEvent\x12\x20\n\x0bexternalUrl\x18\x01\
    \x20\x01(\tR\x0bexternalUrl\x12\"\n\x0cresolvedType\x18\x02\x20\x01(\x05\
    R\x0cresolvedType\"\x8c\x01\n\x18PlayStoreImpressionEvent\x12'\n\x04tree\
    \x18\x01\x20\x01(\x0b2\x13.PlayStoreUiElementR\x04tree\x127\n\x0creferre\
    rPath\x18\x02\x20\x03(\x0b2\x13.PlayStoreUiElementR\x0creferrerPath\x12\
    \x0e\n\x02id\x18\x03\x20\x01(\x03R\x02id\"\xab\x02\n\x11PlayStoreLogEven\
    t\x129\n\nimpression\x18\x01\x20\x01(\x0b2\x19.PlayStoreImpressionEventR\
    \nimpression\x12*\n\x05click\x18\x03\x20\x01(\x0b2\x14.PlayStoreClickEve\
    ntR\x05click\x12K\n\x10backgroundAction\x18\x04\x20\x01(\x0b2\x1f.PlaySt\
    oreBackgroundActionEventR\x10backgroundAction\x12-\n\x06search\x18\x05\
    \x20\x01(\x0b2\x15.PlayStoreSearchEventR\x06search\x123\n\x08deepLink\
    \x18\x06\x20\x01(\x0b2\x17.PlayStoreDeepLinkEventR\x08deepLink\"j\n\x14P\
    layStoreSearchEvent\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\x12\
    \x1a\n\x08queryUrl\x18\x02\x20\x01(\tR\x08queryUrl\x12\x20\n\x0breferrer\
    Url\x18\x03\x20\x01(\tR\x0breferrerUrl\"\xbc\x05\n\x14PlayStoreSessionDa\
    ta\x128\n\x17globalAutoUpdateEnabled\x18\x01\x20\x01(\x08R\x17globalAuto\
    UpdateEnabled\x12B\n\x1cglobalAutoUpdateOverWifiOnly\x18\x02\x20\x01(\
    \x08R\x1cglobalAutoUpdateOverWifiOnly\x12R\n$autoUpdateCleanupDialogNumT\
    imesShown\x18\x03\x20\x01(\x05R$autoUpdateCleanupDialogNumTimesShown\x12\
    \x20\n\x0bnetworkType\x18\x04\x20\x01(\x05R\x0bnetworkType\x12&\n\x0enet\
    workSubType\x18\x05\x20\x01(\x05R\x0enetworkSubType\x120\n\x13numAccount\
    sOnDevice\x18\x06\x20\x01(\x05R\x13numAccountsOnDevice\x12*\n\x10numInst\
    alledApps\x18\x07\x20\x01(\x05R\x10numInstalledApps\x12B\n\x1cnumAutoUpd\
    atingInstalledApps\x18\x08\x20\x01(\x05R\x1cnumAutoUpdatingInstalledApps\
    \x12H\n\x1fnumInstalledAppsNotAutoUpdating\x18\t\x20\x01(\x05R\x1fnumIns\
    talledAppsNotAutoUpdating\x12:\n\x18gaiaPasswordAuthOptedOut\x18\n\x20\
    \x01(\x08R\x18gaiaPasswordAuthOptedOut\x12.\n\x12contentFilterLevel\x18\
    \x0b\x20\x01(\x05R\x12contentFilterLevel\x120\n\x13allowUnknownSources\
    \x18\x0c\x20\x01(\x08R\x13allowUnknownSources\"\xc4\x01\n\x12PlayStoreUi\
    Element\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12*\n\x10server\
    LogsCookie\x18\x02\x20\x01(\x0cR\x10serverLogsCookie\x12C\n\x10clientLog\
    sCookie\x18\x03\x20\x01(\x0b2\x17.PlayStoreUiElementInfoR\x10clientLogsC\
    ookie\x12)\n\x05child\x18\x04\x20\x03(\x0b2\x13.PlayStoreUiElementR\x05c\
    hild\"\xe6\x01\n\x16PlayStoreUiElementInfo\x12N\n\x0einstrumentInfo\x18\
    \x01\x20\x01(\x0b2&.PlayStoreUiElementInfo.InstrumentInfoR\x0einstrument\
    Info\x12\x20\n\x0bserialDocid\x18\x02\x20\x01(\tR\x0bserialDocid\x1aZ\n\
    \x0eInstrumentInfo\x12*\n\x10instrumentFamily\x18\x01\x20\x01(\x05R\x10i\
    nstrumentFamily\x12\x1c\n\tisDefault\x18\x02\x20\x01(\x08R\tisDefault\"\
    \x85\x01\n\x0bPlusProfile\x12\x20\n\x0bdisplayName\x18\x02\x20\x01(\tR\
    \x0bdisplayName\x12(\n\x0fprofileImageUrl\x18\x04\x20\x01(\tR\x0fprofile\
    ImageUrl\x12*\n\x0cprofileImage\x18\x05\x20\x01(\x0b2\x06.ImageR\x0cprof\
    ileImage\"\x11\n\x0fPlusOneResponse\"E\n\x13PlusProfileResponse\x12.\n\
    \x0bplusProfile\x18\x01\x20\x01(\x0b2\x0c.PlusProfileR\x0bplusProfile\"\
    \xe1\x03\n\nClientCart\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\
    \x12&\n\x0eformattedPrice\x18\x02\x20\x01(\tR\x0eformattedPrice\x122\n\
    \x14purchaseContextToken\x18\x03\x20\x01(\tR\x14purchaseContextToken\x12\
    +\n\ninstrument\x18\x04\x20\x01(\x0b2\x0b.InstrumentR\ninstrument\x12.\n\
    \x12extendedDetailHtml\x18\x05\x20\x03(\tR\x12extendedDetailHtml\x12\x1e\
    \n\nfooterHtml\x18\x06\x20\x01(\tR\nfooterHtml\x128\n\x17addInstrumentPr\
    omptHtml\x18\x07\x20\x01(\tR\x17addInstrumentPromptHtml\x12\x1e\n\nbutto\
    nText\x18\x08\x20\x01(\tR\nbuttonText\x12H\n\x19completePurchaseChalleng\
    e\x18\t\x20\x01(\x0b2\n.ChallengeR\x19completePurchaseChallenge\x12\x20\
    \n\x0bpriceByline\x18\n\x20\x01(\tR\x0bpriceByline\x12\x1e\n\ndetailHtml\
    \x18\x0b\x20\x03(\tR\ndetailHtml\"\xa0\x02\n\x16CommitPurchaseResponse\
    \x127\n\x0epurchaseStatus\x18\x01\x20\x01(\x0b2\x0f.PurchaseStatusR\x0ep\
    urchaseStatus\x12(\n\tchallenge\x18\x02\x20\x01(\x0b2\n.ChallengeR\tchal\
    lenge\x124\n\rlibraryUpdate\x18\x03\x20\x03(\x0b2\x0e.LibraryUpdateR\rli\
    braryUpdate\x12A\n\x0fappDeliveryData\x18\x04\x20\x01(\x0b2\x17.AndroidA\
    ppDeliveryDataR\x0fappDeliveryData\x12*\n\x10serverLogsCookie\x18\x05\
    \x20\x01(\x0cR\x10serverLogsCookie\"\xff\x01\n\x17PreparePurchaseRespons\
    e\x127\n\x0epurchaseStatus\x18\x01\x20\x01(\x0b2\x0f.PurchaseStatusR\x0e\
    purchaseStatus\x12(\n\tchallenge\x18\x02\x20\x01(\x0b2\n.ChallengeR\tcha\
    llenge\x12\x1f\n\x04cart\x18\x03\x20\x01(\x0b2\x0b.ClientCartR\x04cart\
    \x124\n\rlibraryUpdate\x18\x04\x20\x03(\x0b2\x0e.LibraryUpdateR\rlibrary\
    Update\x12*\n\x10serverLogsCookie\x18\x05\x20\x01(\x0cR\x10serverLogsCoo\
    kie\"\x86\x01\n\x0ePurchaseStatus\x12\x1e\n\nstatusCode\x18\x01\x20\x01(\
    \x05R\nstatusCode\x12*\n\x10errorMessageHtml\x18\x02\x20\x01(\tR\x10erro\
    rMessageHtml\x12(\n\x0fpermissionError\x18\x03\x20\x01(\x05R\x0fpermissi\
    onError\"\x1e\n\x1cRateSuggestedContentResponse\"\xdd\x03\n\x0fAggregate\
    Rating\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\x1e\n\nstarRa\
    ting\x18\x02\x20\x01(\x02R\nstarRating\x12\"\n\x0cratingsCount\x18\x03\
    \x20\x01(\x04R\x0cratingsCount\x12&\n\x0eoneStarRatings\x18\x04\x20\x01(\
    \x04R\x0eoneStarRatings\x12&\n\x0etwoStarRatings\x18\x05\x20\x01(\x04R\
    \x0etwoStarRatings\x12*\n\x10threeStarRatings\x18\x06\x20\x01(\x04R\x10t\
    hreeStarRatings\x12(\n\x0ffourStarRatings\x18\x07\x20\x01(\x04R\x0ffourS\
    tarRatings\x12(\n\x0ffiveStarRatings\x18\x08\x20\x01(\x04R\x0ffiveStarRa\
    tings\x12$\n\rthumbsUpCount\x18\t\x20\x01(\x04R\rthumbsUpCount\x12(\n\
    \x0fthumbsDownCount\x18\n\x20\x01(\x04R\x0fthumbsDownCount\x12\"\n\x0cco\
    mmentCount\x18\x0b\x20\x01(\x04R\x0ccommentCount\x12.\n\x12bayesianMeanR\
    ating\x18\x0c\x20\x01(\x01R\x12bayesianMeanRating\"\x96\x01\n\x0eDirectP\
    urchase\x12\x1e\n\ndetailsUrl\x18\x01\x20\x01(\tR\ndetailsUrl\x12$\n\rpu\
    rchaseDocid\x18\x02\x20\x01(\tR\rpurchaseDocid\x12\x20\n\x0bparentDocid\
    \x18\x03\x20\x01(\tR\x0bparentDocid\x12\x1c\n\tofferType\x18\x04\x20\x01\
    (\x05R\tofferType\"Z\n\x0eRedeemGiftCard\x12\x20\n\x0bprefillCode\x18\
    \x01\x20\x01(\tR\x0bprefillCode\x12&\n\x0epartnerPayload\x18\x02\x20\x01\
    (\tR\x0epartnerPayload\"\x92\x03\n\x0cResolvedLink\x12\x1e\n\ndetailsUrl\
    \x18\x01\x20\x01(\tR\ndetailsUrl\x12\x1c\n\tbrowseUrl\x18\x02\x20\x01(\t\
    R\tbrowseUrl\x12\x1c\n\tsearchUrl\x18\x03\x20\x01(\tR\tsearchUrl\x127\n\
    \x0edirectPurchase\x18\x04\x20\x01(\x0b2\x0f.DirectPurchaseR\x0edirectPu\
    rchase\x12\x18\n\x07homeUrl\x18\x05\x20\x01(\tR\x07homeUrl\x127\n\x0ered\
    eemGiftCard\x18\x06\x20\x01(\x0b2\x0f.RedeemGiftCardR\x0eredeemGiftCard\
    \x12*\n\x10serverLogsCookie\x18\x07\x20\x01(\x0cR\x10serverLogsCookie\
    \x12\x1c\n\x05docid\x18\x08\x20\x01(\x0b2\x06.DocidR\x05docid\x12\x20\n\
    \x0bwishlistUrl\x18\t\x20\x01(\tR\x0bwishlistUrl\x12\x18\n\x07backend\
    \x18\n\x20\x01(\x05R\x07backend\x12\x14\n\x05query\x18\x0b\x20\x01(\tR\
    \x05query\"\xd9#\n\x07Payload\x121\n\x0clistResponse\x18\x01\x20\x01(\
    \x0b2\r.ListResponseR\x0clistResponse\x12:\n\x0fdetailsResponse\x18\x02\
    \x20\x01(\x0b2\x10.DetailsResponseR\x0fdetailsResponse\x127\n\x0ereviewR\
    esponse\x18\x03\x20\x01(\x0b2\x0f.ReviewResponseR\x0ereviewResponse\x12.\
    \n\x0bbuyResponse\x18\x04\x20\x01(\x0b2\x0c.BuyResponseR\x0bbuyResponse\
    \x127\n\x0esearchResponse\x18\x05\x20\x01(\x0b2\x0f.SearchResponseR\x0es\
    earchResponse\x12.\n\x0btocResponse\x18\x06\x20\x01(\x0b2\x0c.TocRespons\
    eR\x0btocResponse\x127\n\x0ebrowseResponse\x18\x07\x20\x01(\x0b2\x0f.Bro\
    wseResponseR\x0ebrowseResponse\x12O\n\x16purchaseStatusResponse\x18\x08\
    \x20\x01(\x0b2\x17.PurchaseStatusResponseR\x16purchaseStatusResponse\x12\
    U\n\x18updateInstrumentResponse\x18\t\x20\x01(\x0b2\x19.UpdateInstrument\
    ResponseR\x18updateInstrumentResponse\x12.\n\x0blogResponse\x18\n\x20\
    \x01(\x0b2\x0c.LogResponseR\x0blogResponse\x12R\n\x17checkInstrumentResp\
    onse\x18\x0b\x20\x01(\x0b2\x18.CheckInstrumentResponseR\x17checkInstrume\
    ntResponse\x12:\n\x0fplusOneResponse\x18\x0c\x20\x01(\x0b2\x10.PlusOneRe\
    sponseR\x0fplusOneResponse\x12F\n\x13flagContentResponse\x18\r\x20\x01(\
    \x0b2\x14.FlagContentResponseR\x13flagContentResponse\x12R\n\x17ackNotif\
    icationResponse\x18\x0e\x20\x01(\x0b2\x18.AckNotificationResponseR\x17ac\
    kNotificationResponse\x12^\n\x1binitiateAssociationResponse\x18\x0f\x20\
    \x01(\x0b2\x1c.InitiateAssociationResponseR\x1binitiateAssociationRespon\
    se\x12X\n\x19verifyAssociationResponse\x18\x10\x20\x01(\x0b2\x1a.VerifyA\
    ssociationResponseR\x19verifyAssociationResponse\x12[\n\x1alibraryReplic\
    ationResponse\x18\x11\x20\x01(\x0b2\x1b.LibraryReplicationResponseR\x1al\
    ibraryReplicationResponse\x127\n\x0erevokeResponse\x18\x12\x20\x01(\x0b2\
    \x0f.RevokeResponseR\x0erevokeResponse\x12F\n\x13bulkDetailsResponse\x18\
    \x13\x20\x01(\x0b2\x14.BulkDetailsResponseR\x13bulkDetailsResponse\x12?\
    \n\x13resolveLinkResponse\x18\x14\x20\x01(\x0b2\r.ResolvedLinkR\x13resol\
    veLinkResponse\x12=\n\x10deliveryResponse\x18\x15\x20\x01(\x0b2\x11.Deli\
    veryResponseR\x10deliveryResponse\x12@\n\x11acceptTosResponse\x18\x16\
    \x20\x01(\x0b2\x12.AcceptTosResponseR\x11acceptTosResponse\x12a\n\x1crat\
    eSuggestedContentResponse\x18\x17\x20\x01(\x0b2\x1d.RateSuggestedContent\
    ResponseR\x1crateSuggestedContentResponse\x12R\n\x17checkPromoOfferRespo\
    nse\x18\x18\x20\x01(\x0b2\x18.CheckPromoOfferResponseR\x17checkPromoOffe\
    rResponse\x12^\n\x1binstrumentSetupInfoResponse\x18\x19\x20\x01(\x0b2\
    \x1c.InstrumentSetupInfoResponseR\x1binstrumentSetupInfoResponse\x12O\n\
    \x16redeemGiftCardResponse\x18\x1a\x20\x01(\x0b2\x17.RedeemGiftCardRespo\
    nseR\x16redeemGiftCardResponse\x12L\n\x15modifyLibraryResponse\x18\x1b\
    \x20\x01(\x0b2\x16.ModifyLibraryResponseR\x15modifyLibraryResponse\x12[\
    \n\x1auploadDeviceConfigResponse\x18\x1c\x20\x01(\x0b2\x1b.UploadDeviceC\
    onfigResponseR\x1auploadDeviceConfigResponse\x12F\n\x13plusProfileRespon\
    se\x18\x1d\x20\x01(\x0b2\x14.PlusProfileResponseR\x13plusProfileResponse\
    \x12R\n\x17consumePurchaseResponse\x18\x1e\x20\x01(\x0b2\x18.ConsumePurc\
    haseResponseR\x17consumePurchaseResponse\x12O\n\x16billingProfileRespons\
    e\x18\x1f\x20\x01(\x0b2\x17.BillingProfileResponseR\x16billingProfileRes\
    ponse\x12R\n\x17preparePurchaseResponse\x18\x20\x20\x01(\x0b2\x18.Prepar\
    ePurchaseResponseR\x17preparePurchaseResponse\x12O\n\x16commitPurchaseRe\
    sponse\x18!\x20\x01(\x0b2\x17.CommitPurchaseResponseR\x16commitPurchaseR\
    esponse\x12L\n\x15debugSettingsResponse\x18\"\x20\x01(\x0b2\x16.DebugSet\
    tingsResponseR\x15debugSettingsResponse\x12L\n\x15checkIabPromoResponse\
    \x18#\x20\x01(\x0b2\x16.CheckIabPromoResponseR\x15checkIabPromoResponse\
    \x12a\n\x1cuserActivitySettingsResponse\x18$\x20\x01(\x0b2\x1d.UserActiv\
    itySettingsResponseR\x1cuserActivitySettingsResponse\x12[\n\x1arecordUse\
    rActivityResponse\x18%\x20\x01(\x0b2\x1b.RecordUserActivityResponseR\x1a\
    recordUserActivityResponse\x12C\n\x12redeemCodeResponse\x18&\x20\x01(\
    \x0b2\x13.RedeemCodeResponseR\x12redeemCodeResponse\x12C\n\x12selfUpdate\
    Response\x18'\x20\x01(\x0b2\x13.SelfUpdateResponseR\x12selfUpdateRespons\
    e\x12L\n\x15searchSuggestResponse\x18(\x20\x01(\x0b2\x16.searchSuggestRe\
    sponseR\x15searchSuggestResponse\x12|\n%getInitialInstrumentFlowStateRes\
    ponse\x18)\x20\x01(\x0b2&.GetInitialInstrumentFlowStateResponseR%getInit\
    ialInstrumentFlowStateResponse\x12U\n\x18createInstrumentResponse\x18*\
    \x20\x01(\x0b2\x19.CreateInstrumentResponseR\x18createInstrumentResponse\
    \x12@\n\x11challengeResponse\x18+\x20\x01(\x0b2\x12.ChallengeResponseR\
    \x11challengeResponse\x12\\\n\x1bbackupDeviceChoicesResponse\x18,\x20\
    \x01(\x0b2\x1a.BackDeviceChoicesResponseR\x1bbackupDeviceChoicesResponse\
    \x12d\n\x1dbackupDocumentChoicesResponse\x18-\x20\x01(\x0b2\x1e.BackupDo\
    cumentChoicesResponseR\x1dbackupDocumentChoicesResponse\x12F\n\x13earlyU\
    pdateResponse\x18.\x20\x01(\x0b2\x14.EarlyUpdateResponseR\x13earlyUpdate\
    Response\x12=\n\x10preloadsResponse\x18/\x20\x01(\x0b2\x11.PreloadsRespo\
    nseR\x10preloadsResponse\x12C\n\x12myAccountsResponse\x180\x20\x01(\x0b2\
    \x13.MyAccountsResponseR\x12myAccountsResponse\x12L\n\x15contentFilterRe\
    sponse\x181\x20\x01(\x0b2\x16.ContentFilterResponseR\x15contentFilterRes\
    ponse\x12F\n\x13experimentsResponse\x182\x20\x01(\x0b2\x14.ExperimentsRe\
    sponseR\x13experimentsResponse\x127\n\x0esurveyResponse\x183\x20\x01(\
    \x0b2\x0f.SurveyResponseR\x0esurveyResponse\x121\n\x0cpingResponse\x184\
    \x20\x01(\x0b2\r.PingResponseR\x0cpingResponse\x12X\n\x19updateUserSetti\
    ngResponse\x185\x20\x01(\x0b2\x1a.UpdateUserSettingResponseR\x19updateUs\
    erSettingResponse\x12R\n\x17getUserSettingsREsponse\x186\x20\x01(\x0b2\
    \x18.GetUserSettingsResponseR\x17getUserSettingsREsponse\x12[\n\x1agetSh\
    aringSettingsResponse\x188\x20\x01(\x0b2\x1b.GetSharingSettingsResponseR\
    \x1agetSharingSettingsResponse\x12d\n\x1dupdateSharingSettingsResponse\
    \x189\x20\x01(\x0b2\x1e.UpdateSharingSettingsResponseR\x1dupdateSharingS\
    ettingsResponse\x12O\n\x16reviewSnippetsResponse\x18:\x20\x01(\x0b2\x17.\
    ReviewSnippetsResponseR\x16reviewSnippetsResponse\x12a\n\x1cdocumentShar\
    ingStateResponse\x18;\x20\x01(\x0b2\x1d.DocumentSharingStateResponseR\
    \x1cdocumentSharingStateResponse\x12O\n\x16moduleDeliveryResponse\x18F\
    \x20\x01(\x0b2\x17.ModuleDeliveryResponseR\x16moduleDeliveryResponse\"\
    \x17\n\x15CheckIabPromoResponse\"\x1e\n\x1cUserActivitySettingsResponse\
    \"\x1c\n\x1aRecordUserActivityResponse\"\x14\n\x12RedeemCodeResponse\"\
    \x14\n\x12SelfUpdateResponse\"\x17\n\x15searchSuggestResponse\"'\n%GetIn\
    itialInstrumentFlowStateResponse\"\x1a\n\x18CreateInstrumentResponse\"\
    \x13\n\x11ChallengeResponse\"\x1b\n\x19BackDeviceChoicesResponse\"\x1f\n\
    \x1dBackupDocumentChoicesResponse\"\x15\n\x13EarlyUpdateResponse\"\x12\n\
    \x10PreloadsResponse\"\x14\n\x12MyAccountsResponse\"\x17\n\x15ContentFil\
    terResponse\"\x15\n\x13ExperimentsResponse\"\x10\n\x0eSurveyResponse\"\
    \x0e\n\x0cPingResponse\"\x1b\n\x19UpdateUserSettingResponse\"\x19\n\x17G\
    etUserSettingsResponse\"\x1c\n\x1aGetSharingSettingsResponse\"\x1f\n\x1d\
    UpdateSharingSettingsResponse\"\x18\n\x16ReviewSnippetsResponse\"\x1e\n\
    \x1cDocumentSharingStateResponse\"\x18\n\x16ModuleDeliveryResponse\"x\n\
    \x08PreFetch\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x1a\n\x08re\
    sponse\x18\x02\x20\x01(\x0cR\x08response\x12\x12\n\x04etag\x18\x03\x20\
    \x01(\tR\x04etag\x12\x10\n\x03ttl\x18\x04\x20\x01(\x03R\x03ttl\x12\x18\n\
    \x07softTtl\x18\x05\x20\x01(\x03R\x07softTtl\"\xf5\x01\n\x0fResponseWrap\
    per\x12\"\n\x07payload\x18\x01\x20\x01(\x0b2\x08.PayloadR\x07payload\x12\
    +\n\x08commands\x18\x02\x20\x01(\x0b2\x0f.ServerCommandsR\x08commands\
    \x12%\n\x08preFetch\x18\x03\x20\x03(\x0b2\t.PreFetchR\x08preFetch\x121\n\
    \x0cnotification\x18\x04\x20\x03(\x0b2\r.NotificationR\x0cnotification\
    \x127\n\x0eserverMetadata\x18\x05\x20\x01(\x0b2\x0f.ServerMetadataR\x0es\
    erverMetadata\"\x92\x01\n\x0eServerCommands\x12\x1e\n\nclearCache\x18\
    \x01\x20\x01(\x08R\nclearCache\x120\n\x13displayErrorMessage\x18\x02\x20\
    \x01(\tR\x13displayErrorMessage\x12.\n\x12logErrorStacktrace\x18\x03\x20\
    \x01(\tR\x12logErrorStacktrace\"6\n\x0eServerMetadata\x12$\n\rlatencyMil\
    lis\x18\x01\x20\x01(\x03R\rlatencyMillis\"[\n\x12GetReviewsResponse\x12\
    \x1f\n\x06review\x18\x01\x20\x03(\x0b2\x07.ReviewR\x06review\x12$\n\rmat\
    chingCount\x18\x02\x20\x01(\x03R\rmatchingCount\"\xf4\x03\n\x06Review\
    \x12\x1e\n\nauthorName\x18\x01\x20\x01(\tR\nauthorName\x12\x10\n\x03url\
    \x18\x02\x20\x01(\tR\x03url\x12\x16\n\x06source\x18\x03\x20\x01(\tR\x06s\
    ource\x12(\n\x0fdocumentVersion\x18\x04\x20\x01(\tR\x0fdocumentVersion\
    \x12$\n\rtimestampMsec\x18\x05\x20\x01(\x03R\rtimestampMsec\x12\x1e\n\ns\
    tarRating\x18\x06\x20\x01(\x05R\nstarRating\x12\x14\n\x05title\x18\x07\
    \x20\x01(\tR\x05title\x12\x18\n\x07comment\x18\x08\x20\x01(\tR\x07commen\
    t\x12\x1c\n\tcommentId\x18\t\x20\x01(\tR\tcommentId\x12\x1e\n\ndeviceNam\
    e\x18\x13\x20\x01(\tR\ndeviceName\x12\x1c\n\treplyText\x18\x1d\x20\x01(\
    \tR\treplyText\x12.\n\x12replyTimestampMsec\x18\x1e\x20\x01(\x03R\x12rep\
    lyTimestampMsec\x12.\n\x0bplusProfile\x18\x1f\x20\x01(\x0b2\x0c.PlusProf\
    ileR\x0bplusProfile\x12\x1e\n\x06author\x18!\x20\x01(\x0b2\x06.DocV2R\
    \x06author\x12$\n\tsentiment\x18\"\x20\x01(\x0b2\x06.ImageR\tsentiment\"\
    \x98\x01\n\x0eReviewResponse\x125\n\x0bgetResponse\x18\x01\x20\x01(\x0b2\
    \x13.GetReviewsResponseR\x0bgetResponse\x12\x20\n\x0bnextPageUrl\x18\x02\
    \x20\x01(\tR\x0bnextPageUrl\x12-\n\rupdatedReview\x18\x03\x20\x01(\x0b2\
    \x07.ReviewR\rupdatedReview\"F\n\x0eRevokeResponse\x124\n\rlibraryUpdate\
    \x18\x01\x20\x01(\x0b2\x0e.LibraryUpdateR\rlibraryUpdate\"\x97\x01\n\rRe\
    latedSearch\x12\x1c\n\tsearchUrl\x18\x01\x20\x01(\tR\tsearchUrl\x12\x16\
    \n\x06header\x18\x02\x20\x01(\tR\x06header\x12\x1c\n\tbackendId\x18\x03\
    \x20\x01(\x05R\tbackendId\x12\x18\n\x07docType\x18\x04\x20\x01(\x05R\x07\
    docType\x12\x18\n\x07current\x18\x05\x20\x01(\x08R\x07current\"\xa3\x02\
    \n\x0eSearchResponse\x12$\n\roriginalQuery\x18\x01\x20\x01(\tR\roriginal\
    Query\x12&\n\x0esuggestedQuery\x18\x02\x20\x01(\tR\x0esuggestedQuery\x12\
    &\n\x0eaggregateQuery\x18\x03\x20\x01(\x08R\x0eaggregateQuery\x12\x1f\n\
    \x06bucket\x18\x04\x20\x03(\x0b2\x07.BucketR\x06bucket\x12\x18\n\x03doc\
    \x18\x05\x20\x03(\x0b2\x06.DocV2R\x03doc\x124\n\rrelatedSearch\x18\x06\
    \x20\x03(\x0b2\x0e.RelatedSearchR\rrelatedSearch\x12*\n\x10serverLogsCoo\
    kie\x18\x07\x20\x01(\x0cR\x10serverLogsCookie\"\x86\x01\n\rBillingConfig\
    \x12I\n\x14carrierBillingConfig\x18\x01\x20\x01(\x0b2\x15.CarrierBilling\
    ConfigR\x14carrierBillingConfig\x12*\n\x10maxIabApiVersion\x18\x02\x20\
    \x01(\x05R\x10maxIabApiVersion\"\xfc\x02\n\x14CarrierBillingConfig\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01\
    (\tR\x04name\x12\x1e\n\napiVersion\x18\x03\x20\x01(\x05R\napiVersion\x12\
    (\n\x0fprovisioningUrl\x18\x04\x20\x01(\tR\x0fprovisioningUrl\x12&\n\x0e\
    credentialsUrl\x18\x05\x20\x01(\tR\x0ecredentialsUrl\x12\x20\n\x0btosReq\
    uired\x18\x06\x20\x01(\x08R\x0btosRequired\x12L\n!perTransactionCredenti\
    alsRequired\x18\x07\x20\x01(\x08R!perTransactionCredentialsRequired\x12^\
    \n*sendSubscriberIdWithCarrierBillingRequests\x18\x08\x20\x01(\x08R*send\
    SubscriberIdWithCarrierBillingRequests\"\xa6\x01\n\x0eCorpusMetadata\x12\
    \x18\n\x07backend\x18\x01\x20\x01(\x05R\x07backend\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12\x1e\n\nlandingUrl\x18\x03\x20\x01(\tR\nland\
    ingUrl\x12\x20\n\x0blibraryName\x18\x04\x20\x01(\tR\x0blibraryName\x12$\
    \n\rrecsWidgetUrl\x18\x06\x20\x01(\tR\rrecsWidgetUrl\"1\n\x0bExperiments\
    \x12\"\n\x0cexperimentId\x18\x01\x20\x03(\tR\x0cexperimentId\"L\n\x10Sel\
    fUpdateConfig\x128\n\x17latestClientVersionCode\x18\x01\x20\x01(\x05R\
    \x17latestClientVersionCode\"\xf0\x04\n\x0bTocResponse\x12'\n\x06corpus\
    \x18\x01\x20\x03(\x0b2\x0f.CorpusMetadataR\x06corpus\x122\n\x14tosVersio\
    nDeprecated\x18\x02\x20\x01(\x05R\x14tosVersionDeprecated\x12\x1e\n\ntos\
    Content\x18\x03\x20\x01(\tR\ntosContent\x12\x18\n\x07homeUrl\x18\x04\x20\
    \x01(\tR\x07homeUrl\x12.\n\x0bexperiments\x18\x05\x20\x01(\x0b2\x0c.Expe\
    rimentsR\x0bexperiments\x12F\n\x1etosCheckboxTextMarketingEmails\x18\x06\
    \x20\x01(\tR\x1etosCheckboxTextMarketingEmails\x12\x1a\n\x08tosToken\x18\
    \x07\x20\x01(\tR\x08tosToken\x121\n\x0cuserSettings\x18\x08\x20\x01(\x0b\
    2\r.UserSettingsR\x0cuserSettings\x12(\n\x0ficonOverrideUrl\x18\t\x20\
    \x01(\tR\x0ficonOverrideUrl\x12=\n\x10selfUpdateConfig\x18\n\x20\x01(\
    \x0b2\x11.SelfUpdateConfigR\x10selfUpdateConfig\x12>\n\x1arequiresUpload\
    DeviceConfig\x18\x0b\x20\x01(\x08R\x1arequiresUploadDeviceConfig\x124\n\
    \rbillingConfig\x18\x0c\x20\x01(\x0b2\x0e.BillingConfigR\rbillingConfig\
    \x12$\n\rrecsWidgetUrl\x18\r\x20\x01(\tR\rrecsWidgetUrl\"\\\n\x0cUserSet\
    tings\x12L\n!tosCheckboxMarketingEmailsOptedIn\x18\x01\x20\x01(\x08R!tos\
    CheckboxMarketingEmailsOptedIn\"\x13\n\x11AcceptTosResponse\"\xba\x01\n\
    \x19UploadDeviceConfigRequest\x12K\n\x13deviceConfiguration\x18\x01\x20\
    \x01(\x0b2\x19.DeviceConfigurationProtoR\x13deviceConfiguration\x12\"\n\
    \x0cmanufacturer\x18\x02\x20\x01(\tR\x0cmanufacturer\x12,\n\x11gcmRegist\
    rationId\x18\x03\x20\x01(\tR\x11gcmRegistrationId\"V\n\x1aUploadDeviceCo\
    nfigResponse\x128\n\x17uploadDeviceConfigToken\x18\x01\x20\x01(\tR\x17up\
    loadDeviceConfigToken\"\xb1\x01\n\x1cAckNotificationsRequestProto\x12&\n\
    \x0enotificationId\x18\x01\x20\x03(\tR\x0enotificationId\x129\n\rsignatu\
    reHash\x18\x02\x20\x01(\x0b2\x13.SignatureHashProtoR\rsignatureHash\x12.\
    \n\x12nackNotificationId\x18\x03\x20\x03(\tR\x12nackNotificationId\"\x1f\
    \n\x1dAckNotificationsResponseProto\"\xe8\x01\n\x0cAddressProto\x12\x1a\
    \n\x08address1\x18\x01\x20\x01(\tR\x08address1\x12\x1a\n\x08address2\x18\
    \x02\x20\x01(\tR\x08address2\x12\x12\n\x04city\x18\x03\x20\x01(\tR\x04ci\
    ty\x12\x14\n\x05state\x18\x04\x20\x01(\tR\x05state\x12\x1e\n\npostalCode\
    \x18\x05\x20\x01(\tR\npostalCode\x12\x18\n\x07country\x18\x06\x20\x01(\t\
    R\x07country\x12\x12\n\x04name\x18\x07\x20\x01(\tR\x04name\x12\x12\n\x04\
    type\x18\x08\x20\x01(\tR\x04type\x12\x14\n\x05phone\x18\t\x20\x01(\tR\
    \x05phone\"6\n\x0cAppDataProto\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"G\n\x12AppSuggestion\
    Proto\x121\n\tassetInfo\x18\x01\x20\x01(\x0b2\x13.ExternalAssetProtoR\ta\
    ssetInfo\"t\n\x14AssetIdentifierProto\x12\x20\n\x0bpackageName\x18\x01\
    \x20\x01(\tR\x0bpackageName\x12\x20\n\x0bversionCode\x18\x02\x20\x01(\
    \x05R\x0bversionCode\x12\x18\n\x07assetId\x18\x03\x20\x01(\tR\x07assetId\
    \"\x84\x05\n\x12AssetsRequestProto\x12\x1c\n\tassetType\x18\x01\x20\x01(\
    \x05R\tassetType\x12\x14\n\x05query\x18\x02\x20\x01(\tR\x05query\x12\x1e\
    \n\ncategoryId\x18\x03\x20\x01(\tR\ncategoryId\x12\x18\n\x07assetId\x18\
    \x04\x20\x03(\tR\x07assetId\x126\n\x16retrieveVendingHistory\x18\x05\x20\
    \x01(\x08R\x16retrieveVendingHistory\x122\n\x14retrieveExtendedInfo\x18\
    \x06\x20\x01(\x08R\x14retrieveExtendedInfo\x12\x1c\n\tsortOrder\x18\x07\
    \x20\x01(\x05R\tsortOrder\x12\x1e\n\nstartIndex\x18\x08\x20\x01(\x03R\ns\
    tartIndex\x12\x1e\n\nnumEntries\x18\t\x20\x01(\x03R\nnumEntries\x12\x1e\
    \n\nviewFilter\x18\n\x20\x01(\x05R\nviewFilter\x12\x20\n\x0brankingType\
    \x18\x0b\x20\x01(\tR\x0brankingType\x126\n\x16retrieveCarrierChannel\x18\
    \x0c\x20\x01(\x08R\x16retrieveCarrierChannel\x126\n\x16pendingDownloadAs\
    setId\x18\r\x20\x03(\tR\x16pendingDownloadAssetId\x12<\n\x19reconstructV\
    endingHistory\x18\x0e\x20\x01(\x08R\x19reconstructVendingHistory\x12,\n\
    \x11unfilteredResults\x18\x0f\x20\x01(\x08R\x11unfilteredResults\x12\x18\
    \n\x07badgeId\x18\x10\x20\x03(\tR\x07badgeId\"\xa9\x02\n\x13AssetsRespon\
    seProto\x12)\n\x05asset\x18\x01\x20\x03(\x0b2\x13.ExternalAssetProtoR\
    \x05asset\x12(\n\x0fnumTotalEntries\x18\x02\x20\x01(\x03R\x0fnumTotalEnt\
    ries\x12&\n\x0ecorrectedQuery\x18\x03\x20\x01(\tR\x0ecorrectedQuery\x12/\
    \n\x08altAsset\x18\x04\x20\x03(\x0b2\x13.ExternalAssetProtoR\x08altAsset\
    \x120\n\x13numCorrectedEntries\x18\x05\x20\x01(\x03R\x13numCorrectedEntr\
    ies\x12\x16\n\x06header\x18\x06\x20\x01(\tR\x06header\x12\x1a\n\x08listT\
    ype\x18\x07\x20\x01(\x05R\x08listType\"\x8c\x02\n\x18BillingEventRequest\
    Proto\x12\x1c\n\teventType\x18\x01\x20\x01(\x05R\teventType\x120\n\x13bi\
    llingParametersId\x18\x02\x20\x01(\tR\x13billingParametersId\x12$\n\rres\
    ultSuccess\x18\x03\x20\x01(\x08R\rresultSuccess\x12$\n\rclientMessage\
    \x18\x04\x20\x01(\tR\rclientMessage\x12T\n\x11carrierInstrument\x18\x05\
    \x20\x01(\x0b2&.ExternalCarrierBillingInstrumentProtoR\x11carrierInstrum\
    ent\"\x1b\n\x19BillingEventResponseProto\"\xe1\x05\n\x15BillingParameter\
    Proto\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12\x16\n\x06mncMcc\x18\x03\x20\x03(\tR\x06mncM\
    cc\x12\x1e\n\nbackendUrl\x18\x04\x20\x03(\tR\nbackendUrl\x12\x16\n\x06ic\
    onId\x18\x05\x20\x01(\tR\x06iconId\x124\n\x15billingInstrumentType\x18\
    \x06\x20\x01(\x05R\x15billingInstrumentType\x12$\n\rapplicationId\x18\
    \x07\x20\x01(\tR\rapplicationId\x12\x16\n\x06tosUrl\x18\x08\x20\x01(\tR\
    \x06tosUrl\x124\n\x15instrumentTosRequired\x18\t\x20\x01(\x08R\x15instru\
    mentTosRequired\x12\x1e\n\napiVersion\x18\n\x20\x01(\x05R\napiVersion\
    \x12L\n!perTransactionCredentialsRequired\x18\x0b\x20\x01(\x08R!perTrans\
    actionCredentialsRequired\x12^\n*sendSubscriberIdWithCarrierBillingReque\
    sts\x18\x0c\x20\x01(\x08R*sendSubscriberIdWithCarrierBillingRequests\x12\
    8\n\x17deviceAssociationMethod\x18\r\x20\x01(\x05R\x17deviceAssociationM\
    ethod\x128\n\x17userTokenRequestMessage\x18\x0e\x20\x01(\tR\x17userToken\
    RequestMessage\x128\n\x17userTokenRequestAddress\x18\x0f\x20\x01(\tR\x17\
    userTokenRequestAddress\x12.\n\x12passphraseRequired\x18\x10\x20\x01(\
    \x08R\x12passphraseRequired\"r\n\x1eCarrierBillingCredentialsProto\x12\
    \x20\n\x0bcredentials\x18\x01\x20\x01(\tR\x0bcredentials\x12.\n\x12crede\
    ntialsTimeout\x18\x02\x20\x01(\x03R\x12credentialsTimeout\"\x97\x03\n\rC\
    ategoryProto\x12\x1c\n\tassetType\x18\x02\x20\x01(\x05R\tassetType\x12\
    \x1e\n\ncategoryId\x18\x03\x20\x01(\tR\ncategoryId\x12(\n\x0fcategoryDis\
    play\x18\x04\x20\x01(\tR\x0fcategoryDisplay\x12*\n\x10categorySubtitle\
    \x18\x05\x20\x01(\tR\x10categorySubtitle\x12,\n\x11promotedAssetsNew\x18\
    \x06\x20\x03(\tR\x11promotedAssetsNew\x12.\n\x12promotedAssetsHome\x18\
    \x07\x20\x03(\tR\x12promotedAssetsHome\x124\n\rsubCategories\x18\x08\x20\
    \x03(\x0b2\x0e.CategoryProtoR\rsubCategories\x12.\n\x12promotedAssetsPai\
    d\x18\t\x20\x03(\tR\x12promotedAssetsPaid\x12.\n\x12promotedAssetsFree\
    \x18\n\x20\x03(\tR\x12promotedAssetsFree\"I\n!CheckForNotificationsReque\
    stProto\x12$\n\ralarmDuration\x18\x01\x20\x01(\x03R\ralarmDuration\"$\n\
    \"CheckForNotificationsResponseProto\"t\n\x18CheckLicenseRequestProto\
    \x12\x20\n\x0bpackageName\x18\x01\x20\x01(\tR\x0bpackageName\x12\x20\n\
    \x0bversionCode\x18\x02\x20\x01(\x05R\x0bversionCode\x12\x14\n\x05nonce\
    \x18\x03\x20\x01(\x03R\x05nonce\"}\n\x19CheckLicenseResponseProto\x12\"\
    \n\x0cresponseCode\x18\x01\x20\x01(\x05R\x0cresponseCode\x12\x1e\n\nsign\
    edData\x18\x02\x20\x01(\tR\nsignedData\x12\x1c\n\tsignature\x18\x03\x20\
    \x01(\tR\tsignature\"\xd0\x01\n\x14CommentsRequestProto\x12\x18\n\x07ass\
    etId\x18\x01\x20\x01(\tR\x07assetId\x12\x1e\n\nstartIndex\x18\x02\x20\
    \x01(\x03R\nstartIndex\x12\x1e\n\nnumEntries\x18\x03\x20\x01(\x03R\nnumE\
    ntries\x128\n\x17shouldReturnSelfComment\x18\x04\x20\x01(\x08R\x17should\
    ReturnSelfComment\x12$\n\rassetReferrer\x18\x05\x20\x01(\tR\rassetReferr\
    er\"\xab\x01\n\x15CommentsResponseProto\x12/\n\x07comment\x18\x01\x20\
    \x03(\x0b2\x15.ExternalCommentProtoR\x07comment\x12(\n\x0fnumTotalEntrie\
    s\x18\x02\x20\x01(\x03R\x0fnumTotalEntries\x127\n\x0bselfComment\x18\x03\
    \x20\x01(\x0b2\x15.ExternalCommentProtoR\x0bselfComment\"\x84\x05\n\x17C\
    ontentSyncRequestProto\x12\x20\n\x0bincremental\x18\x01\x20\x01(\x08R\
    \x0bincremental\x12X\n\x11assetinstallstate\x18\x02\x20\x03(\n2*.Content\
    SyncRequestProto.AssetInstallStateR\x11assetinstallstate\x12@\n\tsystema\
    pp\x18\n\x20\x03(\n2\".ContentSyncRequestProto.SystemAppR\tsystemapp\x12\
    .\n\x12sideloadedAppCount\x18\x0e\x20\x01(\x05R\x12sideloadedAppCount\
    \x1a\xff\x01\n\x11AssetInstallState\x12\x18\n\x07assetId\x18\x03\x20\x01\
    (\tR\x07assetId\x12\x1e\n\nassetState\x18\x04\x20\x01(\x05R\nassetState\
    \x12\x20\n\x0binstallTime\x18\x05\x20\x01(\x03R\x0binstallTime\x12$\n\ru\
    ninstallTime\x18\x06\x20\x01(\x03R\runinstallTime\x12\x20\n\x0bpackageNa\
    me\x18\x07\x20\x01(\tR\x0bpackageName\x12\x20\n\x0bversionCode\x18\x08\
    \x20\x01(\x05R\x0bversionCode\x12$\n\rassetReferrer\x18\t\x20\x01(\tR\ra\
    ssetReferrer\x1ay\n\tSystemApp\x12\x20\n\x0bpackageName\x18\x0b\x20\x01(\
    \tR\x0bpackageName\x12\x20\n\x0bversionCode\x18\x0c\x20\x01(\x05R\x0bver\
    sionCode\x12(\n\x0fcertificateHash\x18\r\x20\x03(\tR\x0fcertificateHash\
    \"L\n\x18ContentSyncResponseProto\x120\n\x13numUpdatesAvailable\x18\x01\
    \x20\x01(\x05R\x13numUpdatesAvailable\"W\n\x10DataMessageProto\x12\x1a\n\
    \x08category\x18\x01\x20\x01(\tR\x08category\x12'\n\x07appData\x18\x03\
    \x20\x03(\x0b2\r.AppDataProtoR\x07appData\"i\n\x11DownloadInfoProto\x12\
    \x18\n\x07apkSize\x18\x01\x20\x01(\x03R\x07apkSize\x12:\n\x0eadditionalF\
    ile\x18\x02\x20\x03(\x0b2\x12.FileMetadataProtoR\x0eadditionalFile\"\xbf\
    \x10\n\x12ExternalAssetProto\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x1c\n\tassetType\
    \x18\x03\x20\x01(\x05R\tassetType\x12\x14\n\x05owner\x18\x04\x20\x01(\tR\
    \x05owner\x12\x18\n\x07version\x18\x05\x20\x01(\tR\x07version\x12\x14\n\
    \x05price\x18\x06\x20\x01(\tR\x05price\x12$\n\raverageRating\x18\x07\x20\
    \x01(\tR\raverageRating\x12\x1e\n\nnumRatings\x18\x08\x20\x01(\x03R\nnum\
    Ratings\x12Y\n\x13purchaseinformation\x18\t\x20\x01(\n2'.ExternalAssetPr\
    oto.PurchaseInformationR\x13purchaseinformation\x12D\n\x0cextendedinfo\
    \x18\x0c\x20\x01(\n2\x20.ExternalAssetProto.ExtendedInfoR\x0cextendedinf\
    o\x12\x18\n\x07ownerId\x18\x16\x20\x01(\tR\x07ownerId\x12\x20\n\x0bpacka\
    geName\x18\x18\x20\x01(\tR\x0bpackageName\x12\x20\n\x0bversionCode\x18\
    \x19\x20\x01(\x05R\x0bversionCode\x12\"\n\x0cbundledAsset\x18\x1d\x20\
    \x01(\x08R\x0cbundledAsset\x12$\n\rpriceCurrency\x18\x20\x20\x01(\tR\rpr\
    iceCurrency\x12\x20\n\x0bpriceMicros\x18!\x20\x01(\x03R\x0bpriceMicros\
    \x12\"\n\x0cfilterReason\x18#\x20\x01(\tR\x0cfilterReason\x12,\n\x11actu\
    alSellerPrice\x18(\x20\x01(\tR\x11actualSellerPrice\x12/\n\x08appBadge\
    \x18/\x20\x03(\x0b2\x13.ExternalBadgeProtoR\x08appBadge\x123\n\nownerBad\
    ge\x180\x20\x03(\x0b2\x13.ExternalBadgeProtoR\nownerBadge\x1a\xc9\x01\n\
    \x13PurchaseInformation\x12\"\n\x0cpurchaseTime\x18\n\x20\x01(\x03R\x0cp\
    urchaseTime\x12,\n\x11refundTimeoutTime\x18\x0b\x20\x01(\x03R\x11refundT\
    imeoutTime\x12,\n\x11refundStartPolicy\x18-\x20\x01(\x05R\x11refundStart\
    Policy\x122\n\x14refundWindowDuration\x18.\x20\x01(\x03R\x14refundWindow\
    Duration\x1a\xe9\x08\n\x0cExtendedInfo\x12\x20\n\x0bdescription\x18\r\
    \x20\x01(\tR\x0bdescription\x12$\n\rdownloadCount\x18\x0e\x20\x01(\x03R\
    \rdownloadCount\x128\n\x17applicationPermissionId\x18\x0f\x20\x03(\tR\
    \x17applicationPermissionId\x12:\n\x18requiredInstallationSize\x18\x10\
    \x20\x01(\x03R\x18requiredInstallationSize\x12\x20\n\x0bpackageName\x18\
    \x11\x20\x01(\tR\x0bpackageName\x12\x1a\n\x08category\x18\x12\x20\x01(\t\
    R\x08category\x12$\n\rforwardLocked\x18\x13\x20\x01(\x08R\rforwardLocked\
    \x12\"\n\x0ccontactEmail\x18\x14\x20\x01(\tR\x0ccontactEmail\x120\n\x13e\
    verInstalledByUser\x18\x15\x20\x01(\x08R\x13everInstalledByUser\x120\n\
    \x13downloadCountString\x18\x17\x20\x01(\tR\x13downloadCountString\x12\"\
    \n\x0ccontactPhone\x18\x1a\x20\x01(\tR\x0ccontactPhone\x12&\n\x0econtact\
    Website\x18\x1b\x20\x01(\tR\x0econtactWebsite\x126\n\x16nextPurchaseRefu\
    ndable\x18\x1c\x20\x01(\x08R\x16nextPurchaseRefundable\x12&\n\x0enumScre\
    enshots\x18\x1e\x20\x01(\x05R\x0enumScreenshots\x126\n\x16promotionalDes\
    cription\x18\x1f\x20\x01(\tR\x16promotionalDescription\x12*\n\x10serverA\
    ssetState\x18\"\x20\x01(\x05R\x10serverAssetState\x12.\n\x12contentRatin\
    gLevel\x18$\x20\x01(\x05R\x12contentRatingLevel\x120\n\x13contentRatingS\
    tring\x18%\x20\x01(\tR\x13contentRatingString\x12$\n\rrecentChanges\x18&\
    \x20\x01(\tR\rrecentChanges\x12`\n\x11packagedependency\x18'\x20\x03(\n2\
    2.ExternalAssetProto.ExtendedInfo.PackageDependencyR\x11packagedependenc\
    y\x12\x1c\n\tvideoLink\x18+\x20\x01(\tR\tvideoLink\x126\n\x0cdownloadInf\
    o\x181\x20\x01(\x0b2\x12.DownloadInfoProtoR\x0cdownloadInfo\x1a_\n\x11Pa\
    ckageDependency\x12\x20\n\x0bpackageName\x18)\x20\x01(\tR\x0bpackageName\
    \x12(\n\x0fskipPermissions\x18*\x20\x01(\x08R\x0fskipPermissions\"A\n\
    \x17ExternalBadgeImageProto\x12\x14\n\x05usage\x18\x01\x20\x01(\x05R\x05\
    usage\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\"\xc6\x01\n\x12Externa\
    lBadgeProto\x12&\n\x0elocalizedTitle\x18\x01\x20\x01(\tR\x0elocalizedTit\
    le\x122\n\x14localizedDescription\x18\x02\x20\x01(\tR\x14localizedDescri\
    ption\x128\n\nbadgeImage\x18\x03\x20\x03(\x0b2\x18.ExternalBadgeImagePro\
    toR\nbadgeImage\x12\x1a\n\x08searchId\x18\x04\x20\x01(\tR\x08searchId\"\
    \x97\x04\n%ExternalCarrierBillingInstrumentProto\x12$\n\rinstrumentKey\
    \x18\x01\x20\x01(\tR\rinstrumentKey\x122\n\x14subscriberIdentifier\x18\
    \x02\x20\x01(\tR\x14subscriberIdentifier\x12\x20\n\x0baccountType\x18\
    \x03\x20\x01(\tR\x0baccountType\x12.\n\x12subscriberCurrency\x18\x04\x20\
    \x01(\tR\x12subscriberCurrency\x12*\n\x10transactionLimit\x18\x05\x20\
    \x01(\x04R\x10transactionLimit\x12&\n\x0esubscriberName\x18\x06\x20\x01(\
    \tR\x0esubscriberName\x12\x1a\n\x08address1\x18\x07\x20\x01(\tR\x08addre\
    ss1\x12\x1a\n\x08address2\x18\x08\x20\x01(\tR\x08address2\x12\x12\n\x04c\
    ity\x18\t\x20\x01(\tR\x04city\x12\x14\n\x05state\x18\n\x20\x01(\tR\x05st\
    ate\x12\x1e\n\npostalCode\x18\x0b\x20\x01(\tR\npostalCode\x12\x18\n\x07c\
    ountry\x18\x0c\x20\x01(\tR\x07country\x12R\n\x17encryptedSubscriberInfo\
    \x18\r\x20\x01(\x0b2\x18.EncryptedSubscriberInfoR\x17encryptedSubscriber\
    Info\"\xa6\x01\n\x14ExternalCommentProto\x12\x12\n\x04body\x18\x01\x20\
    \x01(\tR\x04body\x12\x16\n\x06rating\x18\x02\x20\x01(\x05R\x06rating\x12\
    \x20\n\x0bcreatorName\x18\x03\x20\x01(\tR\x0bcreatorName\x12\"\n\x0ccrea\
    tionTime\x18\x04\x20\x01(\x03R\x0ccreationTime\x12\x1c\n\tcreatorId\x18\
    \x05\x20\x01(\tR\tcreatorId\"\xfa\x02\n\x12ExternalCreditCard\x12\x12\n\
    \x04type\x18\x01\x20\x01(\tR\x04type\x12\x1e\n\nlastDigits\x18\x02\x20\
    \x01(\tR\nlastDigits\x12\x18\n\x07expYear\x18\x03\x20\x01(\x05R\x07expYe\
    ar\x12\x1a\n\x08expMonth\x18\x04\x20\x01(\x05R\x08expMonth\x12\x1e\n\npe\
    rsonName\x18\x05\x20\x01(\tR\npersonName\x12\x20\n\x0bcountryCode\x18\
    \x06\x20\x01(\tR\x0bcountryCode\x12\x1e\n\npostalCode\x18\x07\x20\x01(\t\
    R\npostalCode\x12\x20\n\x0bmakeDefault\x18\x08\x20\x01(\x08R\x0bmakeDefa\
    ult\x12\x1a\n\x08address1\x18\t\x20\x01(\tR\x08address1\x12\x1a\n\x08add\
    ress2\x18\n\x20\x01(\tR\x08address2\x12\x12\n\x04city\x18\x0b\x20\x01(\t\
    R\x04city\x12\x14\n\x05state\x18\x0c\x20\x01(\tR\x05state\x12\x14\n\x05p\
    hone\x18\r\x20\x01(\tR\x05phone\"\x94\x02\n\x1dExternalPaypalInstrumentP\
    roto\x12$\n\rinstrumentKey\x18\x01\x20\x01(\tR\rinstrumentKey\x12&\n\x0e\
    preapprovalKey\x18\x02\x20\x01(\tR\x0epreapprovalKey\x12\x20\n\x0bpaypal\
    Email\x18\x03\x20\x01(\tR\x0bpaypalEmail\x123\n\rpaypalAddress\x18\x04\
    \x20\x01(\x0b2\r.AddressProtoR\rpaypalAddress\x12N\n\"multiplePaypalInst\
    rumentsSupported\x18\x05\x20\x01(\x08R\"multiplePaypalInstrumentsSupport\
    ed\"\x87\x01\n\x11FileMetadataProto\x12\x1a\n\x08fileType\x18\x01\x20\
    \x01(\x05R\x08fileType\x12\x20\n\x0bversionCode\x18\x02\x20\x01(\x05R\
    \x0bversionCode\x12\x12\n\x04size\x18\x03\x20\x01(\x03R\x04size\x12\x20\
    \n\x0bdownloadUrl\x18\x04\x20\x01(\tR\x0bdownloadUrl\"s\n\x1dGetAddressS\
    nippetRequestProto\x12R\n\x17encryptedSubscriberInfo\x18\x01\x20\x01(\
    \x0b2\x18.EncryptedSubscriberInfoR\x17encryptedSubscriberInfo\"H\n\x1eGe\
    tAddressSnippetResponseProto\x12&\n\x0eaddressSnippet\x18\x01\x20\x01(\t\
    R\x0eaddressSnippet\"^\n\x14GetAssetRequestProto\x12\x18\n\x07assetId\
    \x18\x01\x20\x01(\tR\x07assetId\x12,\n\x11directDownloadKey\x18\x02\x20\
    \x01(\tR\x11directDownloadKey\"\xd3\x05\n\x15GetAssetResponseProto\x12G\
    \n\x0cinstallasset\x18\x01\x20\x01(\n2#.GetAssetResponseProto.InstallAss\
    etR\x0cinstallasset\x12:\n\x0eadditionalFile\x18\x0f\x20\x03(\x0b2\x12.F\
    ileMetadataProtoR\x0eadditionalFile\x1a\xb4\x04\n\x0cInstallAsset\x12\
    \x18\n\x07assetId\x18\x02\x20\x01(\tR\x07assetId\x12\x1c\n\tassetName\
    \x18\x03\x20\x01(\tR\tassetName\x12\x1c\n\tassetType\x18\x04\x20\x01(\tR\
    \tassetType\x12\"\n\x0cassetPackage\x18\x05\x20\x01(\tR\x0cassetPackage\
    \x12\x18\n\x07blobUrl\x18\x06\x20\x01(\tR\x07blobUrl\x12&\n\x0eassetSign\
    ature\x18\x07\x20\x01(\tR\x0eassetSignature\x12\x1c\n\tassetSize\x18\x08\
    \x20\x01(\x03R\tassetSize\x120\n\x13refundTimeoutMillis\x18\t\x20\x01(\
    \x03R\x13refundTimeoutMillis\x12$\n\rforwardLocked\x18\n\x20\x01(\x08R\r\
    forwardLocked\x12\x18\n\x07secured\x18\x0b\x20\x01(\x08R\x07secured\x12\
    \x20\n\x0bversionCode\x18\x0c\x20\x01(\x05R\x0bversionCode\x126\n\x16dow\
    nloadAuthCookieName\x18\r\x20\x01(\tR\x16downloadAuthCookieName\x128\n\
    \x17downloadAuthCookieValue\x18\x0e\x20\x01(\tR\x17downloadAuthCookieVal\
    ue\x12D\n\x1dpostInstallRefundWindowMillis\x18\x10\x20\x01(\x03R\x1dpost\
    InstallRefundWindowMillis\"\x1c\n\x1aGetCarrierInfoRequestProto\"\xa3\
    \x02\n\x1bGetCarrierInfoResponseProto\x124\n\x15carrierChannelEnabled\
    \x18\x01\x20\x01(\x08R\x15carrierChannelEnabled\x12(\n\x0fcarrierLogoIco\
    n\x18\x02\x20\x01(\x0cR\x0fcarrierLogoIcon\x12$\n\rcarrierBanner\x18\x03\
    \x20\x01(\x0cR\rcarrierBanner\x12(\n\x0fcarrierSubtitle\x18\x04\x20\x01(\
    \tR\x0fcarrierSubtitle\x12\"\n\x0ccarrierTitle\x18\x05\x20\x01(\tR\x0cca\
    rrierTitle\x120\n\x13carrierImageDensity\x18\x06\x20\x01(\x05R\x13carrie\
    rImageDensity\"I\n\x19GetCategoriesRequestProto\x12,\n\x11prefetchPromoD\
    ata\x18\x01\x20\x01(\x08R\x11prefetchPromoData\"L\n\x1aGetCategoriesResp\
    onseProto\x12.\n\ncategories\x18\x01\x20\x03(\x0b2\x0e.CategoryProtoR\nc\
    ategories\"\xa8\x02\n\x14GetImageRequestProto\x12\x18\n\x07assetId\x18\
    \x01\x20\x01(\tR\x07assetId\x12\x1e\n\nimageUsage\x18\x03\x20\x01(\x05R\
    \nimageUsage\x12\x18\n\x07imageId\x18\x04\x20\x01(\tR\x07imageId\x120\n\
    \x13screenPropertyWidth\x18\x05\x20\x01(\x05R\x13screenPropertyWidth\x12\
    2\n\x14screenPropertyHeight\x18\x06\x20\x01(\x05R\x14screenPropertyHeigh\
    t\x124\n\x15screenPropertyDensity\x18\x07\x20\x01(\x05R\x15screenPropert\
    yDensity\x12\x20\n\x0bproductType\x18\x08\x20\x01(\x05R\x0bproductType\"\
    Y\n\x15GetImageResponseProto\x12\x1c\n\timageData\x18\x01\x20\x01(\x0cR\
    \timageData\x12\"\n\x0cimageDensity\x18\x02\x20\x01(\x05R\x0cimageDensit\
    y\"\xf6\x02\n\x1dGetMarketMetadataRequestProto\x12(\n\x0flastRequestTime\
    \x18\x01\x20\x01(\x03R\x0flastRequestTime\x12K\n\x13deviceConfiguration\
    \x18\x02\x20\x01(\x0b2\x19.DeviceConfigurationProtoR\x13deviceConfigurat\
    ion\x12$\n\rdeviceRoaming\x18\x03\x20\x01(\x08R\rdeviceRoaming\x120\n\
    \x13marketSignatureHash\x18\x04\x20\x03(\tR\x13marketSignatureHash\x12$\
    \n\rcontentRating\x18\x05\x20\x01(\x05R\rcontentRating\x12(\n\x0fdeviceM\
    odelName\x18\x06\x20\x01(\tR\x0fdeviceModelName\x126\n\x16deviceManufact\
    urerName\x18\x07\x20\x01(\tR\x16deviceManufacturerName\"\xee\x03\n\x1eGe\
    tMarketMetadataResponseProto\x128\n\x17latestClientVersionCode\x18\x01\
    \x20\x01(\x05R\x17latestClientVersionCode\x12(\n\x0flatestClientUrl\x18\
    \x02\x20\x01(\tR\x0flatestClientUrl\x12(\n\x0fpaidAppsEnabled\x18\x03\
    \x20\x01(\x08R\x0fpaidAppsEnabled\x12B\n\x10billingParameter\x18\x04\x20\
    \x03(\x0b2\x16.BillingParameterProtoR\x10billingParameter\x12.\n\x12comm\
    entPostEnabled\x18\x05\x20\x01(\x08R\x12commentPostEnabled\x122\n\x14bil\
    lingEventsEnabled\x18\x06\x20\x01(\x08R\x14billingEventsEnabled\x12&\n\
    \x0ewarningMessage\x18\x07\x20\x01(\tR\x0ewarningMessage\x120\n\x13inApp\
    BillingEnabled\x18\x08\x20\x01(\x08R\x13inAppBillingEnabled\x12<\n\x19in\
    AppBillingMaxApiVersion\x18\t\x20\x01(\x05R\x19inAppBillingMaxApiVersion\
    \"<\n\x1cGetSubCategoriesRequestProto\x12\x1c\n\tassetType\x18\x01\x20\
    \x01(\x05R\tassetType\"\xd2\x01\n\x1dGetSubCategoriesResponseProto\x12L\
    \n\x0bsubcategory\x18\x01\x20\x03(\n2*.GetSubCategoriesResponseProto.Sub\
    CategoryR\x0bsubcategory\x1ac\n\x0bSubCategory\x12.\n\x12subCategoryDisp\
    lay\x18\x02\x20\x01(\tR\x12subCategoryDisplay\x12$\n\rsubCategoryId\x18\
    \x03\x20\x01(\tR\rsubCategoryId\"\xfd\x01\n$InAppPurchaseInformationRequ\
    estProto\x129\n\rsignatureHash\x18\x01\x20\x01(\x0b2\x13.SignatureHashPr\
    otoR\rsignatureHash\x12\x14\n\x05nonce\x18\x02\x20\x01(\x03R\x05nonce\
    \x12&\n\x0enotificationId\x18\x03\x20\x03(\tR\x0enotificationId\x12.\n\
    \x12signatureAlgorithm\x18\x04\x20\x01(\tR\x12signatureAlgorithm\x12,\n\
    \x11billingApiVersion\x18\x05\x20\x01(\x05R\x11billingApiVersion\"\xf2\
    \x01\n%InAppPurchaseInformationResponseProto\x128\n\x0esignedResponse\
    \x18\x01\x20\x01(\x0b2\x10.SignedDataProtoR\x0esignedResponse\x12Q\n\x15\
    statusBarNotification\x18\x02\x20\x03(\x0b2\x1b.StatusBarNotificationPro\
    toR\x15statusBarNotification\x12<\n\x0epurchaseResult\x18\x03\x20\x01(\
    \x0b2\x14.PurchaseResultProtoR\x0epurchaseResult\"\xd5\x01\n$InAppRestor\
    eTransactionsRequestProto\x129\n\rsignatureHash\x18\x01\x20\x01(\x0b2\
    \x13.SignatureHashProtoR\rsignatureHash\x12\x14\n\x05nonce\x18\x02\x20\
    \x01(\x03R\x05nonce\x12.\n\x12signatureAlgorithm\x18\x03\x20\x01(\tR\x12\
    signatureAlgorithm\x12,\n\x11billingApiVersion\x18\x04\x20\x01(\x05R\x11\
    billingApiVersion\"\x9f\x01\n%InAppRestoreTransactionsResponseProto\x128\
    \n\x0esignedResponse\x18\x01\x20\x01(\x0b2\x10.SignedDataProtoR\x0esigne\
    dResponse\x12<\n\x0epurchaseResult\x18\x02\x20\x01(\x0b2\x14.PurchaseRes\
    ultProtoR\x0epurchaseResult\"\x8a\x02\n\x19ModifyCommentRequestProto\x12\
    \x18\n\x07assetId\x18\x01\x20\x01(\tR\x07assetId\x12/\n\x07comment\x18\
    \x02\x20\x01(\x0b2\x15.ExternalCommentProtoR\x07comment\x12$\n\rdeleteCo\
    mment\x18\x03\x20\x01(\x08R\rdeleteComment\x12\x1c\n\tflagAsset\x18\x04\
    \x20\x01(\x08R\tflagAsset\x12\x1a\n\x08flagType\x18\x05\x20\x01(\x05R\
    \x08flagType\x12\x20\n\x0bflagMessage\x18\x06\x20\x01(\tR\x0bflagMessage\
    \x12\x20\n\x0bnonFlagFlow\x18\x07\x20\x01(\x08R\x0bnonFlagFlow\"\x1c\n\
    \x1aModifyCommentResponseProto\"\xb4\x01\n\x16PaypalCountryInfoProto\x12\
    ,\n\x11birthDateRequired\x18\x01\x20\x01(\x08R\x11birthDateRequired\x12\
    \x18\n\x07tosText\x18\x02\x20\x01(\tR\x07tosText\x122\n\x14billingAgreem\
    entText\x18\x03\x20\x01(\tR\x14billingAgreementText\x12\x1e\n\npreTosTex\
    t\x18\x04\x20\x01(\tR\npreTosText\"\xa2\x01\n\x1fPaypalCreateAccountRequ\
    estProto\x12\x1c\n\tfirstName\x18\x01\x20\x01(\tR\tfirstName\x12\x1a\n\
    \x08lastName\x18\x02\x20\x01(\tR\x08lastName\x12'\n\x07address\x18\x03\
    \x20\x01(\x0b2\r.AddressProtoR\x07address\x12\x1c\n\tbirthDate\x18\x04\
    \x20\x01(\tR\tbirthDate\"N\n\x20PaypalCreateAccountResponseProto\x12*\n\
    \x10createAccountKey\x18\x01\x20\x01(\tR\x10createAccountKey\"b\n\x16Pay\
    palCredentialsProto\x12&\n\x0epreapprovalKey\x18\x01\x20\x01(\tR\x0eprea\
    pprovalKey\x12\x20\n\x0bpaypalEmail\x18\x02\x20\x01(\tR\x0bpaypalEmail\"\
    K\n\x20PaypalMassageAddressRequestProto\x12'\n\x07address\x18\x01\x20\
    \x01(\x0b2\r.AddressProtoR\x07address\"L\n!PaypalMassageAddressResponseP\
    roto\x12'\n\x07address\x18\x01\x20\x01(\x0b2\r.AddressProtoR\x07address\
    \"\x82\x01\n(PaypalPreapprovalCredentialsRequestProto\x12$\n\rgaiaAuthTo\
    ken\x18\x01\x20\x01(\tR\rgaiaAuthToken\x120\n\x13billingInstrumentId\x18\
    \x02\x20\x01(\tR\x13billingInstrumentId\"\x99\x01\n)PaypalPreapprovalCre\
    dentialsResponseProto\x12\x1e\n\nresultCode\x18\x01\x20\x01(\x05R\nresul\
    tCode\x12*\n\x10paypalAccountKey\x18\x02\x20\x01(\tR\x10paypalAccountKey\
    \x12\x20\n\x0bpaypalEmail\x18\x03\x20\x01(\tR\x0bpaypalEmail\"n\n$Paypal\
    PreapprovalDetailsRequestProto\x12\x1e\n\ngetAddress\x18\x01\x20\x01(\
    \x08R\ngetAddress\x12&\n\x0epreapprovalKey\x18\x02\x20\x01(\tR\x0epreapp\
    rovalKey\"r\n%PaypalPreapprovalDetailsResponseProto\x12\x20\n\x0bpaypalE\
    mail\x18\x01\x20\x01(\tR\x0bpaypalEmail\x12'\n\x07address\x18\x02\x20\
    \x01(\x0b2\r.AddressProtoR\x07address\"\x1f\n\x1dPaypalPreapprovalReques\
    tProto\"H\n\x1ePaypalPreapprovalResponseProto\x12&\n\x0epreapprovalKey\
    \x18\x01\x20\x01(\tR\x0epreapprovalKey\"|\n\x19PendingNotificationsProto\
    \x125\n\x0cnotification\x18\x01\x20\x03(\x0b2\x11.DataMessageProtoR\x0cn\
    otification\x12(\n\x0fnextCheckMillis\x18\x02\x20\x01(\x03R\x0fnextCheck\
    Millis\"x\n\x15PrefetchedBundleProto\x12-\n\x07request\x18\x01\x20\x01(\
    \x0b2\x13.SingleRequestProtoR\x07request\x120\n\x08response\x18\x02\x20\
    \x01(\x0b2\x14.SingleResponseProtoR\x08response\"\xa1\x02\n\x15PurchaseC\
    artInfoProto\x12\x1c\n\titemPrice\x18\x01\x20\x01(\tR\titemPrice\x12\"\n\
    \x0ctaxInclusive\x18\x02\x20\x01(\tR\x0ctaxInclusive\x12\"\n\x0ctaxExclu\
    sive\x18\x03\x20\x01(\tR\x0ctaxExclusive\x12\x14\n\x05total\x18\x04\x20\
    \x01(\tR\x05total\x12\x1e\n\ntaxMessage\x18\x05\x20\x01(\tR\ntaxMessage\
    \x12$\n\rfooterMessage\x18\x06\x20\x01(\tR\rfooterMessage\x12$\n\rpriceC\
    urrency\x18\x07\x20\x01(\tR\rpriceCurrency\x12\x20\n\x0bpriceMicros\x18\
    \x08\x20\x01(\x03R\x0bpriceMicros\"\xf8\x05\n\x11PurchaseInfoProto\x12$\
    \n\rtransactionId\x18\x01\x20\x01(\tR\rtransactionId\x122\n\x08cartInfo\
    \x18\x02\x20\x01(\x0b2\x16.PurchaseCartInfoProtoR\x08cartInfo\x12U\n\x12\
    billinginstruments\x18\x03\x20\x01(\n2%.PurchaseInfoProto.BillingInstrum\
    entsR\x12billinginstruments\x12*\n\x10errorInputFields\x18\t\x20\x03(\
    \x05R\x10errorInputFields\x12\"\n\x0crefundPolicy\x18\n\x20\x01(\tR\x0cr\
    efundPolicy\x12$\n\ruserCanAddGdd\x18\x0c\x20\x01(\x08R\ruserCanAddGdd\
    \x128\n\x17eligibleInstrumentTypes\x18\r\x20\x03(\x05R\x17eligibleInstru\
    mentTypes\x12\x18\n\x07orderId\x18\x0f\x20\x01(\tR\x07orderId\x1a\xe7\
    \x02\n\x12BillingInstruments\x12e\n\x11billinginstrument\x18\x04\x20\x03\
    (\n27.PurchaseInfoProto.BillingInstruments.BillingInstrumentR\x11billing\
    instrument\x12>\n\x1adefaultBillingInstrumentId\x18\x08\x20\x01(\tR\x1ad\
    efaultBillingInstrumentId\x1a\xa9\x01\n\x11BillingInstrument\x12\x0e\n\
    \x02id\x18\x05\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x06\x20\x01(\tR\
    \x04name\x12\x1c\n\tisInvalid\x18\x07\x20\x01(\x08R\tisInvalid\x12&\n\
    \x0einstrumentType\x18\x0b\x20\x01(\x05R\x0einstrumentType\x12*\n\x10ins\
    trumentStatus\x18\x0e\x20\x01(\x05R\x10instrumentStatus\"\xa4\x01\n\x1cP\
    urchaseMetadataRequestProto\x12N\n\"deprecatedRetrieveBillingCountries\
    \x18\x01\x20\x01(\x08R\"deprecatedRetrieveBillingCountries\x124\n\x15bil\
    lingInstrumentType\x18\x02\x20\x01(\x05R\x15billingInstrumentType\"\xa3\
    \x05\n\x1dPurchaseMetadataResponseProto\x12F\n\tcountries\x18\x01\x20\
    \x01(\n2(.PurchaseMetadataResponseProto.CountriesR\tcountries\x1a\xb9\
    \x04\n\tCountries\x12J\n\x07country\x18\x02\x20\x03(\n20.PurchaseMetadat\
    aResponseProto.Countries.CountryR\x07country\x1a\xdf\x03\n\x07Country\
    \x12\x20\n\x0bcountryCode\x18\x03\x20\x01(\tR\x0bcountryCode\x12\x20\n\
    \x0bcountryName\x18\x04\x20\x01(\tR\x0bcountryName\x12E\n\x11paypalCount\
    ryInfo\x18\x05\x20\x01(\x0b2\x17.PaypalCountryInfoProtoR\x11paypalCountr\
    yInfo\x12@\n\x1ballowsReducedBillingAddress\x18\x06\x20\x01(\x08R\x1ball\
    owsReducedBillingAddress\x12|\n\x15instrumentaddressspec\x18\x07\x20\x03\
    (\n2F.PurchaseMetadataResponseProto.Countries.Country.InstrumentAddressS\
    pecR\x15instrumentaddressspec\x1a\x88\x01\n\x15InstrumentAddressSpec\x12\
    *\n\x10instrumentFamily\x18\x08\x20\x01(\x05R\x10instrumentFamily\x12C\n\
    \x12billingAddressSpec\x18\t\x20\x01(\x0b2\x13.BillingAddressSpecR\x12bi\
    llingAddressSpec\"\xd4\x05\n\x19PurchaseOrderRequestProto\x12$\n\rgaiaAu\
    thToken\x18\x01\x20\x01(\tR\rgaiaAuthToken\x12\x18\n\x07assetId\x18\x02\
    \x20\x01(\tR\x07assetId\x12$\n\rtransactionId\x18\x03\x20\x01(\tR\rtrans\
    actionId\x120\n\x13billingInstrumentId\x18\x04\x20\x01(\tR\x13billingIns\
    trumentId\x12\x20\n\x0btosAccepted\x18\x05\x20\x01(\x08R\x0btosAccepted\
    \x12]\n\x19carrierBillingCredentials\x18\x06\x20\x01(\x0b2\x1f.CarrierBi\
    llingCredentialsProtoR\x19carrierBillingCredentials\x12(\n\x0fexistingOr\
    derId\x18\x07\x20\x01(\tR\x0fexistingOrderId\x124\n\x15billingInstrument\
    Type\x18\x08\x20\x01(\x05R\x15billingInstrumentType\x120\n\x13billingPar\
    ametersId\x18\t\x20\x01(\tR\x13billingParametersId\x12E\n\x11paypalCrede\
    ntials\x18\n\x20\x01(\x0b2\x17.PaypalCredentialsProtoR\x11paypalCredenti\
    als\x12<\n\x0eriskHeaderInfo\x18\x0b\x20\x01(\x0b2\x14.RiskHeaderInfoPro\
    toR\x0eriskHeaderInfo\x12\x20\n\x0bproductType\x18\x0c\x20\x01(\x05R\x0b\
    productType\x129\n\rsignatureHash\x18\r\x20\x01(\x0b2\x13.SignatureHashP\
    rotoR\rsignatureHash\x12*\n\x10developerPayload\x18\x0e\x20\x01(\tR\x10d\
    eveloperPayload\"\xf1\x01\n\x1aPurchaseOrderResponseProto\x122\n\x14depr\
    ecatedResultCode\x18\x01\x20\x01(\x05R\x14deprecatedResultCode\x126\n\
    \x0cpurchaseInfo\x18\x02\x20\x01(\x0b2\x12.PurchaseInfoProtoR\x0cpurchas\
    eInfo\x12)\n\x05asset\x18\x03\x20\x01(\x0b2\x13.ExternalAssetProtoR\x05a\
    sset\x12<\n\x0epurchaseResult\x18\x04\x20\x01(\x0b2\x14.PurchaseResultPr\
    otoR\x0epurchaseResult\"\xe5\x05\n\x18PurchasePostRequestProto\x12$\n\rg\
    aiaAuthToken\x18\x01\x20\x01(\tR\rgaiaAuthToken\x12\x18\n\x07assetId\x18\
    \x02\x20\x01(\tR\x07assetId\x12$\n\rtransactionId\x18\x03\x20\x01(\tR\rt\
    ransactionId\x12e\n\x15billinginstrumentinfo\x18\x04\x20\x01(\n2/.Purcha\
    sePostRequestProto.BillingInstrumentInfoR\x15billinginstrumentinfo\x12\
    \x20\n\x0btosAccepted\x18\x07\x20\x01(\x08R\x0btosAccepted\x12(\n\x0fcbI\
    nstrumentKey\x18\x08\x20\x01(\tR\x0fcbInstrumentKey\x120\n\x13paypalAuth\
    Confirmed\x18\x0b\x20\x01(\x08R\x13paypalAuthConfirmed\x12\x20\n\x0bprod\
    uctType\x18\x0c\x20\x01(\x05R\x0bproductType\x129\n\rsignatureHash\x18\r\
    \x20\x01(\x0b2\x13.SignatureHashProtoR\rsignatureHash\x1a\xa0\x02\n\x15B\
    illingInstrumentInfo\x120\n\x13billingInstrumentId\x18\x05\x20\x01(\tR\
    \x13billingInstrumentId\x123\n\ncreditCard\x18\x06\x20\x01(\x0b2\x13.Ext\
    ernalCreditCardR\ncreditCard\x12T\n\x11carrierInstrument\x18\t\x20\x01(\
    \x0b2&.ExternalCarrierBillingInstrumentProtoR\x11carrierInstrument\x12J\
    \n\x10paypalInstrument\x18\n\x20\x01(\x0b2\x1e.ExternalPaypalInstrumentP\
    rotoR\x10paypalInstrument\"\xcf\x03\n\x19PurchasePostResponseProto\x122\
    \n\x14deprecatedResultCode\x18\x01\x20\x01(\x05R\x14deprecatedResultCode\
    \x126\n\x0cpurchaseInfo\x18\x02\x20\x01(\x0b2\x12.PurchaseInfoProtoR\x0c\
    purchaseInfo\x12,\n\x11termsOfServiceUrl\x18\x03\x20\x01(\tR\x11termsOfS\
    erviceUrl\x12.\n\x12termsOfServiceText\x18\x04\x20\x01(\tR\x12termsOfSer\
    viceText\x12.\n\x12termsOfServiceName\x18\x05\x20\x01(\tR\x12termsOfServ\
    iceName\x12>\n\x1atermsOfServiceCheckboxText\x18\x06\x20\x01(\tR\x1aterm\
    sOfServiceCheckboxText\x12:\n\x18termsOfServiceHeaderText\x18\x07\x20\
    \x01(\tR\x18termsOfServiceHeaderText\x12<\n\x0epurchaseResult\x18\x08\
    \x20\x01(\x0b2\x14.PurchaseResultProtoR\x0epurchaseResult\"\x98\x01\n\
    \x1bPurchaseProductRequestProto\x12\x20\n\x0bproductType\x18\x01\x20\x01\
    (\x05R\x0bproductType\x12\x1c\n\tproductId\x18\x02\x20\x01(\tR\tproductI\
    d\x129\n\rsignatureHash\x18\x03\x20\x01(\x0b2\x13.SignatureHashProtoR\rs\
    ignatureHash\"\xa2\x01\n\x1cPurchaseProductResponseProto\x12\x14\n\x05ti\
    tle\x18\x01\x20\x01(\tR\x05title\x12\x1c\n\titemTitle\x18\x02\x20\x01(\t\
    R\titemTitle\x12(\n\x0fitemDescription\x18\x03\x20\x01(\tR\x0fitemDescri\
    ption\x12$\n\rmerchantField\x18\x04\x20\x01(\tR\rmerchantField\"c\n\x13P\
    urchaseResultProto\x12\x1e\n\nresultCode\x18\x01\x20\x01(\x05R\nresultCo\
    de\x12,\n\x11resultCodeMessage\x18\x02\x20\x01(\tR\x11resultCodeMessage\
    \"\x80\x01\n\x14QuerySuggestionProto\x12\x14\n\x05query\x18\x01\x20\x01(\
    \tR\x05query\x120\n\x13estimatedNumResults\x18\x02\x20\x01(\x05R\x13esti\
    matedNumResults\x12\x20\n\x0bqueryWeight\x18\x03\x20\x01(\x05R\x0bqueryW\
    eight\"U\n\x1bQuerySuggestionRequestProto\x12\x14\n\x05query\x18\x01\x20\
    \x01(\tR\x05query\x12\x20\n\x0brequestType\x18\x02\x20\x01(\x05R\x0brequ\
    estType\"\xf7\x02\n\x1cQuerySuggestionResponseProto\x12H\n\nsuggestion\
    \x18\x01\x20\x03(\n2(.QuerySuggestionResponseProto.SuggestionR\nsuggesti\
    on\x12>\n\x1aestimatedNumAppSuggestions\x18\x04\x20\x01(\x05R\x1aestimat\
    edNumAppSuggestions\x12B\n\x1cestimatedNumQuerySuggestions\x18\x05\x20\
    \x01(\x05R\x1cestimatedNumQuerySuggestions\x1a\x88\x01\n\nSuggestion\x12\
    9\n\rappSuggestion\x18\x02\x20\x01(\x0b2\x13.AppSuggestionProtoR\rappSug\
    gestion\x12?\n\x0fquerySuggestion\x18\x03\x20\x01(\x0b2\x15.QuerySuggest\
    ionProtoR\x0fquerySuggestion\"w\n\x17RateCommentRequestProto\x12\x18\n\
    \x07assetId\x18\x01\x20\x01(\tR\x07assetId\x12\x1c\n\tcreatorId\x18\x02\
    \x20\x01(\tR\tcreatorId\x12$\n\rcommentRating\x18\x03\x20\x01(\x05R\rcom\
    mentRating\"\x1a\n\x18RateCommentResponseProto\"S\n\x1fReconstructDataba\
    seRequestProto\x120\n\x13retrieveFullHistory\x18\x01\x20\x01(\x08R\x13re\
    trieveFullHistory\"O\n\x20ReconstructDatabaseResponseProto\x12+\n\x05ass\
    et\x18\x01\x20\x03(\x0b2\x15.AssetIdentifierProtoR\x05asset\".\n\x12Refu\
    ndRequestProto\x12\x18\n\x07assetId\x18\x01\x20\x01(\tR\x07assetId\"|\n\
    \x13RefundResponseProto\x12\x16\n\x06result\x18\x01\x20\x01(\x05R\x06res\
    ult\x12)\n\x05asset\x18\x02\x20\x01(\x0b2\x13.ExternalAssetProtoR\x05ass\
    et\x12\"\n\x0cresultDetail\x18\x03\x20\x01(\tR\x0cresultDetail\"3\n\x17R\
    emoveAssetRequestProto\x12\x18\n\x07assetId\x18\x01\x20\x01(\tR\x07asset\
    Id\"\x9a\x04\n\x16RequestPropertiesProto\x12$\n\ruserAuthToken\x18\x01\
    \x20\x01(\tR\ruserAuthToken\x120\n\x13userAuthTokenSecure\x18\x02\x20\
    \x01(\x08R\x13userAuthTokenSecure\x12(\n\x0fsoftwareVersion\x18\x03\x20\
    \x01(\x05R\x0fsoftwareVersion\x12\x10\n\x03aid\x18\x04\x20\x01(\tR\x03ai\
    d\x124\n\x15productNameAndVersion\x18\x05\x20\x01(\tR\x15productNameAndV\
    ersion\x12\"\n\x0cuserLanguage\x18\x06\x20\x01(\tR\x0cuserLanguage\x12\
    \x20\n\x0buserCountry\x18\x07\x20\x01(\tR\x0buserCountry\x12\"\n\x0coper\
    atorName\x18\x08\x20\x01(\tR\x0coperatorName\x12(\n\x0fsimOperatorName\
    \x18\t\x20\x01(\tR\x0fsimOperatorName\x120\n\x13operatorNumericName\x18\
    \n\x20\x01(\tR\x13operatorNumericName\x126\n\x16simOperatorNumericName\
    \x18\x0b\x20\x01(\tR\x16simOperatorNumericName\x12\x1a\n\x08clientId\x18\
    \x0c\x20\x01(\tR\x08clientId\x12\x1c\n\tloggingId\x18\r\x20\x01(\tR\tlog\
    gingId\"\x8e\x18\n\x0cRequestProto\x12E\n\x11requestProperties\x18\x01\
    \x20\x01(\x0b2\x17.RequestPropertiesProtoR\x11requestProperties\x12/\n\
    \x07request\x18\x02\x20\x03(\n2\x15.RequestProto.RequestR\x07request\x1a\
    \x85\x17\n\x07Request\x12]\n\x19requestSpecificProperties\x18\x03\x20\
    \x01(\x0b2\x1f.RequestSpecificPropertiesProtoR\x19requestSpecificPropert\
    ies\x127\n\x0cassetRequest\x18\x04\x20\x01(\x0b2\x13.AssetsRequestProtoR\
    \x0cassetRequest\x12?\n\x0fcommentsRequest\x18\x05\x20\x01(\x0b2\x15.Com\
    mentsRequestProtoR\x0fcommentsRequest\x12N\n\x14modifyCommentRequest\x18\
    \x06\x20\x01(\x0b2\x1a.ModifyCommentRequestProtoR\x14modifyCommentReques\
    t\x12K\n\x13purchasePostRequest\x18\x07\x20\x01(\x0b2\x19.PurchasePostRe\
    questProtoR\x13purchasePostRequest\x12N\n\x14purchaseOrderRequest\x18\
    \x08\x20\x01(\x0b2\x1a.PurchaseOrderRequestProtoR\x14purchaseOrderReques\
    t\x12H\n\x12contentSyncRequest\x18\t\x20\x01(\x0b2\x18.ContentSyncReques\
    tProtoR\x12contentSyncRequest\x12?\n\x0fgetAssetRequest\x18\n\x20\x01(\
    \x0b2\x15.GetAssetRequestProtoR\x0fgetAssetRequest\x12?\n\x0fgetImageReq\
    uest\x18\x0b\x20\x01(\x0b2\x15.GetImageRequestProtoR\x0fgetImageRequest\
    \x129\n\rrefundRequest\x18\x0c\x20\x01(\x0b2\x13.RefundRequestProtoR\rre\
    fundRequest\x12W\n\x17purchaseMetadataRequest\x18\r\x20\x01(\x0b2\x1d.Pu\
    rchaseMetadataRequestProtoR\x17purchaseMetadataRequest\x12Q\n\x14subCate\
    goriesRequest\x18\x0e\x20\x01(\x0b2\x1d.GetSubCategoriesRequestProtoR\
    \x14subCategoriesRequest\x12T\n\x16uninstallReasonRequest\x18\x10\x20\
    \x01(\x0b2\x1c.UninstallReasonRequestProtoR\x16uninstallReasonRequest\
    \x12H\n\x12rateCommentRequest\x18\x11\x20\x01(\x0b2\x18.RateCommentReque\
    stProtoR\x12rateCommentRequest\x12K\n\x13checkLicenseRequest\x18\x12\x20\
    \x01(\x0b2\x19.CheckLicenseRequestProtoR\x13checkLicenseRequest\x12Z\n\
    \x18getMarketMetadataRequest\x18\x13\x20\x01(\x0b2\x1e.GetMarketMetadata\
    RequestProtoR\x18getMarketMetadataRequest\x12N\n\x14getCategoriesRequest\
    \x18\x15\x20\x01(\x0b2\x1a.GetCategoriesRequestProtoR\x14getCategoriesRe\
    quest\x12Q\n\x15getCarrierInfoRequest\x18\x16\x20\x01(\x0b2\x1b.GetCarri\
    erInfoRequestProtoR\x15getCarrierInfoRequest\x12H\n\x12removeAssetReques\
    t\x18\x17\x20\x01(\x0b2\x18.RemoveAssetRequestProtoR\x12removeAssetReque\
    st\x12`\n\x1arestoreApplicationsRequest\x18\x18\x20\x01(\x0b2\x20.Restor\
    eApplicationsRequestProtoR\x1arestoreApplicationsRequest\x12T\n\x16query\
    SuggestionRequest\x18\x19\x20\x01(\x0b2\x1c.QuerySuggestionRequestProtoR\
    \x16querySuggestionRequest\x12K\n\x13billingEventRequest\x18\x1a\x20\x01\
    (\x0b2\x19.BillingEventRequestProtoR\x13billingEventRequest\x12Z\n\x18pa\
    ypalPreapprovalRequest\x18\x1b\x20\x01(\x0b2\x1e.PaypalPreapprovalReques\
    tProtoR\x18paypalPreapprovalRequest\x12o\n\x1fpaypalPreapprovalDetailsRe\
    quest\x18\x1c\x20\x01(\x0b2%.PaypalPreapprovalDetailsRequestProtoR\x1fpa\
    ypalPreapprovalDetailsRequest\x12`\n\x1apaypalCreateAccountRequest\x18\
    \x1d\x20\x01(\x0b2\x20.PaypalCreateAccountRequestProtoR\x1apaypalCreateA\
    ccountRequest\x12{\n#paypalPreapprovalCredentialsRequest\x18\x1e\x20\x01\
    (\x0b2).PaypalPreapprovalCredentialsRequestProtoR#paypalPreapprovalCrede\
    ntialsRequest\x12o\n\x1finAppRestoreTransactionsRequest\x18\x1f\x20\x01(\
    \x0b2%.InAppRestoreTransactionsRequestProtoR\x1finAppRestoreTransactions\
    Request\x12o\n\x1finAppPurchaseInformationRequest\x18\x20\x20\x01(\x0b2%\
    .InAppPurchaseInformationRequestProtoR\x1finAppPurchaseInformationReques\
    t\x12f\n\x1ccheckForNotificationsRequest\x18!\x20\x01(\x0b2\".CheckForNo\
    tificationsRequestProtoR\x1ccheckForNotificationsRequest\x12W\n\x17ackNo\
    tificationsRequest\x18\"\x20\x01(\x0b2\x1d.AckNotificationsRequestProtoR\
    \x17ackNotificationsRequest\x12T\n\x16purchaseProductRequest\x18#\x20\
    \x01(\x0b2\x1c.PurchaseProductRequestProtoR\x16purchaseProductRequest\
    \x12`\n\x1areconstructDatabaseRequest\x18$\x20\x01(\x0b2\x20.Reconstruct\
    DatabaseRequestProtoR\x1areconstructDatabaseRequest\x12c\n\x1bpaypalMass\
    ageAddressRequest\x18%\x20\x01(\x0b2!.PaypalMassageAddressRequestProtoR\
    \x1bpaypalMassageAddressRequest\x12Z\n\x18getAddressSnippetRequest\x18&\
    \x20\x01(\x0b2\x1e.GetAddressSnippetRequestProtoR\x18getAddressSnippetRe\
    quest\"B\n\x1eRequestSpecificPropertiesProto\x12\x20\n\x0bifNoneMatch\
    \x18\x01\x20\x01(\tR\x0bifNoneMatch\"\x94\x02\n\x17ResponsePropertiesPro\
    to\x12\x16\n\x06result\x18\x01\x20\x01(\x05R\x06result\x12\x16\n\x06maxA\
    ge\x18\x02\x20\x01(\x05R\x06maxAge\x12\x12\n\x04etag\x18\x03\x20\x01(\tR\
    \x04etag\x12$\n\rserverVersion\x18\x04\x20\x01(\x05R\rserverVersion\x12*\
    \n\x10maxAgeConsumable\x18\x06\x20\x01(\x05R\x10maxAgeConsumable\x12\"\n\
    \x0cerrorMessage\x18\x07\x20\x01(\tR\x0cerrorMessage\x12?\n\x0ferrorInpu\
    tField\x18\x08\x20\x03(\x0b2\x15.InputValidationErrorR\x0ferrorInputFiel\
    d\"\xe2\x18\n\rResponseProto\x123\n\x08response\x18\x01\x20\x03(\n2\x17.\
    ResponseProto.ResponseR\x08response\x12N\n\x14pendingNotifications\x18&\
    \x20\x01(\x0b2\x1a.PendingNotificationsProtoR\x14pendingNotifications\
    \x1a\xcb\x17\n\x08Response\x12H\n\x12responseProperties\x18\x02\x20\x01(\
    \x0b2\x18.ResponsePropertiesProtoR\x12responseProperties\x12<\n\x0easset\
    sResponse\x18\x03\x20\x01(\x0b2\x14.AssetsResponseProtoR\x0eassetsRespon\
    se\x12B\n\x10commentsResponse\x18\x04\x20\x01(\x0b2\x16.CommentsResponse\
    ProtoR\x10commentsResponse\x12Q\n\x15modifyCommentResponse\x18\x05\x20\
    \x01(\x0b2\x1b.ModifyCommentResponseProtoR\x15modifyCommentResponse\x12N\
    \n\x14purchasePostResponse\x18\x06\x20\x01(\x0b2\x1a.PurchasePostRespons\
    eProtoR\x14purchasePostResponse\x12Q\n\x15purchaseOrderResponse\x18\x07\
    \x20\x01(\x0b2\x1b.PurchaseOrderResponseProtoR\x15purchaseOrderResponse\
    \x12K\n\x13contentSyncResponse\x18\x08\x20\x01(\x0b2\x19.ContentSyncResp\
    onseProtoR\x13contentSyncResponse\x12B\n\x10getAssetResponse\x18\t\x20\
    \x01(\x0b2\x16.GetAssetResponseProtoR\x10getAssetResponse\x12B\n\x10getI\
    mageResponse\x18\n\x20\x01(\x0b2\x16.GetImageResponseProtoR\x10getImageR\
    esponse\x12<\n\x0erefundResponse\x18\x0b\x20\x01(\x0b2\x14.RefundRespons\
    eProtoR\x0erefundResponse\x12Z\n\x18purchaseMetadataResponse\x18\x0c\x20\
    \x01(\x0b2\x1e.PurchaseMetadataResponseProtoR\x18purchaseMetadataRespons\
    e\x12T\n\x15subCategoriesResponse\x18\r\x20\x01(\x0b2\x1e.GetSubCategori\
    esResponseProtoR\x15subCategoriesResponse\x12W\n\x17uninstallReasonRespo\
    nse\x18\x0f\x20\x01(\x0b2\x1d.UninstallReasonResponseProtoR\x17uninstall\
    ReasonResponse\x12K\n\x13rateCommentResponse\x18\x10\x20\x01(\x0b2\x19.R\
    ateCommentResponseProtoR\x13rateCommentResponse\x12N\n\x14checkLicenseRe\
    sponse\x18\x11\x20\x01(\x0b2\x1a.CheckLicenseResponseProtoR\x14checkLice\
    nseResponse\x12]\n\x19getMarketMetadataResponse\x18\x12\x20\x01(\x0b2\
    \x1f.GetMarketMetadataResponseProtoR\x19getMarketMetadataResponse\x12B\n\
    \x10prefetchedBundle\x18\x13\x20\x03(\x0b2\x16.PrefetchedBundleProtoR\
    \x10prefetchedBundle\x12Q\n\x15getCategoriesResponse\x18\x14\x20\x01(\
    \x0b2\x1b.GetCategoriesResponseProtoR\x15getCategoriesResponse\x12T\n\
    \x16getCarrierInfoResponse\x18\x15\x20\x01(\x0b2\x1c.GetCarrierInfoRespo\
    nseProtoR\x16getCarrierInfoResponse\x12a\n\x1arestoreApplicationResponse\
    \x18\x17\x20\x01(\x0b2!.RestoreApplicationsResponseProtoR\x1arestoreAppl\
    icationResponse\x12W\n\x17querySuggestionResponse\x18\x18\x20\x01(\x0b2\
    \x1d.QuerySuggestionResponseProtoR\x17querySuggestionResponse\x12N\n\x14\
    billingEventResponse\x18\x19\x20\x01(\x0b2\x1a.BillingEventResponseProto\
    R\x14billingEventResponse\x12]\n\x19paypalPreapprovalResponse\x18\x1a\
    \x20\x01(\x0b2\x1f.PaypalPreapprovalResponseProtoR\x19paypalPreapprovalR\
    esponse\x12r\n\x20paypalPreapprovalDetailsResponse\x18\x1b\x20\x01(\x0b2\
    &.PaypalPreapprovalDetailsResponseProtoR\x20paypalPreapprovalDetailsResp\
    onse\x12c\n\x1bpaypalCreateAccountResponse\x18\x1c\x20\x01(\x0b2!.Paypal\
    CreateAccountResponseProtoR\x1bpaypalCreateAccountResponse\x12~\n$paypal\
    PreapprovalCredentialsResponse\x18\x1d\x20\x01(\x0b2*.PaypalPreapprovalC\
    redentialsResponseProtoR$paypalPreapprovalCredentialsResponse\x12r\n\x20\
    inAppRestoreTransactionsResponse\x18\x1e\x20\x01(\x0b2&.InAppRestoreTran\
    sactionsResponseProtoR\x20inAppRestoreTransactionsResponse\x12r\n\x20inA\
    ppPurchaseInformationResponse\x18\x1f\x20\x01(\x0b2&.InAppPurchaseInform\
    ationResponseProtoR\x20inAppPurchaseInformationResponse\x12i\n\x1dcheckF\
    orNotificationsResponse\x18\x20\x20\x01(\x0b2#.CheckForNotificationsResp\
    onseProtoR\x1dcheckForNotificationsResponse\x12Z\n\x18ackNotificationsRe\
    sponse\x18!\x20\x01(\x0b2\x1e.AckNotificationsResponseProtoR\x18ackNotif\
    icationsResponse\x12W\n\x17purchaseProductResponse\x18\"\x20\x01(\x0b2\
    \x1d.PurchaseProductResponseProtoR\x17purchaseProductResponse\x12c\n\x1b\
    reconstructDatabaseResponse\x18#\x20\x01(\x0b2!.ReconstructDatabaseRespo\
    nseProtoR\x1breconstructDatabaseResponse\x12f\n\x1cpaypalMassageAddressR\
    esponse\x18$\x20\x01(\x0b2\".PaypalMassageAddressResponseProtoR\x1cpaypa\
    lMassageAddressResponse\x12]\n\x19getAddressSnippetResponse\x18%\x20\x01\
    (\x0b2\x1f.GetAddressSnippetResponseProtoR\x19getAddressSnippetResponse\
    \"\xb8\x01\n\x1fRestoreApplicationsRequestProto\x12(\n\x0fbackupAndroidI\
    d\x18\x01\x20\x01(\tR\x0fbackupAndroidId\x12\x1e\n\ntosVersion\x18\x02\
    \x20\x01(\tR\ntosVersion\x12K\n\x13deviceConfiguration\x18\x03\x20\x01(\
    \x0b2\x19.DeviceConfigurationProtoR\x13deviceConfiguration\"P\n\x20Resto\
    reApplicationsResponseProto\x12,\n\x05asset\x18\x01\x20\x03(\x0b2\x16.Ge\
    tAssetResponseProtoR\x05asset\"A\n\x13RiskHeaderInfoProto\x12*\n\x10hash\
    edDeviceInfo\x18\x01\x20\x01(\tR\x10hashedDeviceInfo\"l\n\x12SignatureHa\
    shProto\x12\x20\n\x0bpackageName\x18\x01\x20\x01(\tR\x0bpackageName\x12\
    \x20\n\x0bversionCode\x18\x02\x20\x01(\x05R\x0bversionCode\x12\x12\n\x04\
    hash\x18\x03\x20\x01(\x0cR\x04hash\"O\n\x0fSignedDataProto\x12\x1e\n\nsi\
    gnedData\x18\x01\x20\x01(\tR\nsignedData\x12\x1c\n\tsignature\x18\x02\
    \x20\x01(\tR\tsignature\"\x96\x17\n\x12SingleRequestProto\x12]\n\x19requ\
    estSpecificProperties\x18\x03\x20\x01(\x0b2\x1f.RequestSpecificPropertie\
    sProtoR\x19requestSpecificProperties\x127\n\x0cassetRequest\x18\x04\x20\
    \x01(\x0b2\x13.AssetsRequestProtoR\x0cassetRequest\x12?\n\x0fcommentsReq\
    uest\x18\x05\x20\x01(\x0b2\x15.CommentsRequestProtoR\x0fcommentsRequest\
    \x12N\n\x14modifyCommentRequest\x18\x06\x20\x01(\x0b2\x1a.ModifyCommentR\
    equestProtoR\x14modifyCommentRequest\x12K\n\x13purchasePostRequest\x18\
    \x07\x20\x01(\x0b2\x19.PurchasePostRequestProtoR\x13purchasePostRequest\
    \x12N\n\x14purchaseOrderRequest\x18\x08\x20\x01(\x0b2\x1a.PurchaseOrderR\
    equestProtoR\x14purchaseOrderRequest\x12H\n\x12contentSyncRequest\x18\t\
    \x20\x01(\x0b2\x18.ContentSyncRequestProtoR\x12contentSyncRequest\x12?\n\
    \x0fgetAssetRequest\x18\n\x20\x01(\x0b2\x15.GetAssetRequestProtoR\x0fget\
    AssetRequest\x12?\n\x0fgetImageRequest\x18\x0b\x20\x01(\x0b2\x15.GetImag\
    eRequestProtoR\x0fgetImageRequest\x129\n\rrefundRequest\x18\x0c\x20\x01(\
    \x0b2\x13.RefundRequestProtoR\rrefundRequest\x12W\n\x17purchaseMetadataR\
    equest\x18\r\x20\x01(\x0b2\x1d.PurchaseMetadataRequestProtoR\x17purchase\
    MetadataRequest\x12Q\n\x14subCategoriesRequest\x18\x0e\x20\x01(\x0b2\x1d\
    .GetSubCategoriesRequestProtoR\x14subCategoriesRequest\x12T\n\x16uninsta\
    llReasonRequest\x18\x10\x20\x01(\x0b2\x1c.UninstallReasonRequestProtoR\
    \x16uninstallReasonRequest\x12H\n\x12rateCommentRequest\x18\x11\x20\x01(\
    \x0b2\x18.RateCommentRequestProtoR\x12rateCommentRequest\x12K\n\x13check\
    LicenseRequest\x18\x12\x20\x01(\x0b2\x19.CheckLicenseRequestProtoR\x13ch\
    eckLicenseRequest\x12Z\n\x18getMarketMetadataRequest\x18\x13\x20\x01(\
    \x0b2\x1e.GetMarketMetadataRequestProtoR\x18getMarketMetadataRequest\x12\
    N\n\x14getCategoriesRequest\x18\x15\x20\x01(\x0b2\x1a.GetCategoriesReque\
    stProtoR\x14getCategoriesRequest\x12Q\n\x15getCarrierInfoRequest\x18\x16\
    \x20\x01(\x0b2\x1b.GetCarrierInfoRequestProtoR\x15getCarrierInfoRequest\
    \x12H\n\x12removeAssetRequest\x18\x17\x20\x01(\x0b2\x18.RemoveAssetReque\
    stProtoR\x12removeAssetRequest\x12`\n\x1arestoreApplicationsRequest\x18\
    \x18\x20\x01(\x0b2\x20.RestoreApplicationsRequestProtoR\x1arestoreApplic\
    ationsRequest\x12T\n\x16querySuggestionRequest\x18\x19\x20\x01(\x0b2\x1c\
    .QuerySuggestionRequestProtoR\x16querySuggestionRequest\x12K\n\x13billin\
    gEventRequest\x18\x1a\x20\x01(\x0b2\x19.BillingEventRequestProtoR\x13bil\
    lingEventRequest\x12Z\n\x18paypalPreapprovalRequest\x18\x1b\x20\x01(\x0b\
    2\x1e.PaypalPreapprovalRequestProtoR\x18paypalPreapprovalRequest\x12o\n\
    \x1fpaypalPreapprovalDetailsRequest\x18\x1c\x20\x01(\x0b2%.PaypalPreappr\
    ovalDetailsRequestProtoR\x1fpaypalPreapprovalDetailsRequest\x12`\n\x1apa\
    ypalCreateAccountRequest\x18\x1d\x20\x01(\x0b2\x20.PaypalCreateAccountRe\
    questProtoR\x1apaypalCreateAccountRequest\x12{\n#paypalPreapprovalCreden\
    tialsRequest\x18\x1e\x20\x01(\x0b2).PaypalPreapprovalCredentialsRequestP\
    rotoR#paypalPreapprovalCredentialsRequest\x12o\n\x1finAppRestoreTransact\
    ionsRequest\x18\x1f\x20\x01(\x0b2%.InAppRestoreTransactionsRequestProtoR\
    \x1finAppRestoreTransactionsRequest\x12u\n\"getInAppPurchaseInformationR\
    equest\x18\x20\x20\x01(\x0b2%.InAppPurchaseInformationRequestProtoR\"get\
    InAppPurchaseInformationRequest\x12f\n\x1ccheckForNotificationsRequest\
    \x18!\x20\x01(\x0b2\".CheckForNotificationsRequestProtoR\x1ccheckForNoti\
    ficationsRequest\x12W\n\x17ackNotificationsRequest\x18\"\x20\x01(\x0b2\
    \x1d.AckNotificationsRequestProtoR\x17ackNotificationsRequest\x12T\n\x16\
    purchaseProductRequest\x18#\x20\x01(\x0b2\x1c.PurchaseProductRequestProt\
    oR\x16purchaseProductRequest\x12`\n\x1areconstructDatabaseRequest\x18$\
    \x20\x01(\x0b2\x20.ReconstructDatabaseRequestProtoR\x1areconstructDataba\
    seRequest\x12c\n\x1bpaypalMassageAddressRequest\x18%\x20\x01(\x0b2!.Payp\
    alMassageAddressRequestProtoR\x1bpaypalMassageAddressRequest\x12Z\n\x18g\
    etAddressSnippetRequest\x18&\x20\x01(\x0b2\x1e.GetAddressSnippetRequestP\
    rotoR\x18getAddressSnippetRequest\"\x98\x17\n\x13SingleResponseProto\x12\
    H\n\x12responseProperties\x18\x02\x20\x01(\x0b2\x18.ResponsePropertiesPr\
    otoR\x12responseProperties\x12<\n\x0eassetsResponse\x18\x03\x20\x01(\x0b\
    2\x14.AssetsResponseProtoR\x0eassetsResponse\x12B\n\x10commentsResponse\
    \x18\x04\x20\x01(\x0b2\x16.CommentsResponseProtoR\x10commentsResponse\
    \x12Q\n\x15modifyCommentResponse\x18\x05\x20\x01(\x0b2\x1b.ModifyComment\
    ResponseProtoR\x15modifyCommentResponse\x12N\n\x14purchasePostResponse\
    \x18\x06\x20\x01(\x0b2\x1a.PurchasePostResponseProtoR\x14purchasePostRes\
    ponse\x12Q\n\x15purchaseOrderResponse\x18\x07\x20\x01(\x0b2\x1b.Purchase\
    OrderResponseProtoR\x15purchaseOrderResponse\x12K\n\x13contentSyncRespon\
    se\x18\x08\x20\x01(\x0b2\x19.ContentSyncResponseProtoR\x13contentSyncRes\
    ponse\x12B\n\x10getAssetResponse\x18\t\x20\x01(\x0b2\x16.GetAssetRespons\
    eProtoR\x10getAssetResponse\x12B\n\x10getImageResponse\x18\n\x20\x01(\
    \x0b2\x16.GetImageResponseProtoR\x10getImageResponse\x12<\n\x0erefundRes\
    ponse\x18\x0b\x20\x01(\x0b2\x14.RefundResponseProtoR\x0erefundResponse\
    \x12Z\n\x18purchaseMetadataResponse\x18\x0c\x20\x01(\x0b2\x1e.PurchaseMe\
    tadataResponseProtoR\x18purchaseMetadataResponse\x12T\n\x15subCategories\
    Response\x18\r\x20\x01(\x0b2\x1e.GetSubCategoriesResponseProtoR\x15subCa\
    tegoriesResponse\x12W\n\x17uninstallReasonResponse\x18\x0f\x20\x01(\x0b2\
    \x1d.UninstallReasonResponseProtoR\x17uninstallReasonResponse\x12K\n\x13\
    rateCommentResponse\x18\x10\x20\x01(\x0b2\x19.RateCommentResponseProtoR\
    \x13rateCommentResponse\x12N\n\x14checkLicenseResponse\x18\x11\x20\x01(\
    \x0b2\x1a.CheckLicenseResponseProtoR\x14checkLicenseResponse\x12]\n\x19g\
    etMarketMetadataResponse\x18\x12\x20\x01(\x0b2\x1f.GetMarketMetadataResp\
    onseProtoR\x19getMarketMetadataResponse\x12Q\n\x15getCategoriesResponse\
    \x18\x14\x20\x01(\x0b2\x1b.GetCategoriesResponseProtoR\x15getCategoriesR\
    esponse\x12T\n\x16getCarrierInfoResponse\x18\x15\x20\x01(\x0b2\x1c.GetCa\
    rrierInfoResponseProtoR\x16getCarrierInfoResponse\x12a\n\x1arestoreAppli\
    cationResponse\x18\x17\x20\x01(\x0b2!.RestoreApplicationsResponseProtoR\
    \x1arestoreApplicationResponse\x12W\n\x17querySuggestionResponse\x18\x18\
    \x20\x01(\x0b2\x1d.QuerySuggestionResponseProtoR\x17querySuggestionRespo\
    nse\x12N\n\x14billingEventResponse\x18\x19\x20\x01(\x0b2\x1a.BillingEven\
    tResponseProtoR\x14billingEventResponse\x12]\n\x19paypalPreapprovalRespo\
    nse\x18\x1a\x20\x01(\x0b2\x1f.PaypalPreapprovalResponseProtoR\x19paypalP\
    reapprovalResponse\x12r\n\x20paypalPreapprovalDetailsResponse\x18\x1b\
    \x20\x01(\x0b2&.PaypalPreapprovalDetailsResponseProtoR\x20paypalPreappro\
    valDetailsResponse\x12c\n\x1bpaypalCreateAccountResponse\x18\x1c\x20\x01\
    (\x0b2!.PaypalCreateAccountResponseProtoR\x1bpaypalCreateAccountResponse\
    \x12~\n$paypalPreapprovalCredentialsResponse\x18\x1d\x20\x01(\x0b2*.Payp\
    alPreapprovalCredentialsResponseProtoR$paypalPreapprovalCredentialsRespo\
    nse\x12r\n\x20inAppRestoreTransactionsResponse\x18\x1e\x20\x01(\x0b2&.In\
    AppRestoreTransactionsResponseProtoR\x20inAppRestoreTransactionsResponse\
    \x12x\n#getInAppPurchaseInformationResponse\x18\x1f\x20\x01(\x0b2&.InApp\
    PurchaseInformationResponseProtoR#getInAppPurchaseInformationResponse\
    \x12i\n\x1dcheckForNotificationsResponse\x18\x20\x20\x01(\x0b2#.CheckFor\
    NotificationsResponseProtoR\x1dcheckForNotificationsResponse\x12Z\n\x18a\
    ckNotificationsResponse\x18!\x20\x01(\x0b2\x1e.AckNotificationsResponseP\
    rotoR\x18ackNotificationsResponse\x12W\n\x17purchaseProductResponse\x18\
    \"\x20\x01(\x0b2\x1d.PurchaseProductResponseProtoR\x17purchaseProductRes\
    ponse\x12c\n\x1breconstructDatabaseResponse\x18#\x20\x01(\x0b2!.Reconstr\
    uctDatabaseResponseProtoR\x1breconstructDatabaseResponse\x12f\n\x1cpaypa\
    lMassageAddressResponse\x18$\x20\x01(\x0b2\".PaypalMassageAddressRespons\
    eProtoR\x1cpaypalMassageAddressResponse\x12]\n\x19getAddressSnippetRespo\
    nse\x18%\x20\x01(\x0b2\x1f.GetAddressSnippetResponseProtoR\x19getAddress\
    SnippetResponse\"\x82\x01\n\x1aStatusBarNotificationProto\x12\x1e\n\ntic\
    kerText\x18\x01\x20\x01(\tR\ntickerText\x12\"\n\x0ccontentTitle\x18\x02\
    \x20\x01(\tR\x0ccontentTitle\x12\x20\n\x0bcontentText\x18\x03\x20\x01(\t\
    R\x0bcontentText\"O\n\x1bUninstallReasonRequestProto\x12\x18\n\x07assetI\
    d\x18\x01\x20\x01(\tR\x07assetId\x12\x16\n\x06reason\x18\x02\x20\x01(\
    \x05R\x06reason\"\x1e\n\x1cUninstallReasonResponseProto\"\x9b\x02\n\x15C\
    riticReviewsResponse\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\
    6\n\x12aggregateSentiment\x18\x02\x20\x01(\x0b2\x06.ImageR\x12aggregateS\
    entiment\x12(\n\x0ftotalNumReviews\x18\x03\x20\x01(\rR\x0ftotalNumReview\
    s\x12*\n\x10percentFavorable\x18\x04\x20\x01(\rR\x10percentFavorable\x12\
    \x1e\n\nsourceText\x18\x05\x20\x01(\tR\nsourceText\x12\x1d\n\x06source\
    \x18\x06\x20\x01(\x0b2\x05.LinkR\x06source\x12\x1f\n\x06review\x18\x07\
    \x20\x03(\x0b2\x07.ReviewR\x06review\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
